-- #################################################### --

local si_fceq = class(Node)

function si_fceq:get_help(out)
  out.write[[ Floating Compare Equal  

 rt.w[n] = (ra.f[n] == rb.f[n]) ? 0xF… : 0x0… ]]
end

function si_fceq:new()
  Node.new(self)
  self.ra = self.add_port(Input('ra'))
  self.rb = self.add_port(Input('rb'))
  self.rt = self.add_port(Output('rt'))
end

function si_fceq:config(props)
  Node.config(self, props)
  props.delete('Name')
end

function si_fceq:gen_code(out, scratch)
  local rt = 'r' .. self.rt.hex()
  local ra = 'r' .. self.ra.get_output().hex()
  local rb = 'r' .. self.rb.get_output().hex()
  out.write( '\t .reg ' .. rt .. '\n')
  out.write( '\t fceq ' .. rt .. ', ' .. ra .. ', ' .. rb .. '\n' )
end

function si_fceq:get_tip(out)
  out.write('Floating Compare Equal ')
end

function si_fceq:get_type(port)
  return 'qword'
end

-- #################################################### --

local si_fcgt = class(Node)

function si_fcgt:get_help(out)
  out.write[[ Floating Compare Greater Than  

 rt.w[n] = (ra.f[n] > rb.f[n]) ? 0xF… : 0x0… ]]
end

function si_fcgt:new()
  Node.new(self)
  self.ra = self.add_port(Input('ra'))
  self.rb = self.add_port(Input('rb'))
  self.rt = self.add_port(Output('rt'))
end

function si_fcgt:config(props)
  Node.config(self, props)
  props.delete('Name')
end

function si_fcgt:gen_code(out, scratch)
  local rt = 'r' .. self.rt.hex()
  local ra = 'r' .. self.ra.get_output().hex()
  local rb = 'r' .. self.rb.get_output().hex()
  out.write( '\t .reg ' .. rt .. '\n')
  out.write( '\t fcgt ' .. rt .. ', ' .. ra .. ', ' .. rb .. '\n' )
end

function si_fcgt:get_tip(out)
  out.write('Floating Compare Greater Than ')
end

function si_fcgt:get_type(port)
  return 'qword'
end

-- #################################################### --

local si_fcmeq = class(Node)

function si_fcmeq:get_help(out)
  out.write[[ Floating Compare Magnitude Equal  

 rt.w[n] = (abs(ra.f[n]) == abs(rb.f[n])) ? 0xF… : 0x0… ]]
end

function si_fcmeq:new()
  Node.new(self)
  self.ra = self.add_port(Input('ra'))
  self.rb = self.add_port(Input('rb'))
  self.rt = self.add_port(Output('rt'))
end

function si_fcmeq:config(props)
  Node.config(self, props)
  props.delete('Name')
end

function si_fcmeq:gen_code(out, scratch)
  local rt = 'r' .. self.rt.hex()
  local ra = 'r' .. self.ra.get_output().hex()
  local rb = 'r' .. self.rb.get_output().hex()
  out.write( '\t .reg ' .. rt .. '\n')
  out.write( '\t fcmeq ' .. rt .. ', ' .. ra .. ', ' .. rb .. '\n' )
end

function si_fcmeq:get_tip(out)
  out.write('Floating Compare Magnitude Equal ')
end

function si_fcmeq:get_type(port)
  return 'qword'
end

-- #################################################### --

local si_fcmgt = class(Node)

function si_fcmgt:get_help(out)
  out.write[[ Floating Compare Magnitude Greater Than  

 rt.w[n] = (abs(ra.f[n]) > abs(rb.f[n])) ? 0xF… : 0x0… ]]
end

function si_fcmgt:new()
  Node.new(self)
  self.ra = self.add_port(Input('ra'))
  self.rb = self.add_port(Input('rb'))
  self.rt = self.add_port(Output('rt'))
end

function si_fcmgt:config(props)
  Node.config(self, props)
  props.delete('Name')
end

function si_fcmgt:gen_code(out, scratch)
  local rt = 'r' .. self.rt.hex()
  local ra = 'r' .. self.ra.get_output().hex()
  local rb = 'r' .. self.rb.get_output().hex()
  out.write( '\t .reg ' .. rt .. '\n')
  out.write( '\t fcmgt ' .. rt .. ', ' .. ra .. ', ' .. rb .. '\n' )
end

function si_fcmgt:get_tip(out)
  out.write('Floating Compare Magnitude Greater Than ')
end

function si_fcmgt:get_type(port)
  return 'qword'
end

register {
  __name = 'SPU [Float Compare]',
  __prologue = '',
  __epilogue = '',
  ['fceq'] = si_fceq,
  ['fcgt'] = si_fcgt,
  ['fcmeq'] = si_fcmeq,
  ['fcmgt'] = si_fcmgt,
}
