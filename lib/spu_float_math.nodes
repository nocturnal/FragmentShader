-- #################################################### --

local si_frest = class(Node)

function si_frest:get_help(out)
  out.write[[ Floating Reciprocal Estimate  

  ]]
end

function si_frest:new()
  Node.new(self)
  self.ra = self.add_port(Input('ra'))
  self.rt = self.add_port(Output('rt'))
end

function si_frest:config(props)
  Node.config(self, props)
  props.delete('Name')
end

function si_frest:gen_code(out, scratch)
  local rt = 'r' .. self.rt.hex()
  local ra = 'r' .. self.ra.get_output().hex()
  out.write( '\t .reg ' .. rt .. '\n')
  out.write( '\t frest ' .. rt .. ', ' .. ra .. '\n' )
end

function si_frest:get_tip(out)
  out.write('Floating Reciprocal Estimate ')
end

function si_frest:get_type(port)
  return 'qword'
end

-- #################################################### --

local si_frsqest = class(Node)

function si_frsqest:get_help(out)
  out.write[[ Floating Reciprocal Absolute Square Root Estimate  

  ]]
end

function si_frsqest:new()
  Node.new(self)
  self.ra = self.add_port(Input('ra'))
  self.rt = self.add_port(Output('rt'))
end

function si_frsqest:config(props)
  Node.config(self, props)
  props.delete('Name')
end

function si_frsqest:gen_code(out, scratch)
  local rt = 'r' .. self.rt.hex()
  local ra = 'r' .. self.ra.get_output().hex()
  out.write( '\t .reg ' .. rt .. '\n')
  out.write( '\t frsqest ' .. rt .. ', ' .. ra .. '\n' )
end

function si_frsqest:get_tip(out)
  out.write('Floating Reciprocal Absolute Square Root Estimate ')
end

function si_frsqest:get_type(port)
  return 'qword'
end

-- #################################################### --

local si_fi = class(Node)

function si_fi:get_help(out)
  out.write[[ Floating Interpolate  

 rt will have 12 bit precision ]]
end

function si_fi:new()
  Node.new(self)
  self.ra = self.add_port(Input('ra'))
  self.rb = self.add_port(Input('rb'))
  self.rt = self.add_port(Output('rt'))
end

function si_fi:config(props)
  Node.config(self, props)
  props.delete('Name')
end

function si_fi:gen_code(out, scratch)
  local rt = 'r' .. self.rt.hex()
  local ra = 'r' .. self.ra.get_output().hex()
  local rb = 'r' .. self.rb.get_output().hex()
  out.write( '\t .reg ' .. rt .. '\n')
  out.write( '\t fi ' .. rt .. ', ' .. ra .. ', ' .. rb .. '\n' )
end

function si_fi:get_tip(out)
  out.write('Floating Interpolate ')
end

function si_fi:get_type(port)
  return 'qword'
end

-- #################################################### --

local si_fa = class(Node)

function si_fa:get_help(out)
  out.write[[ Floating Add  

 rt.f[n] = ra.f[n] + rb.f[n] ]]
end

function si_fa:new()
  Node.new(self)
  self.ra = self.add_port(Input('ra'))
  self.rb = self.add_port(Input('rb'))
  self.rt = self.add_port(Output('rt'))
end

function si_fa:config(props)
  Node.config(self, props)
  props.delete('Name')
end

function si_fa:gen_code(out, scratch)
  local rt = 'r' .. self.rt.hex()
  local ra = 'r' .. self.ra.get_output().hex()
  local rb = 'r' .. self.rb.get_output().hex()
  out.write( '\t .reg ' .. rt .. '\n')
  out.write( '\t fa ' .. rt .. ', ' .. ra .. ', ' .. rb .. '\n' )
end

function si_fa:get_tip(out)
  out.write('Floating Add ')
end

function si_fa:get_type(port)
  return 'qword'
end

-- #################################################### --

local si_fs = class(Node)

function si_fs:get_help(out)
  out.write[[ Floating Subtract  

 rt.f[n] = ra.f[n] – rb.f[n] ]]
end

function si_fs:new()
  Node.new(self)
  self.ra = self.add_port(Input('ra'))
  self.rb = self.add_port(Input('rb'))
  self.rt = self.add_port(Output('rt'))
end

function si_fs:config(props)
  Node.config(self, props)
  props.delete('Name')
end

function si_fs:gen_code(out, scratch)
  local rt = 'r' .. self.rt.hex()
  local ra = 'r' .. self.ra.get_output().hex()
  local rb = 'r' .. self.rb.get_output().hex()
  out.write( '\t .reg ' .. rt .. '\n')
  out.write( '\t fs ' .. rt .. ', ' .. ra .. ', ' .. rb .. '\n' )
end

function si_fs:get_tip(out)
  out.write('Floating Subtract ')
end

function si_fs:get_type(port)
  return 'qword'
end

-- #################################################### --

local si_fm = class(Node)

function si_fm:get_help(out)
  out.write[[ Floating Multiply  

 rt.f[n] = ra.f[n] * rb.f[n] ]]
end

function si_fm:new()
  Node.new(self)
  self.ra = self.add_port(Input('ra'))
  self.rb = self.add_port(Input('rb'))
  self.rt = self.add_port(Output('rt'))
end

function si_fm:config(props)
  Node.config(self, props)
  props.delete('Name')
end

function si_fm:gen_code(out, scratch)
  local rt = 'r' .. self.rt.hex()
  local ra = 'r' .. self.ra.get_output().hex()
  local rb = 'r' .. self.rb.get_output().hex()
  out.write( '\t .reg ' .. rt .. '\n')
  out.write( '\t fm ' .. rt .. ', ' .. ra .. ', ' .. rb .. '\n' )
end

function si_fm:get_tip(out)
  out.write('Floating Multiply ')
end

function si_fm:get_type(port)
  return 'qword'
end

-- #################################################### --

local si_fma = class(Node)

function si_fma:get_help(out)
  out.write[[ Floating Multiply and Add  

 rt.f[n] = ra.f[n] * rb.f[n] + rc.f[n] ]]
end

function si_fma:new()
  Node.new(self)
  self.ra = self.add_port(Input('ra'))
  self.rb = self.add_port(Input('rb'))
  self.rc = self.add_port(Input('rc'))
  self.rt = self.add_port(Output('rt'))
end

function si_fma:config(props)
  Node.config(self, props)
  props.delete('Name')
end

function si_fma:gen_code(out, scratch)
  local rt = 'r' .. self.rt.hex()
  local ra = 'r' .. self.ra.get_output().hex()
  local rb = 'r' .. self.rb.get_output().hex()
  local rc = 'r' .. self.rc.get_output().hex()
  out.write( '\t .reg ' .. rt .. '\n')
  out.write( '\t fma ' .. rt .. ', ' .. ra .. ', ' .. rb .. ', ' .. rc .. '\n' )
end

function si_fma:get_tip(out)
  out.write('Floating Multiply and Add ')
end

function si_fma:get_type(port)
  return 'qword'
end

-- #################################################### --

local si_fms = class(Node)

function si_fms:get_help(out)
  out.write[[ Floating Multiply and Subtract  

 rt.f[n] = ra.f[n] * rb.f[n] - rc.f[n] ]]
end

function si_fms:new()
  Node.new(self)
  self.ra = self.add_port(Input('ra'))
  self.rb = self.add_port(Input('rb'))
  self.rc = self.add_port(Input('rc'))
  self.rt = self.add_port(Output('rt'))
end

function si_fms:config(props)
  Node.config(self, props)
  props.delete('Name')
end

function si_fms:gen_code(out, scratch)
  local rt = 'r' .. self.rt.hex()
  local ra = 'r' .. self.ra.get_output().hex()
  local rb = 'r' .. self.rb.get_output().hex()
  local rc = 'r' .. self.rc.get_output().hex()
  out.write( '\t .reg ' .. rt .. '\n')
  out.write( '\t fms ' .. rt .. ', ' .. ra .. ', ' .. rb .. ', ' .. rc .. '\n' )
end

function si_fms:get_tip(out)
  out.write('Floating Multiply and Subtract ')
end

function si_fms:get_type(port)
  return 'qword'
end

-- #################################################### --

local si_fnms = class(Node)

function si_fnms:get_help(out)
  out.write[[ Floating Negative Multiply and Subtract  

 -(rt.f[n] = ra.f[n] * rb.f[n] - rc.f[n]) ]]
end

function si_fnms:new()
  Node.new(self)
  self.ra = self.add_port(Input('ra'))
  self.rb = self.add_port(Input('rb'))
  self.rc = self.add_port(Input('rc'))
  self.rt = self.add_port(Output('rt'))
end

function si_fnms:config(props)
  Node.config(self, props)
  props.delete('Name')
end

function si_fnms:gen_code(out, scratch)
  local rt = 'r' .. self.rt.hex()
  local ra = 'r' .. self.ra.get_output().hex()
  local rb = 'r' .. self.rb.get_output().hex()
  local rc = 'r' .. self.rc.get_output().hex()
  out.write( '\t .reg ' .. rt .. '\n')
  out.write( '\t fnms ' .. rt .. ', ' .. ra .. ', ' .. rb .. ', ' .. rc .. '\n' )
end

function si_fnms:get_tip(out)
  out.write('Floating Negative Multiply and Subtract ')
end

function si_fnms:get_type(port)
  return 'qword'
end

register {
  __name = 'SPU [Float Math]',
  __prologue = '',
  __epilogue = '',
  ['frest'] = si_frest,
  ['frsqest'] = si_frsqest,
  ['fi'] = si_fi,
  ['fa'] = si_fa,
  ['fs'] = si_fs,
  ['fm'] = si_fm,
  ['fma'] = si_fma,
  ['fms'] = si_fms,
  ['fnms'] = si_fnms,
}
