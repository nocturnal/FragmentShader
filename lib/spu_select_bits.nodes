-- #################################################### --

local si_selb = class(Node)

function si_selb:get_help(out)
  out.write[[ Select Bits  

 rt.bi[n] = (rc.bi[n] == 0) ? ra.bi[n] : rb.bi[n] ]]
end

function si_selb:new()
  Node.new(self)
  self.ra = self.add_port(Input('ra'))
  self.rb = self.add_port(Input('rb'))
  self.rc = self.add_port(Input('rc'))
  self.rt = self.add_port(Output('rt'))
end

function si_selb:config(props)
  Node.config(self, props)
  props.delete('Name')
end

function si_selb:gen_code(out, scratch)
  local rt = 'r' .. self.rt.hex()
  local ra = 'r' .. self.ra.get_output().hex()
  local rb = 'r' .. self.rb.get_output().hex()
  local rc = 'r' .. self.rc.get_output().hex()
  out.write( '\t .reg ' .. rt .. '\n')
  out.write( '\t selb ' .. rt .. ', ' .. ra .. ', ' .. rb .. ', ' .. rc .. '\n' )
end

function si_selb:get_tip(out)
  out.write('Select Bits ')
end

function si_selb:get_type(port)
  return 'qword'
end

-- #################################################### --

local si_gb = class(Node)

function si_gb:get_help(out)
  out.write[[ Gather Bits from Words  

 rt=0;for(n=0;n<4;n++){rt.w[0]|=(rb.w[n]&1);rt.w[0]<<=1} ]]
end

function si_gb:new()
  Node.new(self)
  self.ra = self.add_port(Input('ra'))
  self.rt = self.add_port(Output('rt'))
end

function si_gb:config(props)
  Node.config(self, props)
  props.delete('Name')
end

function si_gb:gen_code(out, scratch)
  local rt = 'r' .. self.rt.hex()
  local ra = 'r' .. self.ra.get_output().hex()
  out.write( '\t .reg ' .. rt .. '\n')
  out.write( '\t gb ' .. rt .. ', ' .. ra .. '\n' )
end

function si_gb:get_tip(out)
  out.write('Gather Bits from Words ')
end

function si_gb:get_type(port)
  return 'qword'
end

-- #################################################### --

local si_gbh = class(Node)

function si_gbh:get_help(out)
  out.write[[ Gather Bits from Halfwords  

 rt=0;for(n=0;n<8;n++){rt.w[0]|=(rb.h[n]&1);rt.w[0]<<=1} ]]
end

function si_gbh:new()
  Node.new(self)
  self.ra = self.add_port(Input('ra'))
  self.rt = self.add_port(Output('rt'))
end

function si_gbh:config(props)
  Node.config(self, props)
  props.delete('Name')
end

function si_gbh:gen_code(out, scratch)
  local rt = 'r' .. self.rt.hex()
  local ra = 'r' .. self.ra.get_output().hex()
  out.write( '\t .reg ' .. rt .. '\n')
  out.write( '\t gbh ' .. rt .. ', ' .. ra .. '\n' )
end

function si_gbh:get_tip(out)
  out.write('Gather Bits from Halfwords ')
end

function si_gbh:get_type(port)
  return 'qword'
end

-- #################################################### --

local si_gbb = class(Node)

function si_gbb:get_help(out)
  out.write[[ Gather Bits from Bytes  

 rt=0;for(n=0;n<16;n++){rt.w[0]|=(rb.b[n]&1);rt.w[0]<<=1} ]]
end

function si_gbb:new()
  Node.new(self)
  self.ra = self.add_port(Input('ra'))
  self.rt = self.add_port(Output('rt'))
end

function si_gbb:config(props)
  Node.config(self, props)
  props.delete('Name')
end

function si_gbb:gen_code(out, scratch)
  local rt = 'r' .. self.rt.hex()
  local ra = 'r' .. self.ra.get_output().hex()
  out.write( '\t .reg ' .. rt .. '\n')
  out.write( '\t gbb ' .. rt .. ', ' .. ra .. '\n' )
end

function si_gbb:get_tip(out)
  out.write('Gather Bits from Bytes ')
end

function si_gbb:get_type(port)
  return 'qword'
end

-- #################################################### --

local si_fsm = class(Node)

function si_fsm:get_help(out)
  out.write[[ Form Select Mask for Words  

 rt.w[n] = ((ra.b[3] << n) & 0x8) ? 0xF... : 0x0… ]]
end

function si_fsm:new()
  Node.new(self)
  self.ra = self.add_port(Input('ra'))
  self.rt = self.add_port(Output('rt'))
end

function si_fsm:config(props)
  Node.config(self, props)
  props.delete('Name')
end

function si_fsm:gen_code(out, scratch)
  local rt = 'r' .. self.rt.hex()
  local ra = 'r' .. self.ra.get_output().hex()
  out.write( '\t .reg ' .. rt .. '\n')
  out.write( '\t fsm ' .. rt .. ', ' .. ra .. '\n' )
end

function si_fsm:get_tip(out)
  out.write('Form Select Mask for Words ')
end

function si_fsm:get_type(port)
  return 'qword'
end

-- #################################################### --

local si_fsmh = class(Node)

function si_fsmh:get_help(out)
  out.write[[ Form Select Mask for Halfwords  

 rt.h[n] = ((ra.b[3] << n) & 0x80) ? 0xF… : 0x0… ]]
end

function si_fsmh:new()
  Node.new(self)
  self.ra = self.add_port(Input('ra'))
  self.rt = self.add_port(Output('rt'))
end

function si_fsmh:config(props)
  Node.config(self, props)
  props.delete('Name')
end

function si_fsmh:gen_code(out, scratch)
  local rt = 'r' .. self.rt.hex()
  local ra = 'r' .. self.ra.get_output().hex()
  out.write( '\t .reg ' .. rt .. '\n')
  out.write( '\t fsmh ' .. rt .. ', ' .. ra .. '\n' )
end

function si_fsmh:get_tip(out)
  out.write('Form Select Mask for Halfwords ')
end

function si_fsmh:get_type(port)
  return 'qword'
end

-- #################################################### --

local si_fsmb = class(Node)

function si_fsmb:get_help(out)
  out.write[[ Form Select Mask for Bytes  

 rt.b[n] = ((ra.h[1] << n) & 0x8000) ? 0xF… : 0x0… ]]
end

function si_fsmb:new()
  Node.new(self)
  self.ra = self.add_port(Input('ra'))
  self.rt = self.add_port(Output('rt'))
end

function si_fsmb:config(props)
  Node.config(self, props)
  props.delete('Name')
end

function si_fsmb:gen_code(out, scratch)
  local rt = 'r' .. self.rt.hex()
  local ra = 'r' .. self.ra.get_output().hex()
  out.write( '\t .reg ' .. rt .. '\n')
  out.write( '\t fsmb ' .. rt .. ', ' .. ra .. '\n' )
end

function si_fsmb:get_tip(out)
  out.write('Form Select Mask for Bytes ')
end

function si_fsmb:get_type(port)
  return 'qword'
end

-- #################################################### --

local si_fsmbi = class(Node)

function si_fsmbi:get_help(out)
  out.write[[ Form Select Mask for Bytes Immediate  

 rt.b[n] = ((u16 << n) & 0x8000) ? 0xF… : 0x0… ]]
end

function si_fsmbi:new()
  Node.new(self)
  self.rt  = self.add_port(Output('rt'))
  self.u16 = 0
end

function si_fsmbi:config(props)
  Node.config(self, props)
  props.delete('Name')
  props.text_input(
                    'u16',
                    function() return self.u16 end,
                    function(v) self.u16 = v end,
                    function(v) return math.evaluate(v) end
                  )
end

function si_fsmbi:gen_code(out, scratch)
  local rt  = 'r' .. self.rt.hex()
  local u16 = math.evaluate(self.u16)
  out.write( '\t .reg ' .. rt .. '\n')
  out.write( '\t fsmbi ' .. rt .. ', ' .. u16 .. '\n' )
end

function si_fsmbi:get_tip(out)
  out.write('Form Select Mask for Bytes Immediate ')
end

function si_fsmbi:get_type(port)
  return 'qword'
end

register {
  __name = 'SPU [Select Bits]',
  __prologue = '',
  __epilogue = '',
  ['selb'] = si_selb,
  ['gb'] = si_gb,
  ['gbh'] = si_gbh,
  ['gbb'] = si_gbb,
  ['fsm'] = si_fsm,
  ['fsmh'] = si_fsmh,
  ['fsmb'] = si_fsmb,
  ['fsmbi'] = si_fsmbi,
}
