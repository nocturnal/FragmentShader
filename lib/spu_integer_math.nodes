-- #################################################### --

local si_a = class(Node)

function si_a:get_help(out)
  out.write[[ Add Word 

 rt.w[n] = ra.w[n] + rb.h[w] ]]
end

function si_a:new()
  Node.new(self)
  self.ra = self.add_port(Input('ra'))
  self.rb = self.add_port(Input('rb'))
  self.rt = self.add_port(Output('rt'))
end

function si_a:config(props)
  Node.config(self, props)
  props.delete('Name')
end

function si_a:gen_code(out, scratch)
  local rt = 'r' .. self.rt.hex()
  local ra = 'r' .. self.ra.get_output().hex()
  local rb = 'r' .. self.rb.get_output().hex()
  out.write( '\t .reg ' .. rt .. '\n')
  out.write( '\t a ' .. rt .. ', ' .. ra .. ', ' .. rb .. '\n' )
end

function si_a:get_tip(out)
  out.write('Add Word')
end

function si_a:get_type(port)
  return 'qword'
end

-- #################################################### --

local si_ai = class(Node)

function si_ai:get_help(out)
  out.write[[ Add Word Immediate  

 rt.w[n] = ra.w[n] + ext(s10) ]]
end

function si_ai:new()
  Node.new(self)
  self.ra  = self.add_port(Input('ra'))
  self.rt  = self.add_port(Output('rt'))
  self.s10 = 0
end

function si_ai:config(props)
  Node.config(self, props)
  props.delete('Name')
  props.text_input(
                    's10',
                    function() return self.s10 end,
                    function(v) self.s10 = v end,
                    function(v) return math.evaluate(v) end
                  )
end

function si_ai:gen_code(out, scratch)
  local rt  = 'r' .. self.rt.hex()
  local ra  = 'r' .. self.ra.get_output().hex()
  local s10 = math.evaluate(self.s10)
  out.write( '\t .reg ' .. rt .. '\n')
  out.write( '\t ai ' .. rt .. ', ' .. ra .. ', ' .. s10 .. '\n' )
end

function si_ai:get_tip(out)
  out.write('Add Word Immediate ')
end

function si_ai:get_type(port)
  return 'qword'
end

-- #################################################### --

local si_ah = class(Node)

function si_ah:get_help(out)
  out.write[[ Add Halfword  

 rt.h[n] = ra.h[n] + rb.h[n] ]]
end

function si_ah:new()
  Node.new(self)
  self.ra = self.add_port(Input('ra'))
  self.rb = self.add_port(Input('rb'))
  self.rt = self.add_port(Output('rt'))
end

function si_ah:config(props)
  Node.config(self, props)
  props.delete('Name')
end

function si_ah:gen_code(out, scratch)
  local rt = 'r' .. self.rt.hex()
  local ra = 'r' .. self.ra.get_output().hex()
  local rb = 'r' .. self.rb.get_output().hex()
  out.write( '\t .reg ' .. rt .. '\n')
  out.write( '\t ah ' .. rt .. ', ' .. ra .. ', ' .. rb .. '\n' )
end

function si_ah:get_tip(out)
  out.write('Add Halfword ')
end

function si_ah:get_type(port)
  return 'qword'
end

-- #################################################### --

local si_ahi = class(Node)

function si_ahi:get_help(out)
  out.write[[ Add Halfword Immediate  

 rt.h[n] = ra.h[n] + ext(s10) ]]
end

function si_ahi:new()
  Node.new(self)
  self.ra  = self.add_port(Input('ra'))
  self.rt  = self.add_port(Output('rt'))
  self.s10 = 0
end

function si_ahi:config(props)
  Node.config(self, props)
  props.delete('Name')
  props.text_input(
                    's10',
                    function() return self.s10 end,
                    function(v) self.s10 = v end,
                    function(v) return math.evaluate(v) end
                  )
end

function si_ahi:gen_code(out, scratch)
  local rt  = 'r' .. self.rt.hex()
  local ra  = 'r' .. self.ra.get_output().hex()
  local s10 = math.evaluate(self.s10)
  out.write( '\t .reg ' .. rt .. '\n')
  out.write( '\t ahi ' .. rt .. ', ' .. ra .. ', ' .. s10 .. '\n' )
end

function si_ahi:get_tip(out)
  out.write('Add Halfword Immediate ')
end

function si_ahi:get_type(port)
  return 'qword'
end

-- #################################################### --

local si_addx = class(Node)

function si_addx:get_help(out)
  out.write[[ Add Extended (With Carry) 

 rt.w[n] = (ra.w[n] + rb.w[n] + (rt.w[n]&1)) ]]
end

function si_addx:new()
  Node.new(self)
  self.ra = self.add_port(Input('ra'))
  self.rb = self.add_port(Input('rb'))
  self.rt = self.add_port(Output('rt'))
end

function si_addx:config(props)
  Node.config(self, props)
  props.delete('Name')
end

function si_addx:gen_code(out, scratch)
  local rt = 'r' .. self.rt.hex()
  local ra = 'r' .. self.ra.get_output().hex()
  local rb = 'r' .. self.rb.get_output().hex()
  out.write( '\t .reg ' .. rt .. '\n')
  out.write( '\t addx ' .. rt .. ', ' .. ra .. ', ' .. rb .. '\n' )
end

function si_addx:get_tip(out)
  out.write('Add Extended (With Carry)')
end

function si_addx:get_type(port)
  return 'qword'
end

-- #################################################### --

local si_bg = class(Node)

function si_bg:get_help(out)
  out.write[[ Borrow Generate  

 rt .w[n] = ((-ra.w[n] + rb.w[n]) < 0) ? 0 : 1 ]]
end

function si_bg:new()
  Node.new(self)
  self.ra = self.add_port(Input('ra'))
  self.rb = self.add_port(Input('rb'))
  self.rt = self.add_port(Output('rt'))
end

function si_bg:config(props)
  Node.config(self, props)
  props.delete('Name')
end

function si_bg:gen_code(out, scratch)
  local rt = 'r' .. self.rt.hex()
  local ra = 'r' .. self.ra.get_output().hex()
  local rb = 'r' .. self.rb.get_output().hex()
  out.write( '\t .reg ' .. rt .. '\n')
  out.write( '\t bg ' .. rt .. ', ' .. ra .. ', ' .. rb .. '\n' )
end

function si_bg:get_tip(out)
  out.write('Borrow Generate ')
end

function si_bg:get_type(port)
  return 'qword'
end

-- #################################################### --

local si_bgx = class(Node)

function si_bgx:get_help(out)
  out.write[[ Borrow Generate Extended (With Borrow)  

 rt .w[n] = ((-ra.w[n] + rb.w[n] + (rt.w[n]&1)-1) < 0) ? 0 : 1 ]]
end

function si_bgx:new()
  Node.new(self)
  self.ra = self.add_port(Input('ra'))
  self.rb = self.add_port(Input('rb'))
  self.rt = self.add_port(Output('rt'))
end

function si_bgx:config(props)
  Node.config(self, props)
  props.delete('Name')
end

function si_bgx:gen_code(out, scratch)
  local rt = 'r' .. self.rt.hex()
  local ra = 'r' .. self.ra.get_output().hex()
  local rb = 'r' .. self.rb.get_output().hex()
  out.write( '\t .reg ' .. rt .. '\n')
  out.write( '\t bgx ' .. rt .. ', ' .. ra .. ', ' .. rb .. '\n' )
end

function si_bgx:get_tip(out)
  out.write('Borrow Generate Extended (With Borrow) ')
end

function si_bgx:get_type(port)
  return 'qword'
end

-- #################################################### --

local si_cg = class(Node)

function si_cg:get_help(out)
  out.write[[ Carry Generate  

 rt.w[n] = (ra.w[n] + rb.w[n]) > 0xF… ? 1 : 0 ]]
end

function si_cg:new()
  Node.new(self)
  self.ra = self.add_port(Input('ra'))
  self.rb = self.add_port(Input('rb'))
  self.rt = self.add_port(Output('rt'))
end

function si_cg:config(props)
  Node.config(self, props)
  props.delete('Name')
end

function si_cg:gen_code(out, scratch)
  local rt = 'r' .. self.rt.hex()
  local ra = 'r' .. self.ra.get_output().hex()
  local rb = 'r' .. self.rb.get_output().hex()
  out.write( '\t .reg ' .. rt .. '\n')
  out.write( '\t cg ' .. rt .. ', ' .. ra .. ', ' .. rb .. '\n' )
end

function si_cg:get_tip(out)
  out.write('Carry Generate ')
end

function si_cg:get_type(port)
  return 'qword'
end

-- #################################################### --

local si_cgx = class(Node)

function si_cgx:get_help(out)
  out.write[[ Carry Generate Extended (With Carry) 

 rt.w[n] = (ra.w[n] + rb.w[n] + (rt.w[n]&1)) > 0xF… ? 1 : 0 ]]
end

function si_cgx:new()
  Node.new(self)
  self.ra = self.add_port(Input('ra'))
  self.rb = self.add_port(Input('rb'))
  self.rt = self.add_port(Output('rt'))
end

function si_cgx:config(props)
  Node.config(self, props)
  props.delete('Name')
end

function si_cgx:gen_code(out, scratch)
  local rt = 'r' .. self.rt.hex()
  local ra = 'r' .. self.ra.get_output().hex()
  local rb = 'r' .. self.rb.get_output().hex()
  out.write( '\t .reg ' .. rt .. '\n')
  out.write( '\t cgx ' .. rt .. ', ' .. ra .. ', ' .. rb .. '\n' )
end

function si_cgx:get_tip(out)
  out.write('Carry Generate Extended (With Carry)')
end

function si_cgx:get_type(port)
  return 'qword'
end

-- #################################################### --

local si_sf = class(Node)

function si_sf:get_help(out)
  out.write[[ Subtract from Word  

 rt.w[n] = -ra.w[n] + rb.w[n] ]]
end

function si_sf:new()
  Node.new(self)
  self.ra = self.add_port(Input('ra'))
  self.rb = self.add_port(Input('rb'))
  self.rt = self.add_port(Output('rt'))
end

function si_sf:config(props)
  Node.config(self, props)
  props.delete('Name')
end

function si_sf:gen_code(out, scratch)
  local rt = 'r' .. self.rt.hex()
  local ra = 'r' .. self.ra.get_output().hex()
  local rb = 'r' .. self.rb.get_output().hex()
  out.write( '\t .reg ' .. rt .. '\n')
  out.write( '\t sf ' .. rt .. ', ' .. ra .. ', ' .. rb .. '\n' )
end

function si_sf:get_tip(out)
  out.write('Subtract from Word ')
end

function si_sf:get_type(port)
  return 'qword'
end

-- #################################################### --

local si_sfi = class(Node)

function si_sfi:get_help(out)
  out.write[[ Subtract from Word Immediate  

 rt.w[n] = -ra.w[n] + ext(s10) ]]
end

function si_sfi:new()
  Node.new(self)
  self.ra  = self.add_port(Input('ra'))
  self.rt  = self.add_port(Output('rt'))
  self.s10 = 0
end

function si_sfi:config(props)
  Node.config(self, props)
  props.delete('Name')
  props.text_input(
                    's10',
                    function() return self.s10 end,
                    function(v) self.s10 = v end,
                    function(v) return math.evaluate(v) end
                  )
end

function si_sfi:gen_code(out, scratch)
  local rt  = 'r' .. self.rt.hex()
  local ra  = 'r' .. self.ra.get_output().hex()
  local s10 = math.evaluate(self.s10)
  out.write( '\t .reg ' .. rt .. '\n')
  out.write( '\t sfi ' .. rt .. ', ' .. ra .. ', ' .. s10 .. '\n' )
end

function si_sfi:get_tip(out)
  out.write('Subtract from Word Immediate ')
end

function si_sfi:get_type(port)
  return 'qword'
end

-- #################################################### --

local si_sfh = class(Node)

function si_sfh:get_help(out)
  out.write[[ Subtract from Halfword  

 rt.h[n] = -ra.h[n] + rb.h[n] ]]
end

function si_sfh:new()
  Node.new(self)
  self.ra = self.add_port(Input('ra'))
  self.rb = self.add_port(Input('rb'))
  self.rt = self.add_port(Output('rt'))
end

function si_sfh:config(props)
  Node.config(self, props)
  props.delete('Name')
end

function si_sfh:gen_code(out, scratch)
  local rt = 'r' .. self.rt.hex()
  local ra = 'r' .. self.ra.get_output().hex()
  local rb = 'r' .. self.rb.get_output().hex()
  out.write( '\t .reg ' .. rt .. '\n')
  out.write( '\t sfh ' .. rt .. ', ' .. ra .. ', ' .. rb .. '\n' )
end

function si_sfh:get_tip(out)
  out.write('Subtract from Halfword ')
end

function si_sfh:get_type(port)
  return 'qword'
end

-- #################################################### --

local si_sfhi = class(Node)

function si_sfhi:get_help(out)
  out.write[[ Subtract from Halfword Immediate  

 rt.h[n] = -ra.h[n] + ext(s10) ]]
end

function si_sfhi:new()
  Node.new(self)
  self.ra  = self.add_port(Input('ra'))
  self.rt  = self.add_port(Output('rt'))
  self.s10 = 0
end

function si_sfhi:config(props)
  Node.config(self, props)
  props.delete('Name')
  props.text_input(
                    's10',
                    function() return self.s10 end,
                    function(v) self.s10 = v end,
                    function(v) return math.evaluate(v) end
                  )
end

function si_sfhi:gen_code(out, scratch)
  local rt  = 'r' .. self.rt.hex()
  local ra  = 'r' .. self.ra.get_output().hex()
  local s10 = math.evaluate(self.s10)
  out.write( '\t .reg ' .. rt .. '\n')
  out.write( '\t sfhi ' .. rt .. ', ' .. ra .. ', ' .. s10 .. '\n' )
end

function si_sfhi:get_tip(out)
  out.write('Subtract from Halfword Immediate ')
end

function si_sfhi:get_type(port)
  return 'qword'
end

-- #################################################### --

local si_sfx = class(Node)

function si_sfx:get_help(out)
  out.write[[ Subtract from Extended (With Borrow) 

 rt.w[n] = (-ra.w[n] + rb.w[n] + (rt.w[n]&1) – 1) ]]
end

function si_sfx:new()
  Node.new(self)
  self.ra = self.add_port(Input('ra'))
  self.rb = self.add_port(Input('rb'))
  self.rt = self.add_port(Output('rt'))
end

function si_sfx:config(props)
  Node.config(self, props)
  props.delete('Name')
end

function si_sfx:gen_code(out, scratch)
  local rt = 'r' .. self.rt.hex()
  local ra = 'r' .. self.ra.get_output().hex()
  local rb = 'r' .. self.rb.get_output().hex()
  out.write( '\t .reg ' .. rt .. '\n')
  out.write( '\t sfx ' .. rt .. ', ' .. ra .. ', ' .. rb .. '\n' )
end

function si_sfx:get_tip(out)
  out.write('Subtract from Extended (With Borrow)')
end

function si_sfx:get_type(port)
  return 'qword'
end

-- #################################################### --

local si_mpy = class(Node)

function si_mpy:get_help(out)
  out.write[[ Multiply  

 rt.w[n] = ra.h[2n+1] * rb.h[2n+1] ]]
end

function si_mpy:new()
  Node.new(self)
  self.ra = self.add_port(Input('ra'))
  self.rb = self.add_port(Input('rb'))
  self.rt = self.add_port(Output('rt'))
end

function si_mpy:config(props)
  Node.config(self, props)
  props.delete('Name')
end

function si_mpy:gen_code(out, scratch)
  local rt = 'r' .. self.rt.hex()
  local ra = 'r' .. self.ra.get_output().hex()
  local rb = 'r' .. self.rb.get_output().hex()
  out.write( '\t .reg ' .. rt .. '\n')
  out.write( '\t mpy ' .. rt .. ', ' .. ra .. ', ' .. rb .. '\n' )
end

function si_mpy:get_tip(out)
  out.write('Multiply ')
end

function si_mpy:get_type(port)
  return 'qword'
end

-- #################################################### --

local si_mpyi = class(Node)

function si_mpyi:get_help(out)
  out.write[[ Multiply Immediate  

 rt.w[n] = ra.h[2n+1] * ext(s10) ]]
end

function si_mpyi:new()
  Node.new(self)
  self.ra  = self.add_port(Input('ra'))
  self.rt  = self.add_port(Output('rt'))
  self.s10 = 0
end

function si_mpyi:config(props)
  Node.config(self, props)
  props.delete('Name')
  props.text_input(
                    's10',
                    function() return self.s10 end,
                    function(v) self.s10 = v end,
                    function(v) return math.evaluate(v) end
                  )
end

function si_mpyi:gen_code(out, scratch)
  local rt  = 'r' .. self.rt.hex()
  local ra  = 'r' .. self.ra.get_output().hex()
  local s10 = math.evaluate(self.s10)
  out.write( '\t .reg ' .. rt .. '\n')
  out.write( '\t mpyi ' .. rt .. ', ' .. ra .. ', ' .. s10 .. '\n' )
end

function si_mpyi:get_tip(out)
  out.write('Multiply Immediate ')
end

function si_mpyi:get_type(port)
  return 'qword'
end

-- #################################################### --

local si_mpyu = class(Node)

function si_mpyu:get_help(out)
  out.write[[ Multiply Unsigned  

 rt.w[n] = ra.h[2n+1] * rb.h[2n+1] ]]
end

function si_mpyu:new()
  Node.new(self)
  self.ra = self.add_port(Input('ra'))
  self.rb = self.add_port(Input('rb'))
  self.rt = self.add_port(Output('rt'))
end

function si_mpyu:config(props)
  Node.config(self, props)
  props.delete('Name')
end

function si_mpyu:gen_code(out, scratch)
  local rt = 'r' .. self.rt.hex()
  local ra = 'r' .. self.ra.get_output().hex()
  local rb = 'r' .. self.rb.get_output().hex()
  out.write( '\t .reg ' .. rt .. '\n')
  out.write( '\t mpyu ' .. rt .. ', ' .. ra .. ', ' .. rb .. '\n' )
end

function si_mpyu:get_tip(out)
  out.write('Multiply Unsigned ')
end

function si_mpyu:get_type(port)
  return 'qword'
end

-- #################################################### --

local si_mpyui = class(Node)

function si_mpyui:get_help(out)
  out.write[[ Multiply Unsigned Immediate  

 rt.w[n] = ra.h[2n+1] * ext(s10) ]]
end

function si_mpyui:new()
  Node.new(self)
  self.ra  = self.add_port(Input('ra'))
  self.rt  = self.add_port(Output('rt'))
  self.s10 = 0
end

function si_mpyui:config(props)
  Node.config(self, props)
  props.delete('Name')
  props.text_input(
                    's10',
                    function() return self.s10 end,
                    function(v) self.s10 = v end,
                    function(v) return math.evaluate(v) end
                  )
end

function si_mpyui:gen_code(out, scratch)
  local rt  = 'r' .. self.rt.hex()
  local ra  = 'r' .. self.ra.get_output().hex()
  local s10 = math.evaluate(self.s10)
  out.write( '\t .reg ' .. rt .. '\n')
  out.write( '\t mpyui ' .. rt .. ', ' .. ra .. ', ' .. s10 .. '\n' )
end

function si_mpyui:get_tip(out)
  out.write('Multiply Unsigned Immediate ')
end

function si_mpyui:get_type(port)
  return 'qword'
end

-- #################################################### --

local si_mpya = class(Node)

function si_mpya:get_help(out)
  out.write[[ Multiply and Add  

 rt.w[n] = ra.h[2n+1] * rb.h[2n+1] + rc.w[n] ]]
end

function si_mpya:new()
  Node.new(self)
  self.ra = self.add_port(Input('ra'))
  self.rb = self.add_port(Input('rb'))
  self.rc = self.add_port(Input('rc'))
  self.rt = self.add_port(Output('rt'))
end

function si_mpya:config(props)
  Node.config(self, props)
  props.delete('Name')
end

function si_mpya:gen_code(out, scratch)
  local rt = 'r' .. self.rt.hex()
  local ra = 'r' .. self.ra.get_output().hex()
  local rb = 'r' .. self.rb.get_output().hex()
  local rc = 'r' .. self.rc.get_output().hex()
  out.write( '\t .reg ' .. rt .. '\n')
  out.write( '\t mpya ' .. rt .. ', ' .. ra .. ', ' .. rb .. ', ' .. rc .. '\n' )
end

function si_mpya:get_tip(out)
  out.write('Multiply and Add ')
end

function si_mpya:get_type(port)
  return 'qword'
end

-- #################################################### --

local si_mpys = class(Node)

function si_mpys:get_help(out)
  out.write[[ Multiply and Shift Right  

 rt.w[n] = ra.h[2n+1] * rb.h[2n+1] >> 16 ]]
end

function si_mpys:new()
  Node.new(self)
  self.ra = self.add_port(Input('ra'))
  self.rb = self.add_port(Input('rb'))
  self.rt = self.add_port(Output('rt'))
end

function si_mpys:config(props)
  Node.config(self, props)
  props.delete('Name')
end

function si_mpys:gen_code(out, scratch)
  local rt = 'r' .. self.rt.hex()
  local ra = 'r' .. self.ra.get_output().hex()
  local rb = 'r' .. self.rb.get_output().hex()
  out.write( '\t .reg ' .. rt .. '\n')
  out.write( '\t mpys ' .. rt .. ', ' .. ra .. ', ' .. rb .. '\n' )
end

function si_mpys:get_tip(out)
  out.write('Multiply and Shift Right ')
end

function si_mpys:get_type(port)
  return 'qword'
end

-- #################################################### --

local si_mpyh = class(Node)

function si_mpyh:get_help(out)
  out.write[[ Multiply High  

 rt.w[n] = ra.h[2n] * rb.h[2n+1] << 16 ]]
end

function si_mpyh:new()
  Node.new(self)
  self.ra = self.add_port(Input('ra'))
  self.rb = self.add_port(Input('rb'))
  self.rt = self.add_port(Output('rt'))
end

function si_mpyh:config(props)
  Node.config(self, props)
  props.delete('Name')
end

function si_mpyh:gen_code(out, scratch)
  local rt = 'r' .. self.rt.hex()
  local ra = 'r' .. self.ra.get_output().hex()
  local rb = 'r' .. self.rb.get_output().hex()
  out.write( '\t .reg ' .. rt .. '\n')
  out.write( '\t mpyh ' .. rt .. ', ' .. ra .. ', ' .. rb .. '\n' )
end

function si_mpyh:get_tip(out)
  out.write('Multiply High ')
end

function si_mpyh:get_type(port)
  return 'qword'
end

-- #################################################### --

local si_mpyhh = class(Node)

function si_mpyhh:get_help(out)
  out.write[[ Multiply High High  

 rt.w[n] = ra.h[2n] * rb.h[2n] ]]
end

function si_mpyhh:new()
  Node.new(self)
  self.ra = self.add_port(Input('ra'))
  self.rb = self.add_port(Input('rb'))
  self.rt = self.add_port(Output('rt'))
end

function si_mpyhh:config(props)
  Node.config(self, props)
  props.delete('Name')
end

function si_mpyhh:gen_code(out, scratch)
  local rt = 'r' .. self.rt.hex()
  local ra = 'r' .. self.ra.get_output().hex()
  local rb = 'r' .. self.rb.get_output().hex()
  out.write( '\t .reg ' .. rt .. '\n')
  out.write( '\t mpyhh ' .. rt .. ', ' .. ra .. ', ' .. rb .. '\n' )
end

function si_mpyhh:get_tip(out)
  out.write('Multiply High High ')
end

function si_mpyhh:get_type(port)
  return 'qword'
end

-- #################################################### --

local si_mpyhha = class(Node)

function si_mpyhha:get_help(out)
  out.write[[ Multiply High High and Add  

 rt.w[n] += ra.h[2n] * rb.h[2n] ]]
end

function si_mpyhha:new()
  Node.new(self)
  self.ra = self.add_port(Input('ra'))
  self.rb = self.add_port(Input('rb'))
  self.rt = self.add_port(Output('rt'))
end

function si_mpyhha:config(props)
  Node.config(self, props)
  props.delete('Name')
end

function si_mpyhha:gen_code(out, scratch)
  local rt = 'r' .. self.rt.hex()
  local ra = 'r' .. self.ra.get_output().hex()
  local rb = 'r' .. self.rb.get_output().hex()
  out.write( '\t .reg ' .. rt .. '\n')
  out.write( '\t mpyhha ' .. rt .. ', ' .. ra .. ', ' .. rb .. '\n' )
end

function si_mpyhha:get_tip(out)
  out.write('Multiply High High and Add ')
end

function si_mpyhha:get_type(port)
  return 'qword'
end

-- #################################################### --

local si_mpyhhu = class(Node)

function si_mpyhhu:get_help(out)
  out.write[[ Multiply High High Unsigned  

 rt.w[n] = ra.h[2n] * rb.h[2n] ]]
end

function si_mpyhhu:new()
  Node.new(self)
  self.ra = self.add_port(Input('ra'))
  self.rb = self.add_port(Input('rb'))
  self.rt = self.add_port(Output('rt'))
end

function si_mpyhhu:config(props)
  Node.config(self, props)
  props.delete('Name')
end

function si_mpyhhu:gen_code(out, scratch)
  local rt = 'r' .. self.rt.hex()
  local ra = 'r' .. self.ra.get_output().hex()
  local rb = 'r' .. self.rb.get_output().hex()
  out.write( '\t .reg ' .. rt .. '\n')
  out.write( '\t mpyhhu ' .. rt .. ', ' .. ra .. ', ' .. rb .. '\n' )
end

function si_mpyhhu:get_tip(out)
  out.write('Multiply High High Unsigned ')
end

function si_mpyhhu:get_type(port)
  return 'qword'
end

-- #################################################### --

local si_mpyhhau = class(Node)

function si_mpyhhau:get_help(out)
  out.write[[ Multiply High High Unsigned and Add  

 rt.w[n] += ra.h[2n] * rb.h[2n] ]]
end

function si_mpyhhau:new()
  Node.new(self)
  self.ra = self.add_port(Input('ra'))
  self.rb = self.add_port(Input('rb'))
  self.rt = self.add_port(Output('rt'))
end

function si_mpyhhau:config(props)
  Node.config(self, props)
  props.delete('Name')
end

function si_mpyhhau:gen_code(out, scratch)
  local rt = 'r' .. self.rt.hex()
  local ra = 'r' .. self.ra.get_output().hex()
  local rb = 'r' .. self.rb.get_output().hex()
  out.write( '\t .reg ' .. rt .. '\n')
  out.write( '\t mpyhhau ' .. rt .. ', ' .. ra .. ', ' .. rb .. '\n' )
end

function si_mpyhhau:get_tip(out)
  out.write('Multiply High High Unsigned and Add ')
end

function si_mpyhhau:get_type(port)
  return 'qword'
end

register {
  __name = 'SPU [Integer Math]',
  __prologue = '',
  __epilogue = '',
  ['a'] = si_a,
  ['ai'] = si_ai,
  ['ah'] = si_ah,
  ['ahi'] = si_ahi,
  ['addx'] = si_addx,
  ['bg'] = si_bg,
  ['bgx'] = si_bgx,
  ['cg'] = si_cg,
  ['cgx'] = si_cgx,
  ['sf'] = si_sf,
  ['sfi'] = si_sfi,
  ['sfh'] = si_sfh,
  ['sfhi'] = si_sfhi,
  ['sfx'] = si_sfx,
  ['mpy'] = si_mpy,
  ['mpyi'] = si_mpyi,
  ['mpyu'] = si_mpyu,
  ['mpyui'] = si_mpyui,
  ['mpya'] = si_mpya,
  ['mpys'] = si_mpys,
  ['mpyh'] = si_mpyh,
  ['mpyhh'] = si_mpyhh,
  ['mpyhha'] = si_mpyhha,
  ['mpyhhu'] = si_mpyhhu,
  ['mpyhhau'] = si_mpyhhau,
}
