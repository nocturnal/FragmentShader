<?xml version="1.0"?>
<library path="Cg/Color Functions">
	<node type="Average" deprecated="true">
		<description><![CDATA[d = (a+b)/2\n\nSupported Types:\nfloat\nhalf\nfixed\nfloat4\nhalf4\nfixed4\nfloat3\nhalf3\nfixed3\nfloat2\nhalf2\nfixed2]]></description>
		<tool-tip>d = (a+b)/2</tool-tip>
		<ports>
			<input name="a" required="true">
				<check-type method="list" target="*">float,half,fixed,float4,half4,fixed4,float3,half3,fixed3,float2,half2,fixed2</check-type>
			</input>
			<input name="b" required="true">
				<check-type method="list" target="*">float,half,fixed,float4,half4,fixed4,float3,half3,fixed3,float2,half2,fixed2</check-type>
			</input>
			<output name="d">
				<get-type method="same-as" target="*">a</get-type>
			</output>
			<input-constraints method="equal" target="*"/>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*">
				${node.d.get_type()} r${node.d.uid()} = ( 0.5 ) * ( r${node.a.get_source().uid()} + r${node.b.get_source().uid()} );
			</code>
		</code-generation>
	</node>
	<node type="Screen" deprecated="true">
		<description><![CDATA[d = 1-(1-a)*(1-b)\n\nSupported Types:\nfloat\nhalf\nfixed\nfloat4\nhalf4\nfixed4\nfloat3\nhalf3\nfixed3\nfloat2\nhalf2\nfixed2]]></description>
		<tool-tip>d = 1-(1-a)*(1-b)</tool-tip>
		<ports>
			<input name="a" required="true">
				<check-type method="list" target="*">float,half,fixed,float4,half4,fixed4,float3,half3,fixed3,float2,half2,fixed2</check-type>
			</input>
			<input name="b" required="true">
				<check-type method="list" target="*">float,half,fixed,float4,half4,fixed4,float3,half3,fixed3,float2,half2,fixed2</check-type>
			</input>
			<output name="d">
				<get-type method="same-as" target="*">a</get-type>
			</output>
			<input-constraints method="equal" target="*"/>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*">
				${node.d.get_type()} r${node.d.uid()} = ( 1.0 ) - ( ( 1.0 ) - r${node.a.get_source().uid()} ) * ( ( 1.0) -  r${node.b.get_source().uid()} );
			</code>
		</code-generation>
	</node>
	<node type="Darken" deprecated="true">
		<description><![CDATA[d = if (a < b ) then a else b\n\nSupported Types:\nfloat\nhalf\nfixed\nfloat4\nhalf4\nfixed4\nfloat3\nhalf3\nfixed3\nfloat2\nhalf2\nfixed2]]></description>
		<tool-tip>d = if (a &lt; b ) then a else b</tool-tip>
		<ports>
			<input name="a" required="true">
				<check-type method="list" target="*">float,half,fixed,float4,half4,fixed4,float3,half3,fixed3,float2,half2,fixed2</check-type>
			</input>
			<input name="b" required="true">
				<check-type method="list" target="*">float,half,fixed,float4,half4,fixed4,float3,half3,fixed3,float2,half2,fixed2</check-type>
			</input>
			<output name="d">
				<get-type method="same-as" target="*">a</get-type>
			</output>
			<input-constraints method="equal" target="*"/>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="lua" target="*"><![CDATA[
				local s = {
					type = node.d.get_type(),
					d = 'r' .. node.d.uid(),
					a = 'r' .. node.a.get_source().uid(),
					b = 'r' .. node.b.get_source().uid()
				}
				return (('type d = lerp( b, a, type( a < b ) );'):gsub('[%w_]+', s))
			]]></code>
		</code-generation>
	</node>
	<node type="Lighten" deprecated="true">
		<description><![CDATA[d = if (a > b ) then a else b\n\nSupported Types:\nfloat\nhalf\nfixed\nfloat4\nhalf4\nfixed4\nfloat3\nhalf3\nfixed3\nfloat2\nhalf2\nfixed2]]></description>
		<tool-tip>d = if (a &gt; b ) then a else b</tool-tip>
		<ports>
			<input name="a" required="true">
				<check-type method="list" target="*">float,half,fixed,float4,half4,fixed4,float3,half3,fixed3,float2,half2,fixed2</check-type>
			</input>
			<input name="b" required="true">
				<check-type method="list" target="*">float,half,fixed,float4,half4,fixed4,float3,half3,fixed3,float2,half2,fixed2</check-type>
			</input>
			<output name="d">
				<get-type method="same-as" target="*">a</get-type>
			</output>
			<input-constraints method="equal" target="*"/>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="lua" target="*"><![CDATA[
				local s = {
					type = node.d.get_type(),
					d = 'r' .. node.d.uid(),
					a = 'r' .. node.a.get_source().uid(),
					b = 'r' .. node.b.get_source().uid()
				}
				return (('type d = lerp( b, a, type( a > b ) );'):gsub('[%w_]+', s))
			]]></code>
		</code-generation>
	</node>
	<node type="Difference" deprecated="true">
		<description><![CDATA[d = |a-b|\n\nSupported Types:\nfloat\nhalf\nfixed\nfloat4\nhalf4\nfixed4\nfloat3\nhalf3\nfixed3\nfloat2\nhalf2\nfixed2]]></description>
		<tool-tip>d = |a-b|</tool-tip>
		<ports>
			<input name="a" required="true">
				<check-type method="list" target="*">float,half,fixed,float4,half4,fixed4,float3,half3,fixed3,float2,half2,fixed2</check-type>
			</input>
			<input name="b" required="true">
				<check-type method="list" target="*">float,half,fixed,float4,half4,fixed4,float3,half3,fixed3,float2,half2,fixed2</check-type>
			</input>
			<output name="d">
				<get-type method="same-as" target="*">a</get-type>
			</output>
			<input-constraints method="equal" target="*"/>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*">
				${node.d.get_type()} r${node.d.uid()} = abs( r${node.a.get_source().uid()} - r${node.b.get_source().uid()} );
			</code>
		</code-generation>
	</node>
	<node type="Negation" deprecated="true">
		<description><![CDATA[d = 1-|1-a-b|\n\nSupported Types:\nfloat\nhalf\nfixed\nfloat4\nhalf4\nfixed4\nfloat3\nhalf3\nfixed3\nfloat2\nhalf2\nfixed2]]></description>
		<tool-tip>d = 1-|1-a-b|</tool-tip>
		<ports>
			<input name="a" required="true">
				<check-type method="list" target="*">float,half,fixed,float4,half4,fixed4,float3,half3,fixed3,float2,half2,fixed2</check-type>
			</input>
			<input name="b" required="true">
				<check-type method="list" target="*">float,half,fixed,float4,half4,fixed4,float3,half3,fixed3,float2,half2,fixed2</check-type>
			</input>
			<output name="d">
				<get-type method="same-as" target="*">a</get-type>
			</output>
			<input-constraints method="equal" target="*"/>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*">
				${node.d.get_type()} r${node.d.uid()} = ( 1.0 ) - abs( ( 1.0 ) - r${node.a.get_source().uid()} - r${node.b.get_source().uid()} );
			</code>
		</code-generation>
	</node>
	<node type="Exclusion" deprecated="true">
		<description><![CDATA[d = a+b-2ab\n\nSupported Types:\nfloat\nhalf\nfixed\nfloat4\nhalf4\nfixed4\nfloat3\nhalf3\nfixed3\nfloat2\nhalf2\nfixed2]]></description>
		<tool-tip>d = a+b-2ab</tool-tip>
		<ports>
			<input name="a" required="true">
				<check-type method="list" target="*">float,half,fixed,float4,half4,fixed4,float3,half3,fixed3,float2,half2,fixed2</check-type>
			</input>
			<input name="b" required="true">
				<check-type method="list" target="*">float,half,fixed,float4,half4,fixed4,float3,half3,fixed3,float2,half2,fixed2</check-type>
			</input>
			<output name="d">
				<get-type method="same-as" target="*">a</get-type>
			</output>
			<input-constraints method="equal" target="*"/>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="lua" target="*"><![CDATA[
				local s = {
					type = node.d.get_type(),
					d = 'r' .. node.d.uid(),
					a = 'r' .. node.a.get_source().uid(),
					b = 'r' .. node.b.get_source().uid()
				}
				return (('type d = ( a + b ) - ( ( 2.0 ) * a * b );'):gsub('[%w_]+', s))
			]]></code>
		</code-generation>
	</node>
	<node type="Overlay" deprecated="true">
		<description><![CDATA[d = if ( a < 0.5 ) then (2ab) else (1-2*(1-a)*(1-b))\n\nSupported Types:\nfloat\nhalf\nfixed\nfloat4\nhalf4\nfixed4\nfloat3\nhalf3\nfixed3\nfloat2\nhalf2\nfixed2]]></description>
		<tool-tip>d = if ( a &lt; 0.5 ) then (2ab) else (1-2*(1-a)*(1-b))</tool-tip>
		<ports>
			<input name="a" required="true">
				<check-type method="list" target="*">float,half,fixed,float4,half4,fixed4,float3,half3,fixed3,float2,half2,fixed2</check-type>
			</input>
			<input name="b" required="true">
				<check-type method="list" target="*">float,half,fixed,float4,half4,fixed4,float3,half3,fixed3,float2,half2,fixed2</check-type>
			</input>
			<output name="d">
				<get-type method="same-as" target="*">a</get-type>
			</output>
			<input-constraints method="equal" target="*"/>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="lua" target="*"><![CDATA[
				local s = {
					type = node.d.get_type(),
					d = 'r' .. node.d.uid(),
					d_pass = 'r' .. node.d.uid() .. '_pass',
					d_fail = 'r' .. node.d.uid() .. '_fail',
					a = 'r' .. node.a.get_source().uid(),
					b = 'r' .. node.b.get_source().uid()
				}
				return ((
					'type d_pass = ( 2.0 ) * a * b;\n' ..
					'type d_fail = ( 1.0 ) - ( 2.0 ) * ( ( 1.0 ) - a ) * ( ( 1.0 ) - b );\n' ..
					'type d = lerp( d_fail, d_pass, type( a < ( 0.5 ) ) );'):gsub('[%w_]+', s))
			]]></code>
		</code-generation>
	</node>
	<node type="Hard Light" deprecated="true">
		<description><![CDATA[d = if ( b < 0.5 ) then (2ab) else (1-2*(1-a)*(1-b))\n\nSupported Types:\nfloat\nhalf\nfixed\nfloat4\nhalf4\nfixed4\nfloat3\nhalf3\nfixed3\nfloat2\nhalf2\nfixed2]]></description>
		<tool-tip>d = if ( b &lt; 0.5 ) then (2ab) else (1-2*(1-a)*(1-b))</tool-tip>
		<ports>
			<input name="a" required="true">
				<check-type method="list" target="*">float,half,fixed,float4,half4,fixed4,float3,half3,fixed3,float2,half2,fixed2</check-type>
			</input>
			<input name="b" required="true">
				<check-type method="list" target="*">float,half,fixed,float4,half4,fixed4,float3,half3,fixed3,float2,half2,fixed2</check-type>
			</input>
			<output name="d">
				<get-type method="same-as" target="*">a</get-type>
			</output>
			<input-constraints method="equal" target="*"/>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="lua" target="*"><![CDATA[
				local s = {
					type = node.d.get_type(),
					d = 'r' .. node.d.uid(),
					d_pass = 'r' .. node.d.uid() .. '_pass',
					d_fail = 'r' .. node.d.uid() .. '_fail',
					a = 'r' .. node.a.get_source().uid(),
					b = 'r' .. node.b.get_source().uid()
				}
				return ((
					'type d_pass = ( 2.0 ) * a * b;\n' ..
					'type d_fail = ( 1.0 ) - ( 2.0 ) * ( ( 1.0 ) - a ) * ( ( 1.0 ) - b );\n' ..
					'type d = lerp( d_fail, d_pass, type( b < ( 0.5 ) ) );'):gsub('[%w_]+', s))
			]]></code>
		</code-generation>
	</node>
	<node type="Soft Light" deprecated="true">
		<description><![CDATA[d = if ( b < 0.5 ) then (2ab + aa * (1-2b)) else (sqrt(a) * (2b-1) + 2a * (1-b))\n\nSupported Types:\nfloat\nhalf\nfixed\nfloat4\nhalf4\nfixed4\nfloat3\nhalf3\nfixed3\nfloat2\nhalf2\nfixed2]]></description>
		<tool-tip>d = if ( b &lt; 0.5 ) then (2ab) else (1-2*(1-a)*(1-b))</tool-tip>
		<ports>
			<input name="a" required="true">
				<check-type method="list" target="*">float,half,fixed,float4,half4,fixed4,float3,half3,fixed3,float2,half2,fixed2</check-type>
			</input>
			<input name="b" required="true">
				<check-type method="list" target="*">float,half,fixed,float4,half4,fixed4,float3,half3,fixed3,float2,half2,fixed2</check-type>
			</input>
			<output name="d">
				<get-type method="same-as" target="*">a</get-type>
			</output>
			<input-constraints method="equal" target="*"/>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="lua" target="*"><![CDATA[
				local s = {
					type = node.d.get_type(),
					d = 'r' .. node.d.uid(),
					d_pass = 'r' .. node.d.uid() .. '_pass',
					d_fail = 'r' .. node.d.uid() .. '_fail',
					a = 'r' .. node.a.get_source().uid(),
					b = 'r' .. node.b.get_source().uid()
				}
				return ((
					'type d_pass = ( 2.0 ) * a * b + a * a * ( ( 1.0 ) - ( 2.0 ) * b );\n' ..
					'type d_fail = sqrt( a ) * ( ( 2.0 ) * b - ( 1.0 ) ) + ( 2.0 ) * a * ( ( 1.0 ) - b );\n' ..
					'type d = lerp( d_fail, d_pass, type( b < ( 0.5 ) ) );'):gsub('[%w_]+', s))
			]]></code>
		</code-generation>
	</node>
	<node type="Soft Light (Alt 1)" deprecated="true">
		<description><![CDATA[d = (1-a) * ab + a * ( 1 - (1-a) * (1-b) )\n\nSupported Types:\nfloat\nhalf\nfixed\nfloat4\nhalf4\nfixed4\nfloat3\nhalf3\nfixed3\nfloat2\nhalf2\nfixed2]]></description>
		<tool-tip>d = (1-a) * ab + a * ( 1 - (1-a) * (1-b) )</tool-tip>
		<ports>
			<input name="a" required="true">
				<check-type method="list" target="*">float,half,fixed,float4,half4,fixed4,float3,half3,fixed3,float2,half2,fixed2</check-type>
			</input>
			<input name="b" required="true">
				<check-type method="list" target="*">float,half,fixed,float4,half4,fixed4,float3,half3,fixed3,float2,half2,fixed2</check-type>
			</input>
			<output name="d">
				<get-type method="same-as" target="*">a</get-type>
			</output>
			<input-constraints method="equal" target="*"/>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="lua" target="*"><![CDATA[
				local s = {
					type = node.d.get_type(),
					d = 'r' .. node.d.uid(),
					a = 'r' .. node.a.get_source().uid(),
					b = 'r' .. node.b.get_source().uid()
				}
				return (('type d = ( ( 1.0) - a ) * a * b + a * ( ( 1.0 ) - ( ( 1.0 ) - a ) * ( ( 1.0 ) - b ) );'):gsub('[%w_]+', s))
			]]></code>
		</code-generation>
	</node>
	<node type="Soft Light (Alt 2)" deprecated="true">
		<description><![CDATA[d = 2ab + aa - 2aab\n\nSupported Types:\nfloat\nhalf\nfixed\nfloat4\nhalf4\nfixed4\nfloat3\nhalf3\nfixed3\nfloat2\nhalf2\nfixed2]]></description>
		<tool-tip>d = 2ab + aa - 2aab</tool-tip>
		<ports>
			<input name="a" required="true">
				<check-type method="list" target="*">float,half,fixed,float4,half4,fixed4,float3,half3,fixed3,float2,half2,fixed2</check-type>
			</input>
			<input name="b" required="true">
				<check-type method="list" target="*">float,half,fixed,float4,half4,fixed4,float3,half3,fixed3,float2,half2,fixed2</check-type>
			</input>
			<output name="d">
				<get-type method="same-as" target="*">a</get-type>
			</output>
			<input-constraints method="equal" target="*"/>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="lua" target="*"><![CDATA[
				local s = {
					type = node.d.get_type(),
					d = 'r' .. node.d.uid(),
					a = 'r' .. node.a.get_source().uid(),
					b = 'r' .. node.b.get_source().uid()
				}
				return (('type d = ( 2.0 ) * a * b + a * a - ( 2.0 ) * a * a * b;'):gsub('[%w_]+', s))
			]]></code>
		</code-generation>
	</node>
	<node type="Dodge" deprecated="true">
		<description><![CDATA[d = a / (1-b)\n\nSupported Types:\nfloat\nhalf\nfixed\nfloat4\nhalf4\nfixed4\nfloat3\nhalf3\nfixed3\nfloat2\nhalf2\nfixed2]]></description>
		<tool-tip>d = a / (1-b)</tool-tip>
		<ports>
			<input name="a" required="true">
				<check-type method="list" target="*">float,half,fixed,float4,half4,fixed4,float3,half3,fixed3,float2,half2,fixed2</check-type>
			</input>
			<input name="b" required="true">
				<check-type method="list" target="*">float,half,fixed,float4,half4,fixed4,float3,half3,fixed3,float2,half2,fixed2</check-type>
			</input>
			<output name="d">
				<get-type method="same-as" target="*">a</get-type>
			</output>
			<input-constraints method="equal" target="*"/>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="lua" target="*"><![CDATA[
				local s = {
					type = node.d.get_type(),
					d = 'r' .. node.d.uid(),
					a = 'r' .. node.a.get_source().uid(),
					b = 'r' .. node.b.get_source().uid()
				}
				return (('type d = a / ( ( 1.0 ) - b );'):gsub('[%w_]+', s))
			]]></code>
		</code-generation>
	</node>
	<node type="Inverse Dodge" deprecated="true">
		<description><![CDATA[d = b / (1-a)\n\nSupported Types:\nfloat\nhalf\nfixed\nfloat4\nhalf4\nfixed4\nfloat3\nhalf3\nfixed3\nfloat2\nhalf2\nfixed2]]></description>
		<tool-tip>d = b / (1-a)</tool-tip>
		<ports>
			<input name="a" required="true">
				<check-type method="list" target="*">float,half,fixed,float4,half4,fixed4,float3,half3,fixed3,float2,half2,fixed2</check-type>
			</input>
			<input name="b" required="true">
				<check-type method="list" target="*">float,half,fixed,float4,half4,fixed4,float3,half3,fixed3,float2,half2,fixed2</check-type>
			</input>
			<output name="d">
				<get-type method="same-as" target="*">a</get-type>
			</output>
			<input-constraints method="equal" target="*"/>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="lua" target="*"><![CDATA[
				local s = {
					type = node.d.get_type(),
					d = 'r' .. node.d.uid(),
					a = 'r' .. node.a.get_source().uid(),
					b = 'r' .. node.b.get_source().uid()
				}
				return (('type d = b / ( ( 1.0 ) - a );'):gsub('[%w_]+', s)
			]]></code>
		</code-generation>
	</node>
	<node type="Soft Dodge" deprecated="true">
		<description><![CDATA[d = if ( a+b < 1.0 ) then (0.5a / (1-b)) else (1 - 0.5(1-b)/a)\n\nSupported Types:\nfloat\nhalf\nfixed\nfloat4\nhalf4\nfixed4\nfloat3\nhalf3\nfixed3\nfloat2\nhalf2\nfixed2]]></description>
		<tool-tip>d = if ( a+b &lt; 1.0 ) then (0.5a / (1-b)) else (1 - 0.5(1-b)/a)</tool-tip>
		<ports>
			<input name="a" required="true">
				<check-type method="list" target="*">float,half,fixed,float4,half4,fixed4,float3,half3,fixed3,float2,half2,fixed2</check-type>
			</input>
			<input name="b" required="true">
				<check-type method="list" target="*">float,half,fixed,float4,half4,fixed4,float3,half3,fixed3,float2,half2,fixed2</check-type>
			</input>
			<output name="d">
				<get-type method="same-as" target="*">a</get-type>
			</output>
			<input-constraints method="equal" target="*"/>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="lua" target="*"><![CDATA[
				local s = {
					type = node.d.get_type(),
					d = 'r' .. node.d.uid(),
					d_pass = 'r' .. node.d.uid() .. '_pass',
					d_fail = 'r' .. node.d.uid() .. '_fail',
					a = 'r' .. node.a.get_source().uid(),
					b = 'r' .. node.b.get_source().uid()
				}
				return ((
					'type d_pass = ( ( 0.5 ) * a ) / ( ( 1.0 ) - b );\n' ..
					'type d_fail = ( 1.0 ) - ( 0.5 ) * ( ( 1.0 ) - b ) / a;\n' ..
					'type d = lerp( d_fail, d_pass, type( ( a + b ) < ( 1.0 ) ) );'):gsub('[%w_]+', s))
			]]></code>
		</code-generation>
	</node>
	<node type="Burn" deprecated="true">
		<description><![CDATA[d = 1-(1-a)/b\n\nSupported Types:\nfloat\nhalf\nfixed\nfloat4\nhalf4\nfixed4\nfloat3\nhalf3\nfixed3\nfloat2\nhalf2\nfixed2]]></description>
		<tool-tip>d = 1-(1-a)/b</tool-tip>
		<ports>
			<input name="a" required="true">
				<check-type method="list" target="*">float,half,fixed,float4,half4,fixed4,float3,half3,fixed3,float2,half2,fixed2</check-type>
			</input>
			<input name="b" required="true">
				<check-type method="list" target="*">float,half,fixed,float4,half4,fixed4,float3,half3,fixed3,float2,half2,fixed2</check-type>
			</input>
			<output name="d">
				<get-type method="same-as" target="*">a</get-type>
			</output>
			<input-constraints method="equal" target="*"/>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="lua" target="*"><![CDATA[
				local s = {
					type = node.d.get_type(),
					d = 'r' .. node.d.uid(),
					a = 'r' .. node.a.get_source().uid(),
					b = 'r' .. node.b.get_source().uid()
				}
				return (('type d = ( 1.0 ) - ( ( 1.0 ) - a ) / b;'):gsub('[%w_]+', s))
			]]></code>
		</code-generation>
	</node>
	<node type="Inverse Burn" deprecated="true">
		<description><![CDATA[d = 1-(1-b)/a\n\nSupported Types:\nfloat\nhalf\nfixed\nfloat4\nhalf4\nfixed4\nfloat3\nhalf3\nfixed3\nfloat2\nhalf2\nfixed2]]></description>
		<tool-tip>d = 1-(1-b)/a</tool-tip>
		<ports>
			<input name="a" required="true">
				<check-type method="list" target="*">float,half,fixed,float4,half4,fixed4,float3,half3,fixed3,float2,half2,fixed2</check-type>
			</input>
			<input name="b" required="true">
				<check-type method="list" target="*">float,half,fixed,float4,half4,fixed4,float3,half3,fixed3,float2,half2,fixed2</check-type>
			</input>
			<output name="d">
				<get-type method="same-as" target="*">a</get-type>
			</output>
			<input-constraints method="equal" target="*"/>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="lua" target="*"><![CDATA[
				local s = {
					type = node.d.get_type(),
					d = 'r' .. node.d.uid(),
					a = 'r' .. node.a.get_source().uid(),
					b = 'r' .. node.b.get_source().uid()
				}
				return (('type d = ( 1.0 ) - ( ( 1.0 ) - b ) / a;'):gsub('[%w_]+', s))
			]]></code>
		</code-generation>
	</node>
	<node type="Soft Burn" deprecated="true">
		<description><![CDATA[d = if ( a+b < 1.0 ) then (0.5b / (1-a)) else (1 - 0.5(1-a)/b)\n\nSupported Types:\nfloat\nhalf\nfixed\nfloat4\nhalf4\nfixed4\nfloat3\nhalf3\nfixed3\nfloat2\nhalf2\nfixed2]]></description>
		<tool-tip>d = if ( a+b &lt; 1.0 ) then (0.5b / (1-a)) else (1 - 0.5(1-a)/b)</tool-tip>
		<ports>
			<input name="a" required="true">
				<check-type method="list" target="*">float,half,fixed,float4,half4,fixed4,float3,half3,fixed3,float2,half2,fixed2</check-type>
			</input>
			<input name="b" required="true">
				<check-type method="list" target="*">float,half,fixed,float4,half4,fixed4,float3,half3,fixed3,float2,half2,fixed2</check-type>
			</input>
			<output name="d">
				<get-type method="same-as" target="*">a</get-type>
			</output>
			<input-constraints method="equal" target="*"/>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="lua" target="*"><![CDATA[
				local s = {
					type = node.d.get_type(),
					d = 'r' .. node.d.uid(),
					d_pass = 'r' .. node.d.uid() .. '_pass',
					d_fail = 'r' .. node.d.uid() .. '_fail',
					a = 'r' .. node.a.get_source().uid(),
					b = 'r' .. node.b.get_source().uid()
				}
				return ((
					'type d_pass = ( ( 0.5 ) * b ) / ( ( 1.0 ) - a );\n' ..
					'type d_fail = ( 1.0 ) - ( 0.5 ) * ( ( 1.0 ) - a ) / b;\n' ..
					'type d = lerp( d_fail, d_pass, type( ( a + b ) < ( 1.0 ) ) );'):gsub('[%w_]+', s))
			]]></code>
		</code-generation>
	</node>
	<node type="Reflect" deprecated="true">
		<description><![CDATA[d = aa / (1-b)\n\nSupported Types:\nfloat\nhalf\nfixed\nfloat4\nhalf4\nfixed4\nfloat3\nhalf3\nfixed3\nfloat2\nhalf2\nfixed2]]></description>
		<tool-tip>d = aa / (1-b)</tool-tip>
		<ports>
			<input name="a" required="true">
				<check-type method="list" target="*">float,half,fixed,float4,half4,fixed4,float3,half3,fixed3,float2,half2,fixed2</check-type>
			</input>
			<input name="b" required="true">
				<check-type method="list" target="*">float,half,fixed,float4,half4,fixed4,float3,half3,fixed3,float2,half2,fixed2</check-type>
			</input>
			<output name="d">
				<get-type method="same-as" target="*">a</get-type>
			</output>
			<input-constraints method="equal" target="*"/>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="lua" target="*"><![CDATA[
				local s = {
					type = node.d.get_type(),
					d = 'r' .. node.d.uid(),
					a = 'r' .. node.a.get_source().uid(),
					b = 'r' .. node.b.get_source().uid()
				}
				return (('type d = ( a * a ) / ( ( 1.0 ) - b );'):gsub('[%w_]+', s))
			]]></code>
		</code-generation>
	</node>
	<node type="Glow" deprecated="true">
		<description><![CDATA[d = bb / (1-a)\n\nSupported Types:\n\nfloat\nhalf\nfixed\nfloat4\nhalf4\nfixed4\nfloat3\nhalf3\nfixed3\nfloat2\nhalf2\nfixed2]]></description>
		<tool-tip>d = bb / (1-a)</tool-tip>
		<ports>
			<input name="a" required="true">
				<check-type method="list" target="*">float,half,fixed,float4,half4,fixed4,float3,half3,fixed3,float2,half2,fixed2</check-type>
			</input>
			<input name="b" required="true">
				<check-type method="list" target="*">float,half,fixed,float4,half4,fixed4,float3,half3,fixed3,float2,half2,fixed2</check-type>
			</input>
			<output name="d">
				<get-type method="same-as" target="*">a</get-type>
			</output>
			<input-constraints method="equal" target="*"/>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="lua" target="*"><![CDATA[
				local s = {
					type = node.d.get_type(),
					d = 'r' .. node.d.uid(),
					a = 'r' .. node.a.get_source().uid(),
					b = 'r' .. node.b.get_source().uid()
				}
				return (('type d = ( b * b ) / ( ( 1.0 ) - a );'):gsub('[%w_]+', s))
			]]></code>
		</code-generation>
	</node>
	<node type="Freeze" deprecated="true">
		<description><![CDATA[d = 1 - (1-a)(1-a) / b\n\nSupported Types:\nfloat\nhalf\nfixed\nfloat4\nhalf4\nfixed4\nfloat3\nhalf3\nfixed3\nfloat2\nhalf2\nfixed2]]></description>
		<tool-tip>d = 1 - (1-a)(1-a) / b</tool-tip>
		<ports>
			<input name="a" required="true">
				<check-type method="list" target="*">float,half,fixed,float4,half4,fixed4,float3,half3,fixed3,float2,half2,fixed2</check-type>
			</input>
			<input name="b" required="true">
				<check-type method="list" target="*">float,half,fixed,float4,half4,fixed4,float3,half3,fixed3,float2,half2,fixed2</check-type>
			</input>
			<output name="d">
				<get-type method="same-as" target="*">a</get-type>
			</output>
			<input-constraints method="equal" target="*"/>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="lua" target="*"><![CDATA[
				local s = {
					type = node.d.get_type(),
					d = 'r' .. node.d.uid(),
					a = 'r' .. node.a.get_source().uid(),
					b = 'r' .. node.b.get_source().uid()
				}
				return (('type d = ( 1.0 ) - ( ( ( 1.0 ) - a ) * ( ( 1.0 ) - a ) ) / b;'):gsub('[%w_]+', s))
			]]></code>
		</code-generation>
	</node>
	<node type="Heat" deprecated="true">
		<description><![CDATA[d = 1 - (1-b)(1-b) / a\n\nSupported Types:\nfloat\nhalf\nfixed\nfloat4\nhalf4\nfixed4\nfloat3\nhalf3\nfixed3\nfloat2\nhalf2\nfixed2]]></description>
		<tool-tip>d = 1 - (1-b)(1-b) / a</tool-tip>
		<ports>
			<input name="a" required="true">
				<check-type method="list" target="*">float,half,fixed,float4,half4,fixed4,float3,half3,fixed3,float2,half2,fixed2</check-type>
			</input>
			<input name="b" required="true">
				<check-type method="list" target="*">float,half,fixed,float4,half4,fixed4,float3,half3,fixed3,float2,half2,fixed2</check-type>
			</input>
			<output name="d">
				<get-type method="same-as" target="*">a</get-type>
			</output>
			<input-constraints method="equal" target="*"/>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="lua" target="*"><![CDATA[
				local s = {
					type = node.d.get_type(),
					d = 'r' .. node.d.uid(),
					a = 'r' .. node.a.get_source().uid(),
					b = 'r' .. node.b.get_source().uid()
				}
				return (('type d = ( 1.0 ) - ( ( ( 1.0 ) - b ) * ( ( 1.0 ) - b ) ) / a;'):gsub('[%w_]+', s))
			]]></code>
		</code-generation>
	</node>
	<node type="Additive" deprecated="true">
		<description><![CDATA[d = a + b\n\nSupported Types:\nfloat\nhalf\nfixed\nfloat4\nhalf4\nfixed4\nfloat3\nhalf3\nfixed3\nfloat2\nhalf2\nfixed2]]></description>
		<tool-tip>d = a + b</tool-tip>
		<ports>
			<input name="a" required="true">
				<check-type method="list" target="*">float,half,fixed,float4,half4,fixed4,float3,half3,fixed3,float2,half2,fixed2</check-type>
			</input>
			<input name="b" required="true">
				<check-type method="list" target="*">float,half,fixed,float4,half4,fixed4,float3,half3,fixed3,float2,half2,fixed2</check-type>
			</input>
			<output name="d">
				<get-type method="same-as" target="*">a</get-type>
			</output>
			<input-constraints method="equal" target="*"/>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*">
				${node.d.get_type()} r${node.d.uid()} = r${node.a.get_source().uid()} + r${node.b.get_source().uid()};
			</code>
		</code-generation>
	</node>
	<node type="Subtractive" deprecated="true">
		<description><![CDATA[d = a + b - 1\n\nSupported Types:\nfloat\nhalf\nfixed\nfloat4\nhalf4\nfixed4\nfloat3\nhalf3\nfixed3\nfloat2\nhalf2\nfixed2]]></description>
		<tool-tip>d = a + b - 1</tool-tip>
		<ports>
			<input name="a" required="true">
				<check-type method="list" target="*">float,half,fixed,float4,half4,fixed4,float3,half3,fixed3,float2,half2,fixed2</check-type>
			</input>
			<input name="b" required="true">
				<check-type method="list" target="*">float,half,fixed,float4,half4,fixed4,float3,half3,fixed3,float2,half2,fixed2</check-type>
			</input>
			<output name="d">
				<get-type method="same-as" target="*">a</get-type>
			</output>
			<input-constraints method="equal" target="*"/>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*">
				${node.d.get_type()} r${node.d.uid()} = r${node.a.get_source().uid()} + r${node.b.get_source().uid()} - ( 1.0 );
			</code>
		</code-generation>
	</node>
	<node type="Stamp" deprecated="true">
		<description><![CDATA[d = a + 2b - 1\n\nSupported Types:\nfloat\nhalf\nfixed\nfloat4\nhalf4\nfixed4\nfloat3\nhalf3\nfixed3\nfloat2\nhalf2\nfixed2]]></description>
		<tool-tip>d = a + 2b - 1</tool-tip>
		<ports>
			<input name="a" required="true">
				<check-type method="list" target="*">float,half,fixed,float4,half4,fixed4,float3,half3,fixed3,float2,half2,fixed2</check-type>
			</input>
			<input name="b" required="true">
				<check-type method="list" target="*">float,half,fixed,float4,half4,fixed4,float3,half3,fixed3,float2,half2,fixed2</check-type>
			</input>
			<output name="d">
				<get-type method="same-as" target="*">a</get-type>
			</output>
			<input-constraints method="equal" target="*"/>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*">
				${node.d.get_type()} r${node.d.uid()} = r${node.a.get_source().uid()} + ( 2.0 ) * r${node.b.get_source().uid()} - ( 1.0 );
			</code>
		</code-generation>
	</node>
	<node type="Interpolation" deprecated="true">
		<description><![CDATA[d = 0.5 - 0.25*cos(pi*a) - 0.25*cos(pi*b)\n\nSupported Types:\nfloat\nhalf\nfixed\nfloat4\nhalf4\nfixed4\nfloat3\nhalf3\nfixed3\nfloat2\nhalf2\nfixed2]]></description>
		<tool-tip>d = 0.5 - 0.25*cos(pi*a) - 0.25*cos(pi*b)</tool-tip>
		<ports>
			<input name="a" required="true">
				<check-type method="list" target="*">float,half,fixed,float4,half4,fixed4,float3,half3,fixed3,float2,half2,fixed2</check-type>
			</input>
			<input name="b" required="true">
				<check-type method="list" target="*">float,half,fixed,float4,half4,fixed4,float3,half3,fixed3,float2,half2,fixed2</check-type>
			</input>
			<output name="d">
				<get-type method="same-as" target="*">a</get-type>
			</output>
			<input-constraints method="equal" target="*"/>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="lua" target="*"><![CDATA[
				local s = {
					type = node.d.get_type(),
					d = 'r' .. node.d.uid(),
					a = 'r' .. node.a.get_source().uid(),
					b = 'r' .. node.b.get_source().uid(),
					pi = '( 3.1415926535897932385 )'
				}
				return (('type d = ( 0.5 ) - ( 0.25 ) * cos( pi * a ) - ( 0.25 ) * cos( pi * b );'):gsub('[%w_]+', s))
			]]></code>
		</code-generation>
	</node>
	<node type="Opacity" deprecated="true">
		<description><![CDATA[d = t * b + (1-t)*a\n\nSupported Types:\nfloat\nhalf\nfixed\nfloat4\nhalf4\nfixed4\nfloat3\nhalf3\nfixed3\nfloat2\nhalf2\nfixed2]]></description>
		<tool-tip>d = t * b + (1-t)*a</tool-tip>
		<ports>
			<input name="a" required="true">
				<check-type method="list" target="*">float,half,fixed,float4,half4,fixed4,float3,half3,fixed3,float2,half2,fixed2</check-type>
			</input>
			<input name="b" required="true">
				<check-type method="list" target="*">float,half,fixed,float4,half4,fixed4,float3,half3,fixed3,float2,half2,fixed2</check-type>
			</input>
			<input name="t" required="true">
				<check-type method="list" target="*">float,half,fixed,float4,half4,fixed4,float3,half3,fixed3,float2,half2,fixed2</check-type>
			</input>
			<output name="d">
				<get-type method="same-as" target="*">a</get-type>
			</output>
			<input-constraints method="equal" target="*"/>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="lua" target="*"><![CDATA[
				local s = {
					type = node.d.get_type(),
					d = 'r' .. node.d.uid(),
					a = 'r' .. node.a.get_source().uid(),
					b = 'r' .. node.b.get_source().uid(),
					t = 'r' .. node.t.get_source().uid()
				}
				return (('type d = t * b + ( ( 1.0 ) - t ) * a;'):gsub('[%w_]+', s))
			]]></code>
		</code-generation>
	</node>
	<node type="Transparency" deprecated="true">
		<description><![CDATA[d = (1-t) * b + t * a\n\nSupported Types:\nfloat\nhalf\nfixed\nfloat4\nhalf4\nfixed4\nfloat3\nhalf3\nfixed3\nfloat2\nhalf2\nfixed2]]></description>
		<tool-tip>d = (1-t) * b + t * a</tool-tip>
		<ports>
			<input name="a" required="true">
				<check-type method="list" target="*">float,half,fixed,float4,half4,fixed4,float3,half3,fixed3,float2,half2,fixed2</check-type>
			</input>
			<input name="b" required="true">
				<check-type method="list" target="*">float,half,fixed,float4,half4,fixed4,float3,half3,fixed3,float2,half2,fixed2</check-type>
			</input>
			<input name="t" required="true">
				<check-type method="list" target="*">float,half,fixed,float4,half4,fixed4,float3,half3,fixed3,float2,half2,fixed2</check-type>
			</input>
			<output name="d">
				<get-type method="same-as" target="*">a</get-type>
			</output>
			<input-constraints method="equal" target="*"/>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="lua" target="*"><![CDATA[
				local s = {
					type = node.d.get_type(),
					d = 'r' .. node.d.uid(),
					a = 'r' .. node.a.get_source().uid(),
					b = 'r' .. node.b.get_source().uid(),
					t = 'r' .. node.t.get_source().uid()
				}
				return (('type d = ( ( 1.0 ) - t ) * b + t * a;'):gsub('[%w_]+', s))
			]]></code>
		</code-generation>
	</node>
	<node type="Color Blend (Average)">
		<description><![CDATA[
			Average:            d = (a+b)/2
			Screen:             d = 1-(1-a)*(1-b)
			Darken:             d = if (a < b ) then a else b
			Lighten:            d = if (a > b ) then a else b
			Difference:         d = |a-b|
			Negation:           d = 1-|1-a-b|
			Exclusion:          d = a+b-2ab
			Overlay:            d = if ( a < 0.5 ) then (2ab) else (1-2*(1-a)*(1-b))
			Hard Light:         d = if ( b < 0.5 ) then (2ab) else (1-2*(1-a)*(1-b))
			Soft Light:         d = if ( b < 0.5 ) then (2ab + aa * (1-2b)) else (sqrt(a) * (2b-1) + 2a * (1-b))
			Soft Light (Alt 1): d = (1-a) * ab + a * ( 1 - (1-a) * (1-b) )
			Soft Light (Alt 2): d = 2ab + aa - 2aab
			Dodge:              d = a / (1-b)
			Inverse Dodge:      d = b / (1-a)
			Soft Dodge:         d = if ( a+b < 1.0 ) then (0.5a / (1-b)) else (1 - 0.5(1-b)/a)
			Burn:               d = 1-(1-a)/b
			Inverse Burn:       d = 1-(1-b)/a
			Soft Burn:          d = if ( a+b < 1.0 ) then (0.5b / (1-a)) else (1 - 0.5(1-a)/b)
			Reflect:            d = aa / (1-b)
			Glow:               d = bb / (1-a)
			Freeze:             d = 1 - (1-a)(1-a) / b
			Heat:               d = 1 - (1-b)(1-b) / a
			Additive:           d = a + b
			Subtractive:        d = a + b - 1
			Stamp:              d = a + 2b - 1
			Interpolation:      d = 0.5 - 0.25*cos(pi*a) - 0.25*cos(pi*b)
			
			Supported Types:
			
			float
			half
			fixed
			float4
			half4
			fixed4
			float3
			half3
			fixed3
			float2
			half2
			fixed2
		]]></description>
		<tool-tip>d = (a+b)/2</tool-tip>
		<ports>
			<input name="a" required="true">
				<check-type method="list" target="*">float,half,fixed,float4,half4,fixed4,float3,half3,fixed3,float2,half2,fixed2</check-type>
			</input>
			<input name="b" required="true">
				<check-type method="list" target="*">float,half,fixed,float4,half4,fixed4,float3,half3,fixed3,float2,half2,fixed2</check-type>
			</input>
			<output name="d">
				<get-type method="same-as" target="*">a</get-type>
			</output>
			<input-constraints method="lua" target="*">
        return node.a.get_source().get_type() == node.b.get_source().get_type()
      </input-constraints>
		</ports>
		<properties>
			<default-properties/>
			<property name="Operation" type="list">
				<options>
					<option>Average</option>
					<option>Screen</option>
					<option>Darken</option>
					<option>Lighten</option>
					<option>Difference</option>
					<option>Negation</option>
					<option>Exclusion</option>
					<option>Overlay</option>
					<option value="HardLight">Hard Light</option>
					<option value="SoftLight">Soft Light</option>
					<option value="SoftLight1">Soft Light (Alt 1)</option>
					<option value="SoftLight2">Soft Light (Alt 2)</option>
					<option>Dodge</option>
					<option value="InverseDodge">Inverse Dodge</option>
					<option value="SoftDodge">Soft Dodge</option>
					<option>Burn</option>
					<option value="InverseBurn">Inverse Burn</option>
					<option value="SoftBurn">Soft Burn</option>
					<option>Reflect</option>
					<option>Glow</option>
					<option>Freeze</option>
					<option>Heat</option>
					<option>Additive</option>
					<option>Subtractive</option>
					<option>Stamp</option>
					<option>Interpolation</option>
				</options>
				<on-changed>node.Name.set_value('Color Blend (' .. node.Operation.get_value() .. ')')</on-changed>
			</property>
		</properties>
		<code-generation>
			<code method="lua" target="*"><![CDATA[
				local pats = { -- the patterns per blend mode
					Average =       'type d = half * ( a + b );',
					Screen =        'type d = one - ( one - a ) * ( one - b );',
					Darken =        'type d = lerp( b, a, type( a < b ) );',
					Lighten =       'type d = lerp( b, a, type( a > b ) );',
					Difference =    'type d = abs( a - b );',
					Negation =      'type d = one - abs( one - a - b );',
					Exclusion =     'type d = ( a + b ) - ( two * a * b );',
					Overlay =       'type d_pass = two * a * b;' ..
					                'type d_fail = one - two * ( one - a ) * ( one - b );' ..
					                'type d = lerp( d_fail, d_pass, type( a < half ) );',
					HardLight =     'type d_pass = two * a * b;' ..
					                'type d_fail = one - two * ( one - a ) * ( one - b );' ..
					                'type d = lerp( d_fail, d_pass, type( b < half ) );',
					SoftLight =     'type d_pass = two * a * b + a * a * ( one - two * b );' ..
					                'type d_fail = sqrt( a ) * ( two * b - one ) + two * a * ( one - b );' ..
					                'type d = lerp( d_fail, d_pass, type( b < half ) );',
					SoftLight1 =    'type d = ( one - a ) * a * b + a * ( one - ( one - a ) * ( one - b ) );',
					SoftLight2 =    'type d = two * a * b + a * a - two * a * a * b;',
					Dodge =         'type d = a / ( one - b );',
					InverseDodge =  'type d = b / ( one - a );',
					SoftDodge =     'type d_pass = ( half * a ) / ( one - b );' ..
					                'type d_fail = one - half * ( one - b ) / a;' ..
					                'type d = lerp( d_fail, d_pass, type( ( a + b ) < one ) );',
					Burn =          'type d = one - ( one - a ) / b;',
					InverseBurn =   'type d = one - ( one - b ) / a;',
					SoftBurn =      'type d_pass = ( half * b ) / ( one - a );' ..
					                'type d_fail = one - half * ( one - a ) / b;' ..
					                'type d = lerp( d_fail, d_pass, type( ( a + b ) < one ) );',
					Reflect =       'type d = ( a * a ) / ( one - b );',
					Glow =          'type d = ( b * b ) / ( one - a );',
					Freeze =        'type d = one - ( ( one - a ) * ( one - a ) ) / b;',
					Heat =          'type d = one - ( ( one - b ) * ( one - b ) ) / a;',
					Additive =      'type d = a + b;',
					Subtractive =   'type d = a + b - one;',
					Stamp =         'type d = a + two * b - one;',
					Interpolation = 'type d = half - quarter * cos( pi * a ) - quarter * cos( pi * b );'
				}
				local subs = { -- the substitutions
					type    = node.d.get_type(),                      -- the resulting type
					d       = 'r' .. node.d.uid(),                    -- the resulting variable
					a       = 'r' .. node.a.get_source().uid(),       -- the 1st input variable
					b       = 'r' .. node.b.get_source().uid(),       -- the 2nd input variable
					one     = '( 1.0 )',
					two     = '( 2.0 )',
					half    = '( 0.5 )',
					quarter = '( 0.25 )',
					pi      = '( 3.1415926535897932385 )'
				}
				local op = node.Operation.get_value() -- the blend operation
				local pat = pats[op]
				if pat then
					return pat:gsub('[%w_]+', subs)
				else
					return '#error Unknown blend mode ' .. op
				end
			]]></code>
		</code-generation>
	</node>
	<node type="Color Blend and Layer">
		<description><![CDATA[
			Average:            d = (a+b)/2
			Screen:             d = 1-(1-a)*(1-b)
			Darken:             d = if (a < b ) then a else b
			Lighten:            d = if (a > b ) then a else b
			Difference:         d = |a-b|
			Negation:           d = 1-|1-a-b|
			Exclusion:          d = a+b-2ab
			Overlay:            d = if ( a < 0.5 ) then (2ab) else (1-2*(1-a)*(1-b))
			Hard Light:         d = if ( b < 0.5 ) then (2ab) else (1-2*(1-a)*(1-b))
			Soft Light:         d = if ( b < 0.5 ) then (2ab + aa * (1-2b)) else (sqrt(a) * (2b-1) + 2a * (1-b))
			Soft Light (Alt 1): d = (1-a) * ab + a * ( 1 - (1-a) * (1-b) )
			Soft Light (Alt 2): d = 2ab + aa - 2aab
			Dodge:              d = a / (1-b)
			Inverse Dodge:      d = b / (1-a)
			Soft Dodge:         d = if ( a+b < 1.0 ) then (0.5a / (1-b)) else (1 - 0.5(1-b)/a)
			Burn:               d = 1-(1-a)/b
			Inverse Burn:       d = 1-(1-b)/a
			Soft Burn:          d = if ( a+b < 1.0 ) then (0.5b / (1-a)) else (1 - 0.5(1-a)/b)
			Reflect:            d = aa / (1-b)
			Glow:               d = bb / (1-a)
			Freeze:             d = 1 - (1-a)(1-a) / b
			Heat:               d = 1 - (1-b)(1-b) / a
			Additive:           d = a + b
			Subtractive:        d = a + b - 1
			Stamp:              d = a + 2b - 1
			Interpolation:      d = 0.5 - 0.25*cos(pi*a) - 0.25*cos(pi*b)
			
			Supported Types:
			
			float
			half
			fixed
			float4
			half4
			fixed4
			float3
			half3
			fixed3
			float2
			half2
			fixed2
		]]></description>
		<tool-tip>d = (a+b)/2</tool-tip>
		<ports>
			<input name="a" required="true">
				<check-type method="list" target="*">float,half,fixed,float4,half4,fixed4,float3,half3,fixed3,float2,half2,fixed2</check-type>
			</input>
			<input name="b" required="true">
				<check-type method="list" target="*">float,half,fixed,float4,half4,fixed4,float3,half3,fixed3,float2,half2,fixed2</check-type>
			</input>
      <input name="opacity" required="true">
        <check-type method="lua" target="*">return node.opacity.get_source().get_type() == node.a.get_source().get_type():sub(1, -2)</check-type>
      </input>
			<output name="d">
				<get-type method="same-as" target="*">a</get-type>
			</output>
			<input-constraints method="lua" target="*">
        return node.a.get_source().get_type() == node.b.get_source().get_type() and
          node.opacity.get_source().get_type() == node.a.get_source().get_type():sub(1, -2)
      </input-constraints>
		</ports>
		<properties>
			<default-properties/>
			<property name="Operation" type="list">
				<options>
					<option>Average</option>
					<option>Screen</option>
					<option>Darken</option>
					<option>Lighten</option>
					<option>Difference</option>
					<option>Negation</option>
					<option>Exclusion</option>
					<option>Overlay</option>
					<option value="HardLight">Hard Light</option>
					<option value="SoftLight">Soft Light</option>
					<option value="SoftLight1">Soft Light (Alt 1)</option>
					<option value="SoftLight2">Soft Light (Alt 2)</option>
					<option>Dodge</option>
					<option value="InverseDodge">Inverse Dodge</option>
					<option value="SoftDodge">Soft Dodge</option>
					<option>Burn</option>
					<option value="InverseBurn">Inverse Burn</option>
					<option value="SoftBurn">Soft Burn</option>
					<option>Reflect</option>
					<option>Glow</option>
					<option>Freeze</option>
					<option>Heat</option>
					<option>Additive</option>
					<option>Subtractive</option>
					<option>Stamp</option>
					<option>Interpolation</option>
				</options>
				<on-changed>node.Name.set_value('Color Blend (' .. node.Operation.get_value() .. ')')</on-changed>
			</property>
		</properties>
		<code-generation>
			<code method="lua" target="*"><![CDATA[
				local pats = { -- the patterns per blend mode
					Average =       'type d = half * ( a + b );',
					Screen =        'type d = one - ( one - a ) * ( one - b );',
					Darken =        'type d = lerp( b, a, type( a < b ) );',
					Lighten =       'type d = lerp( b, a, type( a > b ) );',
					Difference =    'type d = abs( a - b );',
					Negation =      'type d = one - abs( one - a - b );',
					Exclusion =     'type d = ( a + b ) - ( two * a * b );',
					Overlay =       'type d_pass = two * a * b;' ..
					                'type d_fail = one - two * ( one - a ) * ( one - b );' ..
					                'type d = lerp( d_fail, d_pass, type( a < half ) );',
					HardLight =     'type d_pass = two * a * b;' ..
					                'type d_fail = one - two * ( one - a ) * ( one - b );' ..
					                'type d = lerp( d_fail, d_pass, type( b < half ) );',
					SoftLight =     'type d_pass = two * a * b + a * a * ( one - two * b );' ..
					                'type d_fail = sqrt( a ) * ( two * b - one ) + two * a * ( one - b );' ..
					                'type d = lerp( d_fail, d_pass, type( b < half ) );',
					SoftLight1 =    'type d = ( one - a ) * a * b + a * ( one - ( one - a ) * ( one - b ) );',
					SoftLight2 =    'type d = two * a * b + a * a - two * a * a * b;',
					Dodge =         'type d = a / ( one - b );',
					InverseDodge =  'type d = b / ( one - a );',
					SoftDodge =     'type d_pass = ( half * a ) / ( one - b );' ..
					                'type d_fail = one - half * ( one - b ) / a;' ..
					                'type d = lerp( d_fail, d_pass, type( ( a + b ) < one ) );',
					Burn =          'type d = one - ( one - a ) / b;',
					InverseBurn =   'type d = one - ( one - b ) / a;',
					SoftBurn =      'type d_pass = ( half * b ) / ( one - a );' ..
					                'type d_fail = one - half * ( one - a ) / b;' ..
					                'type d = lerp( d_fail, d_pass, type( ( a + b ) < one ) );',
					Reflect =       'type d = ( a * a ) / ( one - b );',
					Glow =          'type d = ( b * b ) / ( one - a );',
					Freeze =        'type d = one - ( ( one - a ) * ( one - a ) ) / b;',
					Heat =          'type d = one - ( ( one - b ) * ( one - b ) ) / a;',
					Additive =      'type d = a + b;',
					Subtractive =   'type d = a + b - one;',
					Stamp =         'type d = a + two * b - one;',
					Interpolation = 'type d = half - quarter * cos( pi * a ) - quarter * cos( pi * b );'
				}
				local subs = { -- the substitutions
					type    = node.d.get_type(),                      -- the resulting type
					d       = 'r' .. node.d.uid(),                    -- the resulting variable
					a       = 'r' .. node.a.get_source().uid(),       -- the 1st input variable
					b       = 'r' .. node.b.get_source().uid(),       -- the 2nd input variable
          opacity = 'r' .. node.opacity.get_source().uid(), -- the 3rd input variable
					one     = '( 1.0 )',
					two     = '( 2.0 )',
					half    = '( 0.5 )',
					quarter = '( 0.25 )',
					pi      = '( 3.1415926535897932385 )'
				}
				local op = node.Operation.get_value() -- the blend operation
				local pat = pats[op] .. '\nd = lerp(a, d, type(opacity));'
				if pat then
					return pat:gsub('[%w_]+', subs)
				else
					return '#error Unknown blend mode ' .. op
				end
			]]></code>
		</code-generation>
	</node>
</library>
