<?xml version="1.0"?>
<library path="Cg/stdlib">
	<node type="tex1D( samp, s )">
		<description><![CDATA[
NAME

tex1D - performs a texture lookup in a given 1D sampler and, in some cases, a shadow comparison. May
also use pre computed derivatives if those are provided.


SYNOPSIS

float4 tex1D(sampler1D samp, float s)
float4 tex1D(sampler1D samp, float s, int texelOff)
float4 tex1D(sampler1D samp, float2 s)
float4 tex1D(sampler1D samp, float2 s, int texelOff)
float4 tex1D(sampler1D samp, float s, float dx, float dy)
float4 tex1D(sampler1D samp, float s, float dx, float dy, int texelOff)
float4 tex1D(sampler1D samp, float2 s, float dx, float dy)
float4 tex1D(sampler1D samp, float2 s, float dx, float dy, int texelOff)
int4 tex1D(isampler1D samp, float s);
int4 tex1D(isampler1D samp, float s, int texelOff);
int4 tex1D(isampler1D samp, float s, float dx, float dy)
int4 tex1D(isampler1D samp, float s, float dx, float dy, int texelOff)
uint4 tex1D(usampler1D samp, float s);
uint4 tex1D(usampler1D samp, float s, int texelOff);
uint4 tex1D(usampler1D samp, float s, float dx, float dy)
uint4 tex1D(usampler1D samp, float s, float dx, float dy,int texelOff)


PARAMETERS

samp Sampler to lookup.
s Coordinates to perform the lookup. If an extra coordinate compared to the texture dimensionality
is present it is used to perform a shadow comparison. The value used in the shadow comparison is
always the last component of the coordinate vector.
dx Pre computed derivative along the x axis.
dy Pre computed derivative along the y axis.
texelOff Offset to be added to obtain the final texel.


DESCRIPTION

Performs a texture lookup in sampler samp using coordinates s, may use and derivatives dx and dy, also
may perform shadow comparison and use texel offset texelOff to compute final texel.


REFERENCE IMPLEMENTATION



PROFILE SUPPORT

tex1D is supported in all fragment profiles and all vertex profiles starting with vp40, variants with shadow
comparison are only supported in fp40 and newer profiles, variants with texel offsets are only supported in
gp4 and newer profiles, variants with integer textures are also only supported in gp4 and newer profiles.


SEE ALSO

tex1Dbias, tex1Dlod, tex1Dproj

		]]></description>
		<tool-tip><![CDATA[
			tex1D - performs a texture lookup in a given 1D sampler and, in some cases, a shadow comparison. May
also use pre computed derivatives if those are provided.

		]]></tool-tip>
		<ports>
			<input name="samp">
				<check-type method="list" target="*">
					usampler1D,isampler1D,sampler1D
				</check-type>
			</input>
			<input name="s">
				<check-type method="list" target="*">
					float,float2
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['isampler1D,float'] = 'int4',
						['usampler1D,float'] = 'uint4',
						['sampler1D,float2'] = 'float4',
						['sampler1D,float'] = 'float4',
					}
					local types = node.samp.get_type() .. ',' .. node.s.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = tex1D( r${node.samp.get_source().uid()}, r${node.s.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="radians( a )">
		<description><![CDATA[
NAME

radians - converts values of scalars and vectors from degrees to radians


SYNOPSIS

float radians(float a);
float1 radians(float1 a);
float2 radians(float2 a);
float3 radians(float3 a);
float4 radians(float4 a);
half radians(half a);
half1 radians(half1 a);
half2 radians(half2 a);
half3 radians(half3 a);
half4 radians(half4 a);
fixed radians(fixed a);
fixed1 radians(fixed1 a);
fixed2 radians(fixed2 a);
fixed3 radians(fixed3 a);
fixed4 radians(fixed4 a);


PARAMETERS

a Vector or scalar of which to convert from degrees to radians.


DESCRIPTION

Returns the scalar or vector converted from degrees to radians.
For vectors, the returned vector contains each element of the input vector converted from degrees to
radians.


REFERENCE IMPLEMENTATION

radians for a float scalar could be implemented like this.
float radians(float a)
{
return 0.017453292 * a;
}


PROFILE SUPPORT

radians is supported in all profiles except fp20.


SEE ALSO

cos, degrees, sin, tan

		]]></description>
		<tool-tip><![CDATA[
			radians - converts values of scalars and vectors from degrees to radians

		]]></tool-tip>
		<ports>
			<input name="a">
				<check-type method="list" target="*">
					half4,float4,half,half3,half1,fixed1,fixed4,float1,fixed3,fixed2,float3,float,fixed,half2,float2
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['float4'] = 'float4',
						['half2'] = 'half2',
						['half1'] = 'half1',
						['float'] = 'float',
						['float1'] = 'float1',
						['fixed2'] = 'fixed2',
						['fixed4'] = 'fixed4',
						['fixed3'] = 'fixed3',
						['float3'] = 'float3',
						['float2'] = 'float2',
						['fixed1'] = 'fixed1',
						['fixed'] = 'fixed',
						['half3'] = 'half3',
						['half4'] = 'half4',
						['half'] = 'half',
					}
					local types = node.a.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = radians( r${node.a.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="tex2DARRAY( samp, s, dx, dy )">
		<description><![CDATA[
NAME

tex2DARRAY - performs a texture lookup in a given sampler array may use pre computed derivatives and,
in some cases, perform a shadow comparison.


SYNOPSIS

float4 tex2DARRAY(sampler2DARRAY samp, float3 s)
float4 tex2DARRAY(sampler2DARRAY samp, float3 s, int texelOff)
float4 tex2DARRAY(sampler2DARRAY samp, float4 s)
float4 tex2DARRAY(sampler2DARRAY samp, float4 s, int texelOff)
float4 tex2DARRAY(sampler2DARRAY samp, float3 s, float dx, float dy)
float4 tex2DARRAY(sampler2DARRAY samp, float3 s, float dx, float dy,int texelOff)
float4 tex2DARRAY(sampler2DARRAY samp, float4 s, float dx, float dy)
float4 tex2DARRAY(sampler2DARRAY samp, float4 s, float dx, float dy,int texelOff)
int4 tex2DARRAY(isampler2DARRAY samp, float3 s)
int4 tex2DARRAY(isampler2DARRAY samp, float3 s, int texelOff)
int4 tex2DARRAY(isampler2DARRAY samp, float3 s, float dx, float dy)
int4 tex2DARRAY(isampler2DARRAY samp, float3 s, float dx, float dy,int texelOff)
uint4 tex2DARRAY(usampler2DARRAY samp, float3 s)
uint4 tex2DARRAY(usampler2DARRAY samp, float3 s, int texelOff)
uint4 tex2DARRAY(usampler2DARRAY samp, float3 s, float dx, float dy)
uint4 tex2DARRAY(usampler2DARRAY samp, float3 s, float dx, float dy,int texelOff)


PARAMETERS

samp Sampler array to look up.
s Coordinates to perform the lookup. The value used to select the layer is passed immediatelly after
the regular coordinates, if an extra coordinate is present it is used to perform a shadow
comparison.
dx Pre computed derivative along the x axis.
dy Pre computed derivative along the y axis.
texelOff Offset to be added to obtain the final texel.


DESCRIPTION

Performs a texture lookup in sampler samp using coordinates s, the texture to be sampled is selected from
the layer specified in the coordinates. Also may use the derivatives dx and dy, the lookup may involve a
shadow comparison and use texel offset texelOff to compute the final texel.


REFERENCE IMPLEMENTATION



PROFILE SUPPORT

tex2DARRAY is only supported in gp4 and newer profiles.


SEE ALSO

tex2DARRAYbias, tex2DARRAYlod

		]]></description>
		<tool-tip><![CDATA[
			tex2DARRAY - performs a texture lookup in a given sampler array may use pre computed derivatives and,
in some cases, perform a shadow comparison.

		]]></tool-tip>
		<ports>
			<input name="samp">
				<check-type method="list" target="*">
					usampler2DARRAY,isampler2DARRAY,sampler2DARRAY
				</check-type>
			</input>
			<input name="s">
				<check-type method="list" target="*">
					float3,float4
				</check-type>
			</input>
			<input name="dx">
				<check-type method="list" target="*">
					float
				</check-type>
			</input>
			<input name="dy">
				<check-type method="list" target="*">
					float
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['sampler2DARRAY,float4,float,float'] = 'float4',
						['isampler2DARRAY,float3,float,float'] = 'int4',
						['usampler2DARRAY,float3,float,float'] = 'uint4',
						['sampler2DARRAY,float3,float,float'] = 'float4',
					}
					local types = node.samp.get_type() .. ',' .. node.s.get_type() .. ',' .. node.dx.get_type() .. ',' .. node.dy.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = tex2DARRAY( r${node.samp.get_source().uid()}, r${node.s.get_source().uid()}, r${node.dx.get_source().uid()}, r${node.dy.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="tex3Dlod( samp, s, texelOff )">
		<description><![CDATA[
NAME

tex3Dlod - performs a texture lookup with a specified level of detail in a given sampler.


SYNOPSIS

float4 tex3Dlod(sampler3D samp, float4 s)
float4 tex3Dlod(sampler3D samp, float4 s, int texelOff)
int4 tex3Dlod(isampler3D samp, float4 s)
int4 tex3Dlod(isampler3D samp, float4 s, int texelOff)
uint4 tex3Dlod(usampler3D samp, float4 s)
uint4 tex3Dlod(usampler3D samp, float4 s, int texelOff)


PARAMETERS

samp Sampler to lookup.
s Coordinates to perform the lookup. The level of detail should be passed as the last component of
the coordinate vector.
texelOff Offset to be added to obtain the final texel.


DESCRIPTION

Performs a texture lookup with a specified level of detail in sampler samp using coordinates s.


REFERENCE IMPLEMENTATION



PROFILE SUPPORT

tex3Dlod is supported in fragment profiles starting with fp40 and in vertex profiles starting with vp40.
Variants with texelOff are only supported in gp4 and newer profiles. Variants with integer samplers are also
only suppported in gp4 and newer profiles.


SEE ALSO

tex3Dbias.de Sh
\$1

		]]></description>
		<tool-tip><![CDATA[
			tex3Dlod - performs a texture lookup with a specified level of detail in a given sampler.

		]]></tool-tip>
		<ports>
			<input name="samp">
				<check-type method="list" target="*">
					sampler3D,usampler3D,isampler3D
				</check-type>
			</input>
			<input name="s">
				<check-type method="list" target="*">
					float4
				</check-type>
			</input>
			<input name="texelOff">
				<check-type method="list" target="*">
					int
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['usampler3D,float4,int'] = 'uint4',
						['sampler3D,float4,int'] = 'float4',
						['isampler3D,float4,int'] = 'int4',
					}
					local types = node.samp.get_type() .. ',' .. node.s.get_type() .. ',' .. node.texelOff.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = tex3Dlod( r${node.samp.get_source().uid()}, r${node.s.get_source().uid()}, r${node.texelOff.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="tex3D( samp, s, dx, dy, texelOff )">
		<description><![CDATA[
NAME

tex3D - performs a texture lookup in a given 3D sampler. May also use pre computed derivatives if those
are provided.


SYNOPSIS

float4 tex3D(sampler3D samp, float3 s)
float4 tex3D(sampler3D samp, float3 s, int texelOff)
float4 tex3D(sampler3D samp, float3 s, float3 dx, float3 dy)
float4 tex3D(sampler3D samp, float3 s, float3 dx, float3 dy, int texelOff)
int4 tex3D(isampler3D samp, float3 s)
int4 tex3D(isampler3D samp, float3 s, int texelOff)
int4 tex3D(isampler3D samp, float3 s, float3 dx, float3 dy)
int4 tex3D(isampler3D samp, float3 s, float3 dx, float3 dy, int texelOff)
uint4 tex3D(usampler3D samp, float3 s)
uint4 tex3D(usampler3D samp, float3 s, int texelOff)
uint4 tex3D(usampler3D samp, float3 s, float3 dx, float3 dy)
uint4 tex3D(usampler3D samp, float3 s, float3 dx, float3 dy,int texelOff)


PARAMETERS

samp Sampler to lookup.
s Coordinates to perform the lookup.
dx Pre computed derivative along the x axis.
dy Pre computed derivative along the y axis.
texelOff Offset to be added to obtain the final texel.


DESCRIPTION

Performs a texture lookup in sampler samp using coordinates s, may use and derivatives dx and dy, also
may use texel offset texelOff to compute final texel.


REFERENCE IMPLEMENTATION



PROFILE SUPPORT

tex3D is supported in all fragment profiles and all vertex profiles starting with vp40, variants with texel
offsets are only supported in gp4 and newer profiles. Variants with integer samplers are also only
suppported in gp4 and newer profiles.


SEE ALSO

tex3Dbias, tex3Dlod, tex3Dproj

		]]></description>
		<tool-tip><![CDATA[
			tex3D - performs a texture lookup in a given 3D sampler. May also use pre computed derivatives if those
are provided.

		]]></tool-tip>
		<ports>
			<input name="samp">
				<check-type method="list" target="*">
					sampler3D,usampler3D,isampler3D
				</check-type>
			</input>
			<input name="s">
				<check-type method="list" target="*">
					float3
				</check-type>
			</input>
			<input name="dx">
				<check-type method="list" target="*">
					float3
				</check-type>
			</input>
			<input name="dy">
				<check-type method="list" target="*">
					float3
				</check-type>
			</input>
			<input name="texelOff">
				<check-type method="list" target="*">
					int
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['usampler3D,float3,float3,float3,int'] = 'uint4',
						['isampler3D,float3,float3,float3,int'] = 'int4',
						['sampler3D,float3,float3,float3,int'] = 'float4',
					}
					local types = node.samp.get_type() .. ',' .. node.s.get_type() .. ',' .. node.dx.get_type() .. ',' .. node.dy.get_type() .. ',' .. node.texelOff.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = tex3D( r${node.samp.get_source().uid()}, r${node.s.get_source().uid()}, r${node.dx.get_source().uid()}, r${node.dy.get_source().uid()}, r${node.texelOff.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="texRECTbias( samp, s )">
		<description><![CDATA[
NAME

texRECTbias - performs a texture lookup with bias in a given sampler.


SYNOPSIS

float4 texRECTbias(samplerRECT samp, float4 s)
float4 texRECTbias(samplerRECT samp, float4 s, int2 texelOff)
int4 texRECTbias(isamplerRECT samp, float4 s)
int4 texRECTbias(isamplerRECT samp, float4 s, int2 texelOff)
uint4 texRECTbias(usamplerRECT samp, float4 s)
uint4 texRECTbias(usamplerRECT samp, float4 s, int2 texelOff)


PARAMETERS

samp Sampler to lookup.
s Coordinates to perform the lookup. The bias value should be passed as the last component of the
coordinate vector.
texelOff Offset to be added to obtain the final texel.


DESCRIPTION

Performs a texture lookup with bias in sampler samp using coordinates s.


REFERENCE IMPLEMENTATION



PROFILE SUPPORT

texRECTbias is supported in fragment profiles starting with fp30 and in vertex profiles starting with vp40.
Variants with texelOff are only supported in gp4 and newer profiles. Variants with integer samplers are also
only suppported in gp4 and newer profiles.


SEE ALSO

texRECTlod.de Sh
\$1

		]]></description>
		<tool-tip><![CDATA[
			texRECTbias - performs a texture lookup with bias in a given sampler.

		]]></tool-tip>
		<ports>
			<input name="samp">
				<check-type method="list" target="*">
					isamplerRECT,usamplerRECT,samplerRECT
				</check-type>
			</input>
			<input name="s">
				<check-type method="list" target="*">
					float4
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['samplerRECT,float4'] = 'float4',
						['usamplerRECT,float4'] = 'uint4',
						['isamplerRECT,float4'] = 'int4',
					}
					local types = node.samp.get_type() .. ',' .. node.s.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = texRECTbias( r${node.samp.get_source().uid()}, r${node.s.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="dot( a, b )">
		<description><![CDATA[
NAME

dot - returns the scalar dot product of two vectors


SYNOPSIS

float dot(float a, float b);
float dot(float1 a, float1 b);
float dot(float2 a, float2 b);
float dot(float3 a, float3 b);
float dot(float4 a, float4 b);
half dot(half a, half b);
half dot(half1 a, half1 b);
half dot(half2 a, half2 b);
half dot(half3 a, half3 b);
half dot(half4 a, half4 b);
fixed dot(fixed a, fixed b);
fixed dot(fixed1 a, fixed1 b);
fixed dot(fixed2 a, fixed2 b);
fixed dot(fixed3 a, fixed3 b);
fixed dot(fixed4 a, fixed4 b);


PARAMETERS

a First vector.
b Second vector.


DESCRIPTION

Returns the scalar dot product of two same-typed vectors a and b.


REFERENCE IMPLEMENTATION

dot for float4 vectors could be implemented this way:
float dot(float4 a, float4 b)
{
return a.x*b.x + a.y*b.y + a.z*b.z + a.w*b.w;
}


PROFILE SUPPORT

dot is supported in all profiles.
The fifixed3 dot product is very efficient in the fp20 and fp30 profiles.
The float3 and float4 dot products are very efficient in the vp20, vp30, vp40, arbvp1, fp30, fp40, and
arbfp1 profiles.
The float2 dot product is very efficient in the fp40 profile. In optimal circumstances, two two-component
dot products can sometimes be performed at the four-component and three-component dot product rate.


SEE ALSO

cross, mul

		]]></description>
		<tool-tip><![CDATA[
			dot - returns the scalar dot product of two vectors

		]]></tool-tip>
		<ports>
			<input name="a">
				<check-type method="list" target="*">
					half4,float4,half,half3,half1,fixed1,fixed4,float1,fixed3,fixed2,float3,float,fixed,half2,float2
				</check-type>
			</input>
			<input name="b">
				<check-type method="list" target="*">
					half4,float4,half,half3,half1,fixed1,fixed4,float1,fixed3,fixed2,float3,float,fixed,half2,float2
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['fixed1,fixed1'] = 'fixed',
						['float4,float4'] = 'float',
						['float3,float3'] = 'float',
						['float,float'] = 'float',
						['fixed4,fixed4'] = 'fixed',
						['fixed3,fixed3'] = 'fixed',
						['fixed,fixed'] = 'fixed',
						['fixed2,fixed2'] = 'fixed',
						['half4,half4'] = 'half',
						['half3,half3'] = 'half',
						['float1,float1'] = 'float',
						['half,half'] = 'half',
						['half1,half1'] = 'half',
						['float2,float2'] = 'float',
						['half2,half2'] = 'half',
					}
					local types = node.a.get_type() .. ',' .. node.b.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = dot( r${node.a.get_source().uid()}, r${node.b.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="tex2Dbias( samp, s, texelOff )">
		<description><![CDATA[
NAME

tex2Dbias - performs a texture lookup with bias in a given sampler.


SYNOPSIS

float4 tex2Dbias(sampler2D samp, float4 s)
float4 tex2Dbias(sampler2D samp, float4 s, int texelOff)
int4 tex2Dbias(isampler2D samp, float4 s)
int4 tex2Dbias(isampler2D samp, float4 s, int texelOff)
uint4 tex2Dbias(usampler2D samp, float4 s)
uint4 tex2Dbias(usampler2D samp, float4 s, int texelOff)


PARAMETERS

samp Sampler to lookup.
s Coordinates to perform the lookup. The bias value should be passed as the last component of the
coordinate vector.
texelOff Offset to be added to obtain the final texel.


DESCRIPTION

Performs a texture lookup with bias in sampler samp using coordinates s.


REFERENCE IMPLEMENTATION



PROFILE SUPPORT

tex2Dbias is supported in fragment profiles starting with fp30 and in vertex profiles starting with vp40.
Variants with texelOff are only supported in gp4 and newer profiles. Variants with integer samplers are also
only suppported in gp4 and newer profiles.


SEE ALSO

tex2Dlod, tex2Dcmpbias.de Sh
\$1

		]]></description>
		<tool-tip><![CDATA[
			tex2Dbias - performs a texture lookup with bias in a given sampler.

		]]></tool-tip>
		<ports>
			<input name="samp">
				<check-type method="list" target="*">
					sampler2D,isampler2D,usampler2D
				</check-type>
			</input>
			<input name="s">
				<check-type method="list" target="*">
					float4
				</check-type>
			</input>
			<input name="texelOff">
				<check-type method="list" target="*">
					int
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['usampler2D,float4,int'] = 'uint4',
						['isampler2D,float4,int'] = 'int4',
						['sampler2D,float4,int'] = 'float4',
					}
					local types = node.samp.get_type() .. ',' .. node.s.get_type() .. ',' .. node.texelOff.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = tex2Dbias( r${node.samp.get_source().uid()}, r${node.s.get_source().uid()}, r${node.texelOff.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="tex1DARRAY( samp, s, dx, dy )">
		<description><![CDATA[
NAME

tex1DARRAY - performs a texture lookup in a given sampler array may use pre computed derivatives and,
in some cases, perform a shadow comparison.


SYNOPSIS

float4 tex1DARRAY(sampler1DARRAY samp, float2 s)
float4 tex1DARRAY(sampler1DARRAY samp, float2 s, int texelOff)
float4 tex1DARRAY(sampler1DARRAY samp, float3 s)
float4 tex1DARRAY(sampler1DARRAY samp, float3 s, int texelOff)
float4 tex1DARRAY(sampler1DARRAY samp, float2 s, float dx, float dy)
float4 tex1DARRAY(sampler1DARRAY samp, float2 s, float dx, float dy,int texelOff)
float4 tex1DARRAY(sampler1DARRAY samp, float3 s, float dx, float dy)
float4 tex1DARRAY(sampler1DARRAY samp, float3 s, float dx, float dy,int texelOff)
int4 tex1DARRAY(isampler1DARRAY samp, float2 s)
int4 tex1DARRAY(isampler1DARRAY samp, float2 s, int texelOff)
int4 tex1DARRAY(isampler1DARRAY samp, float2 s, float dx, float dy)
int4 tex1DARRAY(isampler1DARRAY samp, float2 s, float dx, float dy,int texelOff)
uint4 tex1DARRAY(usampler1DARRAY samp, float2 s)
uint4 tex1DARRAY(usampler1DARRAY samp, float2 s, int texelOff)
uint4 tex1DARRAY(usampler1DARRAY samp, float2 s, float dx, float dy)
uint4 tex1DARRAY(usampler1DARRAY samp, float2 s, float dx, float dy,int texelOff)


PARAMETERS

samp Sampler array to look up.
s Coordinates to perform the lookup. The value used to select the layer is passed immediatelly after
the regular coordinates, if an extra coordinate is present it is used to perform a shadow
comparison.
dx Pre computed derivative along the x axis.
dy Pre computed derivative along the y axis.
texelOff Offset to be added to obtain the final texel.


DESCRIPTION

Performs a texture lookup in sampler samp using coordinates s, the texture to be sampled is selected from
the layer specified in the coordinates. Also may use the derivatives dx and dy, the lookup may involve a
shadow comparison and use texel offset texelOff to compute the final texel.


REFERENCE IMPLEMENTATION



PROFILE SUPPORT

tex1DARRAY is only supported in gp4 and newer profiles.


SEE ALSO

tex1DARRAYbias, tex1DARRAYlod

		]]></description>
		<tool-tip><![CDATA[
			tex1DARRAY - performs a texture lookup in a given sampler array may use pre computed derivatives and,
in some cases, perform a shadow comparison.

		]]></tool-tip>
		<ports>
			<input name="samp">
				<check-type method="list" target="*">
					usampler1DARRAY,sampler1DARRAY,isampler1DARRAY
				</check-type>
			</input>
			<input name="s">
				<check-type method="list" target="*">
					float3,float2
				</check-type>
			</input>
			<input name="dx">
				<check-type method="list" target="*">
					float
				</check-type>
			</input>
			<input name="dy">
				<check-type method="list" target="*">
					float
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['sampler1DARRAY,float2,float,float'] = 'float4',
						['usampler1DARRAY,float2,float,float'] = 'uint4',
						['isampler1DARRAY,float2,float,float'] = 'int4',
						['sampler1DARRAY,float3,float,float'] = 'float4',
					}
					local types = node.samp.get_type() .. ',' .. node.s.get_type() .. ',' .. node.dx.get_type() .. ',' .. node.dy.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = tex1DARRAY( r${node.samp.get_source().uid()}, r${node.s.get_source().uid()}, r${node.dx.get_source().uid()}, r${node.dy.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="texRECT( samp, s )">
		<description><![CDATA[
NAME

texRECT - performs a texture lookup in a given RECT sampler and, in some cases, a shadow comparison.
May also use pre computed derivatives if those are provided.


SYNOPSIS

float4 texRECT(samplerRECT samp, float2 s)
float4 texRECT(samplerRECT samp, float2 s, int texelOff)
float4 texRECT(samplerRECT samp, float3 s)
float4 texRECT(samplerRECT samp, float3 s, int texelOff)
float4 texRECT(samplerRECT samp, float2 s, float2 dx, float2 dy)
float4 texRECT(samplerRECT samp, float2 s, float2 dx, float2 dy, int texelOff)
float4 texRECT(samplerRECT samp, float3 s, float2 dx, float2 dy)
float4 texRECT(samplerRECT samp, float3 s, float2 dx, float2 dy, int texelOff)
int4 texRECT(isamplerRECT samp, float2 s)
int4 texRECT(isamplerRECT samp, float2 s, int texelOff)
int4 texRECT(isamplerRECT samp, float2 s, float2 dx, float2 dy)
int4 texRECT(isamplerRECT samp, float2 s, float2 dx, float2 dy, int texelOff)
uint4 texRECT(usamplerRECT samp, float2 s)
uint4 texRECT(usamplerRECT samp, float2 s, int texelOff)
uint4 texRECT(usamplerRECT samp, float2 s, float2 dx, float2 dy)
uint4 texRECT(usamplerRECT samp, float2 s, float2 dx, float2 dy,int texelOff)


PARAMETERS

samp Sampler to lookup.
s Coordinates to perform the lookup. If an extra coordinate compared to the texture dimensionality
is present it is used to perform a shadow comparison. The value used in the shadow comparison is
always the last component of the coordinate vector.
dx Pre computed derivative along the x axis.
dy Pre computed derivative along the y axis.
texelOff Offset to be added to obtain the final texel.


DESCRIPTION

Performs a texture lookup in sampler samp using coordinates s, may use and derivatives dx and dy, also
may perform shadow comparison and use texel offset texelOff to compute final texel.


REFERENCE IMPLEMENTATION



PROFILE SUPPORT

texRECT is supported in all fragment profiles and all vertex profiles starting with vp40, variants with
shadow comparison are only supported in fp40 and newer profiles, variants with texel offsets are only
supported in gp4 and newer profiles. Variants with integer samplers are only supported in gp4 and newer
profiles.


SEE ALSO

texRECTbias, texRECTlod, texRECTproj

		]]></description>
		<tool-tip><![CDATA[
			texRECT - performs a texture lookup in a given RECT sampler and, in some cases, a shadow comparison.
May also use pre computed derivatives if those are provided.

		]]></tool-tip>
		<ports>
			<input name="samp">
				<check-type method="list" target="*">
					isamplerRECT,usamplerRECT,samplerRECT
				</check-type>
			</input>
			<input name="s">
				<check-type method="list" target="*">
					float3,float2
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['usamplerRECT,float2'] = 'uint4',
						['isamplerRECT,float2'] = 'int4',
						['samplerRECT,float3'] = 'float4',
						['samplerRECT,float2'] = 'float4',
					}
					local types = node.samp.get_type() .. ',' .. node.s.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = texRECT( r${node.samp.get_source().uid()}, r${node.s.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="tex3Dfetch( samp, s )">
		<description><![CDATA[
NAME

tex3Dfetch - performs an unfiltered texture lookup in a given sampler.


SYNOPSIS

float4 tex3Dfetch(sampler3D samp, int4 s)
float4 tex3Dfetch(sampler3D samp, int4 s, int texelOff)
int4 tex3Dfetch(isampler3D samp, int4 s)
int4 tex3Dfetch(isampler3D samp, int4 s, int texelOff)
uint4 tex3Dfetch(usampler3D samp, int4 s)
uint4 tex3Dfetch(usampler3D samp, int4 s, int texelOff)


PARAMETERS

samp Sampler to lookup.
s Coordinates to perform the lookup. The level of detail is stored in the last component of the
coordinate vector.
texelOff Offset to be added to obtain the final texel.


DESCRIPTION

Performs an unfiltered texture lookup in sampler samp using coordinates s. The level of detail is provided
by the last component of the coordinate vector. May use texel offset texelOff to compute final texel.


REFERENCE IMPLEMENTATION



PROFILE SUPPORT

tex3Dfetch is only supported in gp4 and newer profiles.


SEE ALSO

tex3D.de Sh
\$1

		]]></description>
		<tool-tip><![CDATA[
			tex3Dfetch - performs an unfiltered texture lookup in a given sampler.

		]]></tool-tip>
		<ports>
			<input name="samp">
				<check-type method="list" target="*">
					sampler3D,usampler3D,isampler3D
				</check-type>
			</input>
			<input name="s">
				<check-type method="list" target="*">
					int4
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['isampler3D,int4'] = 'int4',
						['sampler3D,int4'] = 'float4',
						['usampler3D,int4'] = 'uint4',
					}
					local types = node.samp.get_type() .. ',' .. node.s.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = tex3Dfetch( r${node.samp.get_source().uid()}, r${node.s.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="tex2DARRAYproj( samp, s, texelOff )">
		<description><![CDATA[
NAME

tex2DARRAYproj - performs a texture lookup with projection in a given sampler array.


SYNOPSIS

float4 tex2DARRAYproj(sampler2DARRAY samp, float3 s)
float4 tex2DARRAYproj(sampler2DARRAY samp, float3 s, int texelOff)
int4 tex2DARRAYproj(isampler2DARRAY samp, float3 s)
int4 tex2DARRAYproj(isampler2DARRAY samp, float3 s, int texelOff)
uint4 tex2DARRAYproj(usampler2DARRAY samp, float3 s)
uint4 tex2DARRAYproj(usampler2DARRAY samp, float3 s, int texelOff)


PARAMETERS

samp Sampler array to lookup.
s Coordinates to perform the lookup. The value used to select the layer should be passed as the
component right after the lookup coordinates. The value used in the projection should be passed
as the last component of the coordinate vector.
texelOff Offset to be added to obtain the final texel.


DESCRIPTION

Performs a texture lookup in sampler array samp using coordinates s, the layer used in the lookup is first
selected using the coordinate component right after the regular coordinates. The coordinates used in the
lookup are then projected, that is, divided by the last component of the coordinate vector and them used in
the lookup.


REFERENCE IMPLEMENTATION



PROFILE SUPPORT

tex2DARRAYproj is only supported in gp4 and newer profiles.


SEE ALSO

tex2D, tex2Dproj

		]]></description>
		<tool-tip><![CDATA[
			tex2DARRAYproj - performs a texture lookup with projection in a given sampler array.

		]]></tool-tip>
		<ports>
			<input name="samp">
				<check-type method="list" target="*">
					usampler2DARRAY,isampler2DARRAY,sampler2DARRAY
				</check-type>
			</input>
			<input name="s">
				<check-type method="list" target="*">
					float3
				</check-type>
			</input>
			<input name="texelOff">
				<check-type method="list" target="*">
					int
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['sampler2DARRAY,float3,int'] = 'float4',
						['isampler2DARRAY,float3,int'] = 'int4',
						['usampler2DARRAY,float3,int'] = 'uint4',
					}
					local types = node.samp.get_type() .. ',' .. node.s.get_type() .. ',' .. node.texelOff.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = tex2DARRAYproj( r${node.samp.get_source().uid()}, r${node.s.get_source().uid()}, r${node.texelOff.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="tex3D( samp, s )">
		<description><![CDATA[
NAME

tex3D - performs a texture lookup in a given 3D sampler. May also use pre computed derivatives if those
are provided.


SYNOPSIS

float4 tex3D(sampler3D samp, float3 s)
float4 tex3D(sampler3D samp, float3 s, int texelOff)
float4 tex3D(sampler3D samp, float3 s, float3 dx, float3 dy)
float4 tex3D(sampler3D samp, float3 s, float3 dx, float3 dy, int texelOff)
int4 tex3D(isampler3D samp, float3 s)
int4 tex3D(isampler3D samp, float3 s, int texelOff)
int4 tex3D(isampler3D samp, float3 s, float3 dx, float3 dy)
int4 tex3D(isampler3D samp, float3 s, float3 dx, float3 dy, int texelOff)
uint4 tex3D(usampler3D samp, float3 s)
uint4 tex3D(usampler3D samp, float3 s, int texelOff)
uint4 tex3D(usampler3D samp, float3 s, float3 dx, float3 dy)
uint4 tex3D(usampler3D samp, float3 s, float3 dx, float3 dy,int texelOff)


PARAMETERS

samp Sampler to lookup.
s Coordinates to perform the lookup.
dx Pre computed derivative along the x axis.
dy Pre computed derivative along the y axis.
texelOff Offset to be added to obtain the final texel.


DESCRIPTION

Performs a texture lookup in sampler samp using coordinates s, may use and derivatives dx and dy, also
may use texel offset texelOff to compute final texel.


REFERENCE IMPLEMENTATION



PROFILE SUPPORT

tex3D is supported in all fragment profiles and all vertex profiles starting with vp40, variants with texel
offsets are only supported in gp4 and newer profiles. Variants with integer samplers are also only
suppported in gp4 and newer profiles.


SEE ALSO

tex3Dbias, tex3Dlod, tex3Dproj

		]]></description>
		<tool-tip><![CDATA[
			tex3D - performs a texture lookup in a given 3D sampler. May also use pre computed derivatives if those
are provided.

		]]></tool-tip>
		<ports>
			<input name="samp">
				<check-type method="list" target="*">
					sampler3D,usampler3D,isampler3D
				</check-type>
			</input>
			<input name="s">
				<check-type method="list" target="*">
					float3
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['isampler3D,float3'] = 'int4',
						['sampler3D,float3'] = 'float4',
						['usampler3D,float3'] = 'uint4',
					}
					local types = node.samp.get_type() .. ',' .. node.s.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = tex3D( r${node.samp.get_source().uid()}, r${node.s.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="tex1DARRAYbias( samp, s )">
		<description><![CDATA[
NAME

tex1DARRAYbias - performs a texture lookup with bias in a given sampler array.


SYNOPSIS

float4 tex1DARRAYbias(sampler1DARRAY samp, float4 s)
float4 tex1DARRAYbias(sampler1DARRAY samp, float4 s, int texelOff)
int4 tex1DARRAYbias(isampler1DARRAY samp, float4 s)
int4 tex1DARRAYbias(isampler1DARRAY samp, float4 s, int texelOff)
uint4 tex1DARRAYbias(usampler1DARRAY samp, float4 s)
uint4 tex1DARRAYbias(usampler1DARRAY samp, float4 s, int texelOff)


PARAMETERS

samp Sampler array to lookup.
s Coordinates to perform the lookup. The value used to select the layer should be passed in the
vector component right after the regular coordinates. The bias value should be passed as the last
component of the coordinate vector.
texelOff Offset to be added to obtain the final texel.


DESCRIPTION

Performs a texture lookup with bias in sampler samp using coordinates s, the texture to be sampled is
selected from the layer specified in the coordinates.


REFERENCE IMPLEMENTATION



PROFILE SUPPORT

tex1DARRAYbias is only supported in gp4 and newer profiles.


SEE ALSO

tex1DARRAY, tex1DARRAYlod

		]]></description>
		<tool-tip><![CDATA[
			tex1DARRAYbias - performs a texture lookup with bias in a given sampler array.

		]]></tool-tip>
		<ports>
			<input name="samp">
				<check-type method="list" target="*">
					usampler1DARRAY,sampler1DARRAY,isampler1DARRAY
				</check-type>
			</input>
			<input name="s">
				<check-type method="list" target="*">
					float4
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['usampler1DARRAY,float4'] = 'uint4',
						['isampler1DARRAY,float4'] = 'int4',
						['sampler1DARRAY,float4'] = 'float4',
					}
					local types = node.samp.get_type() .. ',' .. node.s.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = tex1DARRAYbias( r${node.samp.get_source().uid()}, r${node.s.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="tex2Dlod( samp, s )">
		<description><![CDATA[
NAME

tex2Dlod - performs a texture lookup with a specified level of detail in a given sampler.


SYNOPSIS

float4 tex2Dlod(sampler2D samp, float4 s)
float4 tex2Dlod(sampler2D samp, float4 s, int texelOff)
int4 tex2Dlod(isampler2D samp, float4 s)
int4 tex2Dlod(isampler2D samp, float4 s, int texelOff)
uint4 tex2Dlod(usampler2D samp, float4 s)
uint4 tex2Dlod(usampler2D samp, float4 s, int texelOff)


PARAMETERS

samp Sampler to lookup.
s Coordinates to perform the lookup. The level of detail should be passed as the last component of
the coordinate vector.
texelOff Offset to be added to obtain the final texel.


DESCRIPTION

Performs a texture lookup with a specified level of detail in sampler samp using coordinates s.


REFERENCE IMPLEMENTATION



PROFILE SUPPORT

tex2Dlod is supported in fragment profiles starting with fp40 and in vertex profiles starting with vp40.
Variants with texelOff are only supported in gp4 and newer profiles. Variants with integer samplers are also
only suppported in gp4 and newer profiles.


SEE ALSO

tex2Dbias, tex2Dcmplod.de Sh
\$1

		]]></description>
		<tool-tip><![CDATA[
			tex2Dlod - performs a texture lookup with a specified level of detail in a given sampler.

		]]></tool-tip>
		<ports>
			<input name="samp">
				<check-type method="list" target="*">
					sampler2D,isampler2D,usampler2D
				</check-type>
			</input>
			<input name="s">
				<check-type method="list" target="*">
					float4
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['isampler2D,float4'] = 'int4',
						['sampler2D,float4'] = 'float4',
						['usampler2D,float4'] = 'uint4',
					}
					local types = node.samp.get_type() .. ',' .. node.s.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = tex2Dlod( r${node.samp.get_source().uid()}, r${node.s.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="texRECT( samp, s, texelOff )">
		<description><![CDATA[
NAME

texRECT - performs a texture lookup in a given RECT sampler and, in some cases, a shadow comparison.
May also use pre computed derivatives if those are provided.


SYNOPSIS

float4 texRECT(samplerRECT samp, float2 s)
float4 texRECT(samplerRECT samp, float2 s, int texelOff)
float4 texRECT(samplerRECT samp, float3 s)
float4 texRECT(samplerRECT samp, float3 s, int texelOff)
float4 texRECT(samplerRECT samp, float2 s, float2 dx, float2 dy)
float4 texRECT(samplerRECT samp, float2 s, float2 dx, float2 dy, int texelOff)
float4 texRECT(samplerRECT samp, float3 s, float2 dx, float2 dy)
float4 texRECT(samplerRECT samp, float3 s, float2 dx, float2 dy, int texelOff)
int4 texRECT(isamplerRECT samp, float2 s)
int4 texRECT(isamplerRECT samp, float2 s, int texelOff)
int4 texRECT(isamplerRECT samp, float2 s, float2 dx, float2 dy)
int4 texRECT(isamplerRECT samp, float2 s, float2 dx, float2 dy, int texelOff)
uint4 texRECT(usamplerRECT samp, float2 s)
uint4 texRECT(usamplerRECT samp, float2 s, int texelOff)
uint4 texRECT(usamplerRECT samp, float2 s, float2 dx, float2 dy)
uint4 texRECT(usamplerRECT samp, float2 s, float2 dx, float2 dy,int texelOff)


PARAMETERS

samp Sampler to lookup.
s Coordinates to perform the lookup. If an extra coordinate compared to the texture dimensionality
is present it is used to perform a shadow comparison. The value used in the shadow comparison is
always the last component of the coordinate vector.
dx Pre computed derivative along the x axis.
dy Pre computed derivative along the y axis.
texelOff Offset to be added to obtain the final texel.


DESCRIPTION

Performs a texture lookup in sampler samp using coordinates s, may use and derivatives dx and dy, also
may perform shadow comparison and use texel offset texelOff to compute final texel.


REFERENCE IMPLEMENTATION



PROFILE SUPPORT

texRECT is supported in all fragment profiles and all vertex profiles starting with vp40, variants with
shadow comparison are only supported in fp40 and newer profiles, variants with texel offsets are only
supported in gp4 and newer profiles. Variants with integer samplers are only supported in gp4 and newer
profiles.


SEE ALSO

texRECTbias, texRECTlod, texRECTproj

		]]></description>
		<tool-tip><![CDATA[
			texRECT - performs a texture lookup in a given RECT sampler and, in some cases, a shadow comparison.
May also use pre computed derivatives if those are provided.

		]]></tool-tip>
		<ports>
			<input name="samp">
				<check-type method="list" target="*">
					isamplerRECT,usamplerRECT,samplerRECT
				</check-type>
			</input>
			<input name="s">
				<check-type method="list" target="*">
					float3,float2
				</check-type>
			</input>
			<input name="texelOff">
				<check-type method="list" target="*">
					int
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['samplerRECT,float3,int'] = 'float4',
						['samplerRECT,float2,int'] = 'float4',
						['usamplerRECT,float2,int'] = 'uint4',
						['isamplerRECT,float2,int'] = 'int4',
					}
					local types = node.samp.get_type() .. ',' .. node.s.get_type() .. ',' .. node.texelOff.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = texRECT( r${node.samp.get_source().uid()}, r${node.s.get_source().uid()}, r${node.texelOff.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="tex1DARRAYbias( samp, s, texelOff )">
		<description><![CDATA[
NAME

tex1DARRAYbias - performs a texture lookup with bias in a given sampler array.


SYNOPSIS

float4 tex1DARRAYbias(sampler1DARRAY samp, float4 s)
float4 tex1DARRAYbias(sampler1DARRAY samp, float4 s, int texelOff)
int4 tex1DARRAYbias(isampler1DARRAY samp, float4 s)
int4 tex1DARRAYbias(isampler1DARRAY samp, float4 s, int texelOff)
uint4 tex1DARRAYbias(usampler1DARRAY samp, float4 s)
uint4 tex1DARRAYbias(usampler1DARRAY samp, float4 s, int texelOff)


PARAMETERS

samp Sampler array to lookup.
s Coordinates to perform the lookup. The value used to select the layer should be passed in the
vector component right after the regular coordinates. The bias value should be passed as the last
component of the coordinate vector.
texelOff Offset to be added to obtain the final texel.


DESCRIPTION

Performs a texture lookup with bias in sampler samp using coordinates s, the texture to be sampled is
selected from the layer specified in the coordinates.


REFERENCE IMPLEMENTATION



PROFILE SUPPORT

tex1DARRAYbias is only supported in gp4 and newer profiles.


SEE ALSO

tex1DARRAY, tex1DARRAYlod

		]]></description>
		<tool-tip><![CDATA[
			tex1DARRAYbias - performs a texture lookup with bias in a given sampler array.

		]]></tool-tip>
		<ports>
			<input name="samp">
				<check-type method="list" target="*">
					usampler1DARRAY,sampler1DARRAY,isampler1DARRAY
				</check-type>
			</input>
			<input name="s">
				<check-type method="list" target="*">
					float4
				</check-type>
			</input>
			<input name="texelOff">
				<check-type method="list" target="*">
					int
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['isampler1DARRAY,float4,int'] = 'int4',
						['sampler1DARRAY,float4,int'] = 'float4',
						['usampler1DARRAY,float4,int'] = 'uint4',
					}
					local types = node.samp.get_type() .. ',' .. node.s.get_type() .. ',' .. node.texelOff.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = tex1DARRAYbias( r${node.samp.get_source().uid()}, r${node.s.get_source().uid()}, r${node.texelOff.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="tex2DARRAYproj( samp, s )">
		<description><![CDATA[
NAME

tex2DARRAYproj - performs a texture lookup with projection in a given sampler array.


SYNOPSIS

float4 tex2DARRAYproj(sampler2DARRAY samp, float3 s)
float4 tex2DARRAYproj(sampler2DARRAY samp, float3 s, int texelOff)
int4 tex2DARRAYproj(isampler2DARRAY samp, float3 s)
int4 tex2DARRAYproj(isampler2DARRAY samp, float3 s, int texelOff)
uint4 tex2DARRAYproj(usampler2DARRAY samp, float3 s)
uint4 tex2DARRAYproj(usampler2DARRAY samp, float3 s, int texelOff)


PARAMETERS

samp Sampler array to lookup.
s Coordinates to perform the lookup. The value used to select the layer should be passed as the
component right after the lookup coordinates. The value used in the projection should be passed
as the last component of the coordinate vector.
texelOff Offset to be added to obtain the final texel.


DESCRIPTION

Performs a texture lookup in sampler array samp using coordinates s, the layer used in the lookup is first
selected using the coordinate component right after the regular coordinates. The coordinates used in the
lookup are then projected, that is, divided by the last component of the coordinate vector and them used in
the lookup.


REFERENCE IMPLEMENTATION



PROFILE SUPPORT

tex2DARRAYproj is only supported in gp4 and newer profiles.


SEE ALSO

tex2D, tex2Dproj

		]]></description>
		<tool-tip><![CDATA[
			tex2DARRAYproj - performs a texture lookup with projection in a given sampler array.

		]]></tool-tip>
		<ports>
			<input name="samp">
				<check-type method="list" target="*">
					usampler2DARRAY,isampler2DARRAY,sampler2DARRAY
				</check-type>
			</input>
			<input name="s">
				<check-type method="list" target="*">
					float3
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['isampler2DARRAY,float3'] = 'int4',
						['usampler2DARRAY,float3'] = 'uint4',
						['sampler2DARRAY,float3'] = 'float4',
					}
					local types = node.samp.get_type() .. ',' .. node.s.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = tex2DARRAYproj( r${node.samp.get_source().uid()}, r${node.s.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="tex1Dcmplod( samp, s )">
		<description><![CDATA[
NAME

tex1Dcmplod - performs a texture lookup with a specified level of detail and a shadow compare in a given
sampler.


SYNOPSIS

float4 tex1Dcmplod(sampler1D samp, float4 s)
float4 tex1Dcmplod(sampler1D samp, float4 s, int texelOff)
int4 tex1Dcmplod(isampler1D samp, float4 s)
int4 tex1Dcmplod(isampler1D samp, float4 s, int texelOff)
uint4 tex1Dcmplod(usampler1D samp, float4 s)
uint4 tex1Dcmplod(usampler1D samp, float4 s, int texelOff)


PARAMETERS

samp Sampler to lookup.
s Coordinates to perform the lookup. The value used in the shadow comparison should be passed
right after the normal coordinates. The level of detail corresponds to the last component of the
coordinate vector.
texelOff Offset to be added to obtain the final texel.


DESCRIPTION

Performs a texture lookup with shadow compare and a specified level of detail in sampler samp using
coordinates s.


REFERENCE IMPLEMENTATION



PROFILE SUPPORT

tex1Dcmplod is supported in fragment profiles starting with fp40 and in vertex profiles starting with vp40.
Variants with texelOff are only supported in gp4 and newer profiles. Variants with integer samplers are also
only suppported in gp4 and newer profiles.


SEE ALSO

tex1Dlod, tex1Dcmpbias

		]]></description>
		<tool-tip><![CDATA[
			tex1Dcmplod - performs a texture lookup with a specified level of detail and a shadow compare in a given
sampler.

		]]></tool-tip>
		<ports>
			<input name="samp">
				<check-type method="list" target="*">
					usampler1D,isampler1D,sampler1D
				</check-type>
			</input>
			<input name="s">
				<check-type method="list" target="*">
					float4
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['usampler1D,float4'] = 'uint4',
						['isampler1D,float4'] = 'int4',
						['sampler1D,float4'] = 'float4',
					}
					local types = node.samp.get_type() .. ',' .. node.s.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = tex1Dcmplod( r${node.samp.get_source().uid()}, r${node.s.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="tex2DARRAY( samp, s, texelOff )">
		<description><![CDATA[
NAME

tex2DARRAY - performs a texture lookup in a given sampler array may use pre computed derivatives and,
in some cases, perform a shadow comparison.


SYNOPSIS

float4 tex2DARRAY(sampler2DARRAY samp, float3 s)
float4 tex2DARRAY(sampler2DARRAY samp, float3 s, int texelOff)
float4 tex2DARRAY(sampler2DARRAY samp, float4 s)
float4 tex2DARRAY(sampler2DARRAY samp, float4 s, int texelOff)
float4 tex2DARRAY(sampler2DARRAY samp, float3 s, float dx, float dy)
float4 tex2DARRAY(sampler2DARRAY samp, float3 s, float dx, float dy,int texelOff)
float4 tex2DARRAY(sampler2DARRAY samp, float4 s, float dx, float dy)
float4 tex2DARRAY(sampler2DARRAY samp, float4 s, float dx, float dy,int texelOff)
int4 tex2DARRAY(isampler2DARRAY samp, float3 s)
int4 tex2DARRAY(isampler2DARRAY samp, float3 s, int texelOff)
int4 tex2DARRAY(isampler2DARRAY samp, float3 s, float dx, float dy)
int4 tex2DARRAY(isampler2DARRAY samp, float3 s, float dx, float dy,int texelOff)
uint4 tex2DARRAY(usampler2DARRAY samp, float3 s)
uint4 tex2DARRAY(usampler2DARRAY samp, float3 s, int texelOff)
uint4 tex2DARRAY(usampler2DARRAY samp, float3 s, float dx, float dy)
uint4 tex2DARRAY(usampler2DARRAY samp, float3 s, float dx, float dy,int texelOff)


PARAMETERS

samp Sampler array to look up.
s Coordinates to perform the lookup. The value used to select the layer is passed immediatelly after
the regular coordinates, if an extra coordinate is present it is used to perform a shadow
comparison.
dx Pre computed derivative along the x axis.
dy Pre computed derivative along the y axis.
texelOff Offset to be added to obtain the final texel.


DESCRIPTION

Performs a texture lookup in sampler samp using coordinates s, the texture to be sampled is selected from
the layer specified in the coordinates. Also may use the derivatives dx and dy, the lookup may involve a
shadow comparison and use texel offset texelOff to compute the final texel.


REFERENCE IMPLEMENTATION



PROFILE SUPPORT

tex2DARRAY is only supported in gp4 and newer profiles.


SEE ALSO

tex2DARRAYbias, tex2DARRAYlod

		]]></description>
		<tool-tip><![CDATA[
			tex2DARRAY - performs a texture lookup in a given sampler array may use pre computed derivatives and,
in some cases, perform a shadow comparison.

		]]></tool-tip>
		<ports>
			<input name="samp">
				<check-type method="list" target="*">
					usampler2DARRAY,isampler2DARRAY,sampler2DARRAY
				</check-type>
			</input>
			<input name="s">
				<check-type method="list" target="*">
					float3,float4
				</check-type>
			</input>
			<input name="texelOff">
				<check-type method="list" target="*">
					int
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['sampler2DARRAY,float4,int'] = 'float4',
						['isampler2DARRAY,float3,int'] = 'int4',
						['usampler2DARRAY,float3,int'] = 'uint4',
						['sampler2DARRAY,float3,int'] = 'float4',
					}
					local types = node.samp.get_type() .. ',' .. node.s.get_type() .. ',' .. node.texelOff.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = tex2DARRAY( r${node.samp.get_source().uid()}, r${node.s.get_source().uid()}, r${node.texelOff.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="fwidth( a )">
		<description><![CDATA[
NAME

fwidth - returns sum of approximate window-space partial derivatives magnitudes


SYNOPSIS

float fwidth(float a);
float1 fwidth(float1 a);
float2 fwidth(float2 a);
float3 fwidth(float3 a);
float4 fwidth(float4 a);
half fwidth(half a);
half1 fwidth(half1 a);
half2 fwidth(half2 a);
half3 fwidth(half3 a);
half4 fwidth(half4 a);
fixed fwidth(fixed a);
fixed1 fwidth(fixed1 a);
fixed2 fwidth(fixed2 a);
fixed3 fwidth(fixed3 a);
fixed4 fwidth(fixed4 a);


PARAMETERS

a Vector or scalar of which to sum its approximate window-space partial derivative magnitudes.
with respect to window-space X and Y.


DESCRIPTION

Returns sum of the absolute values of each approximate partial derivative of a with respect to both the
window-space (horizontal) x and (vertical) y) coordinate.
.PP For vectors, the returned vector contains the sum of partial derivative magnitudes of each element of the
input vector.
This function can be used to approximate the fragment width (hence the name "fwidth") for level-of-detail
computations dependent on change in window-space.
This function is only available in fragment program profiles (but not all of them).
The specific way the partial derivative is computed is implementation-dependent. Typically fragments are
rasterized in 2x2 arrangements of fragments (called quad-fragments) and the partial derivatives of a
variable is computed by differencing with the adjacent horizontal fragment in the quad-fragment.
The partial derivative computation may incorrect when fwidth is used in control flow paths where not all
the fragments within a quad-fragment have branched the same way.
The partial derivative computation may be less exact (wobbly) when the variable is computed based on
varying parameters interpolated with centroid interpolation.


REFERENCE IMPLEMENTATION

fmod for float3 vectors could be implemented this way:
float3 fwidth(float3 a)
{
return abs(ddx(a)) + abs(ddy(a));
}


PROFILE SUPPORT

fwidth is supported only in fragment profiles. Vertex and geometry profiles lack the concept of window
space.
fwidth is unsupported in the fp20, ps_1_1, ps_1_2, ps_1_3, and arbfp1 profiles.


SEE ALSO

ddx, ddy, fp30, fp40, gp4fp

		]]></description>
		<tool-tip><![CDATA[
			fwidth - returns sum of approximate window-space partial derivatives magnitudes

		]]></tool-tip>
		<ports>
			<input name="a">
				<check-type method="list" target="*">
					half4,float4,half,half3,half1,fixed1,fixed4,float1,fixed3,fixed2,float3,float,fixed,half2,float2
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['float4'] = 'float4',
						['half2'] = 'half2',
						['half1'] = 'half1',
						['float'] = 'float',
						['float1'] = 'float1',
						['fixed2'] = 'fixed2',
						['fixed4'] = 'fixed4',
						['fixed3'] = 'fixed3',
						['float3'] = 'float3',
						['float2'] = 'float2',
						['fixed1'] = 'fixed1',
						['fixed'] = 'fixed',
						['half3'] = 'half3',
						['half4'] = 'half4',
						['half'] = 'half',
					}
					local types = node.a.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = fwidth( r${node.a.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="tex1DARRAYcmplod( samp, s, texelOff )">
		<description><![CDATA[
NAME

tex1DARRAYcmplod - performs a texture lookup with shadow compare and a level of detail in a given
sampler array.


SYNOPSIS

float4 tex1DARRAYcmplod(sampler1DARRAY samp, float4 s)
float4 tex1DARRAYcmplod(sampler1DARRAY samp, float4 s, int texelOff)


PARAMETERS

samp Sampler array to look up.
s Coordinates to perform the lookup. The value used to select the layer is the second coordinate,
the third is the value used in the shadow comparison, the fourth corresponds to the level of detail.
texelOff Offset to be added to obtain the final texel.


DESCRIPTION

Performs a texture lookup with level of detail in sampler samp using coordinates s, the texture to be
sampled is selected from the layer specified in the coordinates, the lookup involves a shadow comparison
and may use texel offset texelOff to compute the final texel.


REFERENCE IMPLEMENTATION



PROFILE SUPPORT

tex1DARRAYcmplod is only supported in gp4 and newer profiles.


SEE ALSO

tex1DARRAYlod, tex1DARRAYbias, tex1DARRAYcmpbias.de Sh
\$1

		]]></description>
		<tool-tip><![CDATA[
			tex1DARRAYcmplod - performs a texture lookup with shadow compare and a level of detail in a given
sampler array.

		]]></tool-tip>
		<ports>
			<input name="samp">
				<check-type method="list" target="*">
					sampler1DARRAY
				</check-type>
			</input>
			<input name="s">
				<check-type method="list" target="*">
					float4
				</check-type>
			</input>
			<input name="texelOff">
				<check-type method="list" target="*">
					int
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['sampler1DARRAY,float4,int'] = 'float4',
					}
					local types = node.samp.get_type() .. ',' .. node.s.get_type() .. ',' .. node.texelOff.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = tex1DARRAYcmplod( r${node.samp.get_source().uid()}, r${node.s.get_source().uid()}, r${node.texelOff.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="tex3D( samp, s, texelOff )">
		<description><![CDATA[
NAME

tex3D - performs a texture lookup in a given 3D sampler. May also use pre computed derivatives if those
are provided.


SYNOPSIS

float4 tex3D(sampler3D samp, float3 s)
float4 tex3D(sampler3D samp, float3 s, int texelOff)
float4 tex3D(sampler3D samp, float3 s, float3 dx, float3 dy)
float4 tex3D(sampler3D samp, float3 s, float3 dx, float3 dy, int texelOff)
int4 tex3D(isampler3D samp, float3 s)
int4 tex3D(isampler3D samp, float3 s, int texelOff)
int4 tex3D(isampler3D samp, float3 s, float3 dx, float3 dy)
int4 tex3D(isampler3D samp, float3 s, float3 dx, float3 dy, int texelOff)
uint4 tex3D(usampler3D samp, float3 s)
uint4 tex3D(usampler3D samp, float3 s, int texelOff)
uint4 tex3D(usampler3D samp, float3 s, float3 dx, float3 dy)
uint4 tex3D(usampler3D samp, float3 s, float3 dx, float3 dy,int texelOff)


PARAMETERS

samp Sampler to lookup.
s Coordinates to perform the lookup.
dx Pre computed derivative along the x axis.
dy Pre computed derivative along the y axis.
texelOff Offset to be added to obtain the final texel.


DESCRIPTION

Performs a texture lookup in sampler samp using coordinates s, may use and derivatives dx and dy, also
may use texel offset texelOff to compute final texel.


REFERENCE IMPLEMENTATION



PROFILE SUPPORT

tex3D is supported in all fragment profiles and all vertex profiles starting with vp40, variants with texel
offsets are only supported in gp4 and newer profiles. Variants with integer samplers are also only
suppported in gp4 and newer profiles.


SEE ALSO

tex3Dbias, tex3Dlod, tex3Dproj

		]]></description>
		<tool-tip><![CDATA[
			tex3D - performs a texture lookup in a given 3D sampler. May also use pre computed derivatives if those
are provided.

		]]></tool-tip>
		<ports>
			<input name="samp">
				<check-type method="list" target="*">
					sampler3D,usampler3D,isampler3D
				</check-type>
			</input>
			<input name="s">
				<check-type method="list" target="*">
					float3
				</check-type>
			</input>
			<input name="texelOff">
				<check-type method="list" target="*">
					int
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['sampler3D,float3,int'] = 'float4',
						['usampler3D,float3,int'] = 'uint4',
						['isampler3D,float3,int'] = 'int4',
					}
					local types = node.samp.get_type() .. ',' .. node.s.get_type() .. ',' .. node.texelOff.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = tex3D( r${node.samp.get_source().uid()}, r${node.s.get_source().uid()}, r${node.texelOff.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="tex3Dfetch( samp, s, texelOff )">
		<description><![CDATA[
NAME

tex3Dfetch - performs an unfiltered texture lookup in a given sampler.


SYNOPSIS

float4 tex3Dfetch(sampler3D samp, int4 s)
float4 tex3Dfetch(sampler3D samp, int4 s, int texelOff)
int4 tex3Dfetch(isampler3D samp, int4 s)
int4 tex3Dfetch(isampler3D samp, int4 s, int texelOff)
uint4 tex3Dfetch(usampler3D samp, int4 s)
uint4 tex3Dfetch(usampler3D samp, int4 s, int texelOff)


PARAMETERS

samp Sampler to lookup.
s Coordinates to perform the lookup. The level of detail is stored in the last component of the
coordinate vector.
texelOff Offset to be added to obtain the final texel.


DESCRIPTION

Performs an unfiltered texture lookup in sampler samp using coordinates s. The level of detail is provided
by the last component of the coordinate vector. May use texel offset texelOff to compute final texel.


REFERENCE IMPLEMENTATION



PROFILE SUPPORT

tex3Dfetch is only supported in gp4 and newer profiles.


SEE ALSO

tex3D.de Sh
\$1

		]]></description>
		<tool-tip><![CDATA[
			tex3Dfetch - performs an unfiltered texture lookup in a given sampler.

		]]></tool-tip>
		<ports>
			<input name="samp">
				<check-type method="list" target="*">
					sampler3D,usampler3D,isampler3D
				</check-type>
			</input>
			<input name="s">
				<check-type method="list" target="*">
					int4
				</check-type>
			</input>
			<input name="texelOff">
				<check-type method="list" target="*">
					int
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['usampler3D,int4,int'] = 'uint4',
						['isampler3D,int4,int'] = 'int4',
						['sampler3D,int4,int'] = 'float4',
					}
					local types = node.samp.get_type() .. ',' .. node.s.get_type() .. ',' .. node.texelOff.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = tex3Dfetch( r${node.samp.get_source().uid()}, r${node.s.get_source().uid()}, r${node.texelOff.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="clamp( x, a, b )">
		<description><![CDATA[
NAME

clamp - returns smallest integer not less than a scalar or each vector component.


SYNOPSIS

float clamp(float x, float a, float b);
float1 clamp(float1 x, float1 a, float1 b);
float2 clamp(float2 x, float2 a, float2 b);
float3 clamp(float3 x, float3 a, float3 b);
float4 clamp(float4 x, float4 a, float4 b);
half clamp(half x, half a, half b);
half1 clamp(half1 x, half1 a, half1 b);
half2 clamp(half2 x, half2 a, half2 b);
half3 clamp(half3 x, half3 a, half3 b);
half4 clamp(half4 x, half4 a, half4 b);
fixed clamp(fixed x, fixed a, fixed b);
fixed1 clamp(fixed1 x, fixed1 a, fixed1 b);
fixed2 clamp(fixed2 x, fixed2 a, fixed2 b);
fixed3 clamp(fixed3 x, fixed3 a, fixed3 b);
fixed4 clamp(fixed4 x, fixed4 a, fixed4 b);


PARAMETERS

x Vector or scalar to clamp.
a Vector or scalar for bottom of clamp range.
b Vector or scalar for top of clamp range.


DESCRIPTION

Returns x clamped to the range [a,b] as follows:
1) Returns a if x is less than a; else
2) Returns b if x is greater than b; else
3) Returns x otherwise.
For vectors, the returned vector contains the clamped result of each element of the vector x clamped using
the respective element of vectors a and b.


REFERENCE IMPLEMENTATION

clamp for float scalars could be implemented like this.
float clamp(float x, float a, float b)
{
return max(a, min(b, x));
}


PROFILE SUPPORT

clamp is supported in all profiles except fp20.


SEE ALSO

max, min, saturate

		]]></description>
		<tool-tip><![CDATA[
			clamp - returns smallest integer not less than a scalar or each vector component.

		]]></tool-tip>
		<ports>
			<input name="x">
				<check-type method="list" target="*">
					half4,float4,half,half3,half1,fixed1,fixed4,float1,fixed3,fixed2,float3,float,fixed,half2,float2
				</check-type>
			</input>
			<input name="a">
				<check-type method="list" target="*">
					half4,float4,half,half3,half1,fixed1,fixed4,float1,fixed3,fixed2,float3,float,fixed,half2,float2
				</check-type>
			</input>
			<input name="b">
				<check-type method="list" target="*">
					half4,float4,half,half3,half1,fixed1,fixed4,float1,fixed3,fixed2,float3,float,fixed,half2,float2
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['half3,half3,half3'] = 'half3',
						['fixed2,fixed2,fixed2'] = 'fixed2',
						['fixed4,fixed4,fixed4'] = 'fixed4',
						['half,half,half'] = 'half',
						['fixed3,fixed3,fixed3'] = 'fixed3',
						['float,float,float'] = 'float',
						['half2,half2,half2'] = 'half2',
						['fixed,fixed,fixed'] = 'fixed',
						['fixed1,fixed1,fixed1'] = 'fixed1',
						['float3,float3,float3'] = 'float3',
						['half1,half1,half1'] = 'half1',
						['half4,half4,half4'] = 'half4',
						['float4,float4,float4'] = 'float4',
						['float1,float1,float1'] = 'float1',
						['float2,float2,float2'] = 'float2',
					}
					local types = node.x.get_type() .. ',' .. node.a.get_type() .. ',' .. node.b.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = clamp( r${node.x.get_source().uid()}, r${node.a.get_source().uid()}, r${node.b.get_source().uid()} );
			]]></code>
		</code-generation>
	</node>
	
	<node type="clip( x )">
		<description><![CDATA[
NAME

clip - Kills the fragment if x is smaller than zero.
		]]></description>
		<tool-tip>clip - Kills the fragment if x is smaller than zero.</tool-tip>
		<ports>
			<input name="x">
				<check-type method="list" target="*">
					float,half
				</check-type>
			</input>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*">
				clip( r${node.x.get_source().uid()} - 0.005 );
			</code>
		</code-generation>
	</node>
	
	<node type="cos( a )">
		<description><![CDATA[
NAME

cos - returns cosine of scalars and vectors.


SYNOPSIS

float cos(float a);
float1 cos(float1 a);
float2 cos(float2 a);
float3 cos(float3 a);
float4 cos(float4 a);
half cos(half a);
half1 cos(half1 a);
half2 cos(half2 a);
half3 cos(half3 a);
half4 cos(half4 a);
fixed cos(fixed a);
fixed1 cos(fixed1 a);
fixed2 cos(fixed2 a);
fixed3 cos(fixed3 a);
fixed4 cos(fixed4 a);


PARAMETERS

a Vector or scalar of which to determine the cosine.


DESCRIPTION

Returns the cosine of a in radians. The return value is in the range [-1,+1].
For vectors, the returned vector contains the cosine of each element of the input vector.


REFERENCE IMPLEMENTATION

cos is best implemented as a native cosine instruction, however cos for a float scalar could be implemented
by an approximation like this.
cos(float a)
{
/* C simulation gives a max absolute error of less than 1.8e-7 */
const float4 c0 = float4( 0.0, 0.5,
1.0, 0.0 );
const float4 c1 = float4( 0.25, -9.0,
0.75, 0.159154943091 );
const float4 c2 = float4( 24.9808039603, -24.9808039603,
-60.1458091736, 60.1458091736 );
const float4 c3 = float4( 85.4537887573, -85.4537887573,
-64.9393539429, 64.9393539429 );
const float4 c4 = float4( 19.7392082214, -19.7392082214,
-1.0, 1.0 );
/* r0.x = cos(a) */
float3 r0, r1, r2;
r1.x = c1.w * a; // normalize input
r1.y = frac( r1.x ); // and extract fraction
r2.x = (float) ( r1.y < c1.x ); // range check: 0.0 to 0.25
r2.yz = (float2) ( r1.yy >= c1.yz ); // range check: 0.75 to 1.0
r2.y = dot( r2, c4.zwz ); // range check: 0.25 to 0.75
r0 = c0.xyz - r1.yyy; // range centering
r0 = r0 * r0;
r1 = c2.xyx * r0 + c2.zwz; // start power series
r1 = r1 * r0 + c3.xyx;
r1 = r1 * r0 + c3.zwz;
r1 = r1 * r0 + c4.xyx;
r1 = r1 * r0 + c4.zwz;
r0.x = dot( r1, -r2 ); // range extract
return r0.x;


PROFILE SUPPORT

cos is fully supported in all profiles unless otherwise specified.
cos is supported via an approximation (shown above) in the vs_1, vp20, and arbvp1 profiles.
cos is unsupported in the fp20, ps_1_1, ps_1_2, and ps_1_3 profiles.


SEE ALSO

acos, dot, frac, sin, tan

		]]></description>
		<tool-tip><![CDATA[
			cos - returns cosine of scalars and vectors.

		]]></tool-tip>
		<ports>
			<input name="a">
				<check-type method="list" target="*">
					half4,float4,half,half3,half1,fixed1,fixed4,float1,fixed3,fixed2,float3,float,fixed,half2,float2
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['float4'] = 'float4',
						['half2'] = 'half2',
						['half1'] = 'half1',
						['float'] = 'float',
						['float1'] = 'float1',
						['fixed2'] = 'fixed2',
						['fixed4'] = 'fixed4',
						['fixed3'] = 'fixed3',
						['float3'] = 'float3',
						['float2'] = 'float2',
						['fixed1'] = 'fixed1',
						['fixed'] = 'fixed',
						['half3'] = 'half3',
						['half4'] = 'half4',
						['half'] = 'half',
					}
					local types = node.a.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = cos( r${node.a.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="tex1DARRAYcmpbias( samp, s )">
		<description><![CDATA[
NAME

tex1DARRAYcmpbias - performs a texture lookup with shadow compare and bias in a given sampler
array.


SYNOPSIS

float4 tex1DARRAYcmpbias(sampler1DARRAY samp, float4 s)
float4 tex1DARRAYcmpbias(sampler1DARRAY samp, float4 s, int texelOff)


PARAMETERS

samp Sampler array to lookup.
s Coordinates to perform the lookup. The value used to select the layer is the second coordinate,
the third is the value used in the shadow comparison, the fourth corresponds to the bias value.
texelOff Offset to be added to obtain the final texel.


DESCRIPTION

Performs a texture lookup with bias in sampler samp using coordinates s, the texture to be sampled is
selected from the layer specified in the coordinates, the lookup involves a shadow comparison and may use
texel offset texelOff to compute the final texel.


REFERENCE IMPLEMENTATION



PROFILE SUPPORT

tex1DARRAYcmpbias is only supported in gp4 and newer profiles.


SEE ALSO

tex1DARRAYbias, tex1DARRAYlod, tex1DARRAYcmplod

		]]></description>
		<tool-tip><![CDATA[
			tex1DARRAYcmpbias - performs a texture lookup with shadow compare and bias in a given sampler
array.

		]]></tool-tip>
		<ports>
			<input name="samp">
				<check-type method="list" target="*">
					sampler1DARRAY
				</check-type>
			</input>
			<input name="s">
				<check-type method="list" target="*">
					float4
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['sampler1DARRAY,float4'] = 'float4',
					}
					local types = node.samp.get_type() .. ',' .. node.s.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = tex1DARRAYcmpbias( r${node.samp.get_source().uid()}, r${node.s.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="tex2D( samp, s )">
		<description><![CDATA[
NAME

tex2D - performs a texture lookup in a given 2D sampler and, in some cases, a shadow comparison. May
also use pre computed derivatives if those are provided.


SYNOPSIS

float4 tex2D(sampler2D samp, float2 s)
float4 tex2D(sampler2D samp, float2 s, int texelOff)
float4 tex2D(sampler2D samp, float3 s)
float4 tex2D(sampler2D samp, float3 s, int texelOff)
float4 tex2D(sampler2D samp, float2 s, float2 dx, float2 dy)
float4 tex2D(sampler2D samp, float2 s, float2 dx, float2 dy, int texelOff)
float4 tex2D(sampler2D samp, float3 s, float2 dx, float2 dy)
float4 tex2D(sampler2D samp, float3 s, float2 dx, float2 dy, int texelOff)
int4 tex2D(isampler2D samp, float2 s)
int4 tex2D(isampler2D samp, float2 s, int texelOff)
int4 tex2D(isampler2D samp, float2 s, float2 dx, float2 dy)
int4 tex2D(isampler2D samp, float2 s, float2 dx, float2 dy, int texelOff)
uint4 tex2D(usampler2D samp, float2 s)
uint4 tex2D(usampler2D samp, float2 s, int texelOff)
uint4 tex2D(usampler2D samp, float2 s, float2 dx, float2 dy)
uint4 tex2D(usampler2D samp, float2 s, float2 dx, float2 dy,int texelOff)


PARAMETERS

samp Sampler to lookup.
s Coordinates to perform the lookup. If an extra coordinate compared to the texture dimensionality
is present it is used to perform a shadow comparison. The value used in the shadow comparison is
always the last component of the coordinate vector.
dx Pre computed derivative along the x axis.
dy Pre computed derivative along the y axis.
texelOff Offset to be added to obtain the final texel.


DESCRIPTION

Performs a texture lookup in sampler samp using coordinates s, may use and derivatives dx and dy, also
may perform shadow comparison and use texel offset texelOff to compute final texel.


REFERENCE IMPLEMENTATION



PROFILE SUPPORT

tex2D is supported in all fragment profiles and all vertex profiles starting with vp40, variants with shadow
comparison are only supported in fp40 and newer profiles, variants with texel offsets are only supported in
gp4 and newer profiles. Variants with integer textures are also only supported in gp4 and newer profiles.


SEE ALSO

tex2Dbias, tex2Dlod, tex2Dproj

		]]></description>
		<tool-tip><![CDATA[
			tex2D - performs a texture lookup in a given 2D sampler and, in some cases, a shadow comparison. May
also use pre computed derivatives if those are provided.

		]]></tool-tip>
		<ports>
			<input name="samp">
				<check-type method="list" target="*">
					sampler2D,isampler2D,usampler2D
				</check-type>
			</input>
			<input name="s">
				<check-type method="list" target="*">
					float3,float2
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['sampler2D,float3'] = 'float4',
						['usampler2D,float2'] = 'uint4',
						['isampler2D,float2'] = 'int4',
						['sampler2D,float2'] = 'float4',
					}
					local types = node.samp.get_type() .. ',' .. node.s.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = tex2D( r${node.samp.get_source().uid()}, r${node.s.get_source().uid()} );
			]]></code>
		</code-generation>
	</node>
	<node type="tex2Dfetch( samp, s, texelOff )">
		<description><![CDATA[
NAME

tex2Dfetch - performs an unfiltered texture lookup in a given sampler.


SYNOPSIS

float4 tex2Dfetch(sampler2D samp, int4 s)
float4 tex2Dfetch(sampler2D samp, int4 s, int texelOff)
int4 tex2Dfetch(isampler2D samp, int4 s)
int4 tex2Dfetch(isampler2D samp, int4 s, int texelOff)
uint4 tex2Dfetch(usampler2D samp, int4 s)
uint4 tex2Dfetch(usampler2D samp, int4 s, int texelOff)


PARAMETERS

samp Sampler to lookup.
s Coordinates to perform the lookup. The level of detail is stored in the last component of the
coordinate vector.
texelOff Offset to be added to obtain the final texel.


DESCRIPTION

Performs an unfiltered texture lookup in sampler samp using coordinates s. The level of detail is provided
by the last component of the coordinate vector. May use texel offset texelOff to compute final texel.


REFERENCE IMPLEMENTATION



PROFILE SUPPORT

tex2Dfetch is only supported in gp4 and newer profiles.


SEE ALSO

tex2D, tex2DARRAYfetch.de Sh
\$1

		]]></description>
		<tool-tip><![CDATA[
			tex2Dfetch - performs an unfiltered texture lookup in a given sampler.

		]]></tool-tip>
		<ports>
			<input name="samp">
				<check-type method="list" target="*">
					sampler2D,isampler2D,usampler2D
				</check-type>
			</input>
			<input name="s">
				<check-type method="list" target="*">
					int4
				</check-type>
			</input>
			<input name="texelOff">
				<check-type method="list" target="*">
					int
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['usampler2D,int4,int'] = 'uint4',
						['isampler2D,int4,int'] = 'int4',
						['sampler2D,int4,int'] = 'float4',
					}
					local types = node.samp.get_type() .. ',' .. node.s.get_type() .. ',' .. node.texelOff.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = tex2Dfetch( r${node.samp.get_source().uid()}, r${node.s.get_source().uid()}, r${node.texelOff.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="tex3Dbias( samp, s, texelOff )">
		<description><![CDATA[
NAME

tex3Dbias - performs a texture lookup with bias in a given sampler.


SYNOPSIS

float4 tex3Dbias(sampler3D samp, float4 s)
float4 tex3Dbias(sampler3D samp, float4 s, int texelOff)
int4 tex3Dbias(isampler3D samp, float4 s)
int4 tex3Dbias(isampler3D samp, float4 s, int texelOff)
uint4 tex3Dbias(usampler3D samp, float4 s)
uint4 tex3Dbias(usampler3D samp, float4 s, int texelOff)


PARAMETERS

samp Sampler to lookup.
s Coordinates to perform the lookup. The bias value should be passed as the last component of the
coordinate vector.
texelOff Offset to be added to obtain the final texel.


DESCRIPTION

Performs a texture lookup with bias in sampler samp using coordinates s.


REFERENCE IMPLEMENTATION



PROFILE SUPPORT

tex3Dbias is supported in fragment profiles starting with fp30 and in vertex profiles starting with vp40.
Variants with texelOff are only supported in gp4 and newer profiles. Variants with integer samplers are also
only suppported in gp4 and newer profiles.


SEE ALSO

tex3Dlod.de Sh
\$1

		]]></description>
		<tool-tip><![CDATA[
			tex3Dbias - performs a texture lookup with bias in a given sampler.

		]]></tool-tip>
		<ports>
			<input name="samp">
				<check-type method="list" target="*">
					sampler3D,usampler3D,isampler3D
				</check-type>
			</input>
			<input name="s">
				<check-type method="list" target="*">
					float4
				</check-type>
			</input>
			<input name="texelOff">
				<check-type method="list" target="*">
					int
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['usampler3D,float4,int'] = 'uint4',
						['sampler3D,float4,int'] = 'float4',
						['isampler3D,float4,int'] = 'int4',
					}
					local types = node.samp.get_type() .. ',' .. node.s.get_type() .. ',' .. node.texelOff.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = tex3Dbias( r${node.samp.get_source().uid()}, r${node.s.get_source().uid()}, r${node.texelOff.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="lerp( a, b, w )">
		<description><![CDATA[
NAME

lerp - returns linear interpolation of two scalars or vectors based on a weight


SYNOPSIS

float lerp(float a, float b, float w);
float1 lerp(float1 a, float1 b, float1 w);
float2 lerp(float2 a, float2 b, float2 w);
float3 lerp(float3 a, float3 b, float3 w);
float4 lerp(float4 a, float4 b, float4 w);
float1 lerp(float1 a, float1 b, float w);
float2 lerp(float2 a, float2 b, float w);
float3 lerp(float3 a, float3 b, float w);
float4 lerp(float4 a, float4 b, float w);
half lerp(half a, half b, half w);
half1 lerp(half1 a, half1 b, half1 w);
half2 lerp(half2 a, half2 b, half2 w);
half3 lerp(half3 a, half3 b, half3 w);
half4 lerp(half4 a, half4 b, half4 w);
half1 lerp(half1 a, half1 b, half w);
half2 lerp(half2 a, half2 b, half w);
half3 lerp(half3 a, half3 b, half w);
half4 lerp(half4 a, half4 b, half w);
fixed lerp(fixed a, fixed b, fixed w);
fixed1 lerp(fixed1 a, fixed1 b, fixed1 w);
fixed2 lerp(fixed2 a, fixed2 b, fixed2 w);
fixed3 lerp(fixed3 a, fixed3 b, fixed3 w);
fixed4 lerp(fixed4 a, fixed4 b, fixed4 w);
fixed1 lerp(fixed1 a, fixed1 b, fixed w);
fixed2 lerp(fixed2 a, fixed2 b, fixed w);
fixed3 lerp(fixed3 a, fixed3 b, fixed w);
fixed4 lerp(fixed4 a, fixed4 b, fixed w);


PARAMETERS

a Vector or scalar to weight; returned with w is one.
b Vector or scalar to weight; returned with w is zero.
w Vector or scalar weight.


DESCRIPTION

Returns the linear interpolation of a and b based on weight w.
a and b are either both scalars or both vectors of the same length. The weight w may be a scalar or a vector
of the same length as a and b. w can be any value (so is not restricted to be between zero and one); if w has
values outside the [0,1] range, it actually extrapolates.
lerp returns a when w is one and returns b when w is zero.


REFERENCE IMPLEMENTATION

lerp for float3 vectors for a and b and a float w could be implemented like this:
float3 lerp(float3 a, float3 b, float w)
{
return a + w*(b-a);
}


PROFILE SUPPORT

lerp is supported in all profiles.


SEE ALSO

saturate, smoothstep, step

		]]></description>
		<tool-tip><![CDATA[
			lerp - returns linear interpolation of two scalars or vectors based on a weight

		]]></tool-tip>
		<ports>
			<input name="a">
				<check-type method="list" target="*">
					half4,float4,half,half3,half1,fixed1,fixed4,float1,fixed3,fixed2,float3,float,fixed,half2,float2
				</check-type>
			</input>
			<input name="b">
				<check-type method="list" target="*">
					half4,float4,half,half3,half1,fixed1,fixed4,float1,fixed3,fixed2,float3,float,fixed,half2,float2
				</check-type>
			</input>
			<input name="w">
				<check-type method="list" target="*">
					half4,float4,half,half3,half1,fixed1,fixed4,float1,fixed3,fixed2,float3,float,fixed,half2,float2
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['float2,float2,float'] = 'float2',
						['half1,half1,half'] = 'half1',
						['half,half,half'] = 'half',
						['fixed4,fixed4,fixed4'] = 'fixed4',
						['half2,half2,half'] = 'half2',
						['float3,float3,float'] = 'float3',
						['fixed2,fixed2,fixed'] = 'fixed2',
						['float4,float4,float'] = 'float4',
						['fixed3,fixed3,fixed'] = 'fixed3',
						['float1,float1,float1'] = 'float1',
						['fixed1,fixed1,fixed'] = 'fixed1',
						['fixed3,fixed3,fixed3'] = 'fixed3',
						['half3,half3,half3'] = 'half3',
						['fixed2,fixed2,fixed2'] = 'fixed2',
						['half3,half3,half'] = 'half3',
						['fixed1,fixed1,fixed1'] = 'fixed1',
						['fixed,fixed,fixed'] = 'fixed',
						['float,float,float'] = 'float',
						['half2,half2,half2'] = 'half2',
						['fixed4,fixed4,fixed'] = 'fixed4',
						['float1,float1,float'] = 'float1',
						['half4,half4,half'] = 'half4',
						['half1,half1,half1'] = 'half1',
						['half4,half4,half4'] = 'half4',
						['float4,float4,float4'] = 'float4',
						['float3,float3,float3'] = 'float3',
						['float2,float2,float2'] = 'float2',
					}
					local types = node.a.get_type() .. ',' .. node.b.get_type() .. ',' .. node.w.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = lerp( r${node.a.get_source().uid()}, r${node.b.get_source().uid()}, r${node.w.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="tex1Dbias( samp, s, texelOff )">
		<description><![CDATA[
NAME

tex1Dbias - performs a texture lookup with bias in a given sampler.


SYNOPSIS

float4 tex1Dbias(sampler1D samp, float4 s)
float4 tex1Dbias(sampler1D samp, float4 s, int texelOff)
int4 tex1Dbias(isampler1D samp, float4 s)
int4 tex1Dbias(isampler1D samp, float4 s, int texelOff)
uint4 tex1Dbias(usampler1D samp, float4 s)
uint4 tex1Dbias(usampler1D samp, float4 s, int texelOff)


PARAMETERS

samp Sampler to lookup.
s Coordinates to perform the lookup. The bias value should be passed as the last component of the
coordinate vector.
texelOff Offset to be added to obtain the final texel.


DESCRIPTION

Performs a texture lookup with bias in sampler samp using coordinates s.


REFERENCE IMPLEMENTATION



PROFILE SUPPORT

tex1Dbias is supported in fragment profiles starting with fp30 and in vertex profiles starting with vp40.
Variants with texelOff are only supported in gp4 and newer profiles. Variants with integer samplers are also
only suppported in gp4 and newer profiles.


SEE ALSO

tex1Dlod, tex1Dcmpbias.de Sh
\$1

		]]></description>
		<tool-tip><![CDATA[
			tex1Dbias - performs a texture lookup with bias in a given sampler.

		]]></tool-tip>
		<ports>
			<input name="samp">
				<check-type method="list" target="*">
					usampler1D,isampler1D,sampler1D
				</check-type>
			</input>
			<input name="s">
				<check-type method="list" target="*">
					float4
				</check-type>
			</input>
			<input name="texelOff">
				<check-type method="list" target="*">
					int
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['sampler1D,float4,int'] = 'float4',
						['isampler1D,float4,int'] = 'int4',
						['usampler1D,float4,int'] = 'uint4',
					}
					local types = node.samp.get_type() .. ',' .. node.s.get_type() .. ',' .. node.texelOff.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = tex1Dbias( r${node.samp.get_source().uid()}, r${node.s.get_source().uid()}, r${node.texelOff.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="tan( a )">
		<description><![CDATA[
NAME

tan - returns tangent of scalars and vectors.


SYNOPSIS

float tan(float a);
float1 tan(float1 a);
float2 tan(float2 a);
float3 tan(float3 a);
float4 tan(float4 a);
half tan(half a);
half1 tan(half1 a);
half2 tan(half2 a);
half3 tan(half3 a);
half4 tan(half4 a);
fixed tan(fixed a);
fixed1 tan(fixed1 a);
fixed2 tan(fixed2 a);
fixed3 tan(fixed3 a);
fixed4 tan(fixed4 a);


PARAMETERS

a Vector or scalar of which to determine the tangent.


DESCRIPTION

Returns the tangent of a in radians.
For vectors, the returned vector contains the tangent of each element of the input vector.


REFERENCE IMPLEMENTATION

tan can be implemented in terms of the sin and cos functions like this:
float tan(float a) {
float s, c;
sincos(a, s, c);
return s / c;
}


PROFILE SUPPORT

tan is fully supported in all profiles unless otherwise specified.
tan is supported via approximations of sin and cos functions (see the respective sin and cos manual pages
for details) in the vs_1, vp20, and arbvp1 profiles.
tan is unsupported in the fp20, ps_1_1, ps_1_2, and ps_1_3 profiles.


SEE ALSO

atan, atan2, cos, dot, frac, sin, sincos

		]]></description>
		<tool-tip><![CDATA[
			tan - returns tangent of scalars and vectors.

		]]></tool-tip>
		<ports>
			<input name="a">
				<check-type method="list" target="*">
					half4,float4,half,half3,half1,fixed1,fixed4,float1,fixed3,fixed2,float3,float,fixed,half2,float2
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['float4'] = 'float4',
						['half2'] = 'half2',
						['half1'] = 'half1',
						['float'] = 'float',
						['float1'] = 'float1',
						['fixed2'] = 'fixed2',
						['fixed4'] = 'fixed4',
						['fixed3'] = 'fixed3',
						['float3'] = 'float3',
						['float2'] = 'float2',
						['fixed1'] = 'fixed1',
						['fixed'] = 'fixed',
						['half3'] = 'half3',
						['half4'] = 'half4',
						['half'] = 'half',
					}
					local types = node.a.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = tan( r${node.a.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="tex1Dbias( samp, s )">
		<description><![CDATA[
NAME

tex1Dbias - performs a texture lookup with bias in a given sampler.


SYNOPSIS

float4 tex1Dbias(sampler1D samp, float4 s)
float4 tex1Dbias(sampler1D samp, float4 s, int texelOff)
int4 tex1Dbias(isampler1D samp, float4 s)
int4 tex1Dbias(isampler1D samp, float4 s, int texelOff)
uint4 tex1Dbias(usampler1D samp, float4 s)
uint4 tex1Dbias(usampler1D samp, float4 s, int texelOff)


PARAMETERS

samp Sampler to lookup.
s Coordinates to perform the lookup. The bias value should be passed as the last component of the
coordinate vector.
texelOff Offset to be added to obtain the final texel.


DESCRIPTION

Performs a texture lookup with bias in sampler samp using coordinates s.


REFERENCE IMPLEMENTATION



PROFILE SUPPORT

tex1Dbias is supported in fragment profiles starting with fp30 and in vertex profiles starting with vp40.
Variants with texelOff are only supported in gp4 and newer profiles. Variants with integer samplers are also
only suppported in gp4 and newer profiles.


SEE ALSO

tex1Dlod, tex1Dcmpbias.de Sh
\$1

		]]></description>
		<tool-tip><![CDATA[
			tex1Dbias - performs a texture lookup with bias in a given sampler.

		]]></tool-tip>
		<ports>
			<input name="samp">
				<check-type method="list" target="*">
					usampler1D,isampler1D,sampler1D
				</check-type>
			</input>
			<input name="s">
				<check-type method="list" target="*">
					float4
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['usampler1D,float4'] = 'uint4',
						['isampler1D,float4'] = 'int4',
						['sampler1D,float4'] = 'float4',
					}
					local types = node.samp.get_type() .. ',' .. node.s.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = tex1Dbias( r${node.samp.get_source().uid()}, r${node.s.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="transpose( A )">
		<description><![CDATA[
NAME

transpose - returns transpose matrix of a matrix


SYNOPSIS

float4x4 transpose(float4x4 A)
float3x4 transpose(float4x3 A)
float2x4 transpose(float4x2 A)
float1x4 transpose(float4x1 A)
float4x3 transpose(float3x4 A)
float3x3 transpose(float3x3 A)
float2x3 transpose(float3x2 A)
float1x3 transpose(float3x1 A)
float4x2 transpose(float2x4 A)
float3x2 transpose(float2x3 A)
float2x2 transpose(float2x2 A)
float1x2 transpose(float2x1 A)
float4x1 transpose(float1x4 A)
float3x1 transpose(float1x3 A)
float2x1 transpose(float1x2 A)
float1x1 transpose(float1x1 A)


PARAMETERS

A Matrix to tranpose.


DESCRIPTION

Returns the transpose of the matrix A.


REFERENCE IMPLEMENTATION

transpose for a float4x3 matrix can be implemented like this:
float4x3 transpose(float3x4 A)
{
float4x3 C;
C[0] = A._m00_m10_m20;
C[1] = A._m01_m11_m21;
C[2] = A._m02_m12_m22;
C[3] = A._m03_m13_m23;
return C;
}


PROFILE SUPPORT

transpose is supported in all profiles.


SEE ALSO

determinant, mul

		]]></description>
		<tool-tip><![CDATA[
			transpose - returns transpose matrix of a matrix

		]]></tool-tip>
		<ports>
			<input name="A">
				<check-type method="list" target="*">
					float1x1,float1x2,float3x4,float1x4,float4x4,float2x3,float2x1,float2x2,float2x4,float3x2,float3x1,float3x3,float4x3,float4x1,float1x3,float4x2
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['float1x1'] = 'float1x1',
						['float4x2'] = 'float2x4',
						['float2x1'] = 'float1x2',
						['float2x3'] = 'float3x2',
						['float2x4'] = 'float4x2',
						['float4x1'] = 'float1x4',
						['float4x4'] = 'float4x4',
						['float1x2'] = 'float2x1',
						['float1x3'] = 'float3x1',
						['float4x3'] = 'float3x4',
						['float1x4'] = 'float4x1',
						['float3x4'] = 'float4x3',
						['float2x2'] = 'float2x2',
						['float3x3'] = 'float3x3',
						['float3x2'] = 'float2x3',
						['float3x1'] = 'float1x3',
					}
					local types = node.A.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = transpose( r${node.A.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="frac( a )">
		<description><![CDATA[
NAME

frac - returns the fractional portion of a scalar or each vector component.


SYNOPSIS

float frac(float a);
float1 frac(float1 a);
float2 frac(float2 a);
float3 frac(float3 a);
float4 frac(float4 a);
half frac(half a);
half1 frac(half1 a);
half2 frac(half2 a);
half3 frac(half3 a);
half4 frac(half4 a);
fixed frac(fixed a);
fixed1 frac(fixed1 a);
fixed2 frac(fixed2 a);
fixed3 frac(fixed3 a);
fixed4 frac(fixed4 a);


PARAMETERS

a Vector or scalar of which to return its fractional portion.


DESCRIPTION

Returns the fractional portion of a scalar or each vector component.


REFERENCE IMPLEMENTATION

frac for a float scalar could be implemented like this.
float frac(float v)
{
return v - floor(v);
}


PROFILE SUPPORT

frac is supported in all profiles except fp20.


SEE ALSO

ceil, floor, round, trunc

		]]></description>
		<tool-tip><![CDATA[
			frac - returns the fractional portion of a scalar or each vector component.

		]]></tool-tip>
		<ports>
			<input name="a">
				<check-type method="list" target="*">
					half4,float4,half,half3,half1,fixed1,fixed4,float1,fixed3,fixed2,float3,float,fixed,half2,float2
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['float4'] = 'float4',
						['half2'] = 'half2',
						['half1'] = 'half1',
						['float'] = 'float',
						['float1'] = 'float1',
						['fixed2'] = 'fixed2',
						['fixed4'] = 'fixed4',
						['fixed3'] = 'fixed3',
						['float3'] = 'float3',
						['float2'] = 'float2',
						['fixed1'] = 'fixed1',
						['fixed'] = 'fixed',
						['half3'] = 'half3',
						['half4'] = 'half4',
						['half'] = 'half',
					}
					local types = node.a.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = frac( r${node.a.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="tex2Dcmplod( samp, s )">
		<description><![CDATA[
NAME

tex2Dcmplod - performs a texture lookup with a specified level of detail and a shadow compare in a given
sampler.


SYNOPSIS

float4 tex2Dcmplod(sampler2D samp, float4 s)
float4 tex2Dcmplod(sampler2D samp, float4 s, int texelOff)


PARAMETERS

samp Sampler to lookup.
s Coordinates to perform the lookup. The value used in the shadow comparison should be passed
right after the normal coordinates. The level of detail corresponds to the last component of the
coordinate vector.
texelOff Offset to be added to obtain the final texel.


DESCRIPTION

Performs a texture lookup with shadow compare and a specified level of detail in sampler samp using
coordinates s.


REFERENCE IMPLEMENTATION



PROFILE SUPPORT

tex2Dcmplod is supported in fragment profiles starting with fp40 and in vertex profiles starting with vp40.
Variants with texelOff are only supported in gp4 and newer profiles.


SEE ALSO

tex2Dlod, tex2Dcmpbias

		]]></description>
		<tool-tip><![CDATA[
			tex2Dcmplod - performs a texture lookup with a specified level of detail and a shadow compare in a given
sampler.

		]]></tool-tip>
		<ports>
			<input name="samp">
				<check-type method="list" target="*">
					sampler2D
				</check-type>
			</input>
			<input name="s">
				<check-type method="list" target="*">
					float4
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['sampler2D,float4'] = 'float4',
					}
					local types = node.samp.get_type() .. ',' .. node.s.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = tex2Dcmplod( r${node.samp.get_source().uid()}, r${node.s.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="tex1Dlod( samp, s )">
		<description><![CDATA[
NAME

tex1Dlod - performs a texture lookup with a specified level of detail in a given sampler.


SYNOPSIS

float4 tex1Dlod(sampler1D samp, float4 s)
float4 tex1Dlod(sampler1D samp, float4 s, int texelOff)
int4 tex1Dlod(isampler1D samp, float4 s)
int4 tex1Dlod(isampler1D samp, float4 s, int texelOff)
uint4 tex1Dlod(usampler1D samp, float4 s)
uint4 tex1Dlod(usampler1D samp, float4 s, int texelOff)


PARAMETERS

samp Sampler to lookup.
s Coordinates to perform the lookup. The level of detail should be passed as the last component of
the coordinate vector.
texelOff Offset to be added to obtain the final texel.


DESCRIPTION

Performs a texture lookup with a specified level of detail in sampler samp using coordinates s.


REFERENCE IMPLEMENTATION



PROFILE SUPPORT

tex1Dlod is supported in fragment profiles starting with fp40 and in vertex profiles starting with vp40.
Variants with texelOff are only supported in gp4 and newer profiles. Variants with integer samplers are also
only suppported in gp4 and newer profiles.


SEE ALSO

tex1Dbias, tex1Dcmplod.de Sh
\$1

		]]></description>
		<tool-tip><![CDATA[
			tex1Dlod - performs a texture lookup with a specified level of detail in a given sampler.

		]]></tool-tip>
		<ports>
			<input name="samp">
				<check-type method="list" target="*">
					usampler1D,isampler1D,sampler1D
				</check-type>
			</input>
			<input name="s">
				<check-type method="list" target="*">
					float4
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['usampler1D,float4'] = 'uint4',
						['isampler1D,float4'] = 'int4',
						['sampler1D,float4'] = 'float4',
					}
					local types = node.samp.get_type() .. ',' .. node.s.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = tex1Dlod( r${node.samp.get_source().uid()}, r${node.s.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="tex1DARRAYcmplod( samp, s )">
		<description><![CDATA[
NAME

tex1DARRAYcmplod - performs a texture lookup with shadow compare and a level of detail in a given
sampler array.


SYNOPSIS

float4 tex1DARRAYcmplod(sampler1DARRAY samp, float4 s)
float4 tex1DARRAYcmplod(sampler1DARRAY samp, float4 s, int texelOff)


PARAMETERS

samp Sampler array to look up.
s Coordinates to perform the lookup. The value used to select the layer is the second coordinate,
the third is the value used in the shadow comparison, the fourth corresponds to the level of detail.
texelOff Offset to be added to obtain the final texel.


DESCRIPTION

Performs a texture lookup with level of detail in sampler samp using coordinates s, the texture to be
sampled is selected from the layer specified in the coordinates, the lookup involves a shadow comparison
and may use texel offset texelOff to compute the final texel.


REFERENCE IMPLEMENTATION



PROFILE SUPPORT

tex1DARRAYcmplod is only supported in gp4 and newer profiles.


SEE ALSO

tex1DARRAYlod, tex1DARRAYbias, tex1DARRAYcmpbias.de Sh
\$1

		]]></description>
		<tool-tip><![CDATA[
			tex1DARRAYcmplod - performs a texture lookup with shadow compare and a level of detail in a given
sampler array.

		]]></tool-tip>
		<ports>
			<input name="samp">
				<check-type method="list" target="*">
					sampler1DARRAY
				</check-type>
			</input>
			<input name="s">
				<check-type method="list" target="*">
					float4
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['sampler1DARRAY,float4'] = 'float4',
					}
					local types = node.samp.get_type() .. ',' .. node.s.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = tex1DARRAYcmplod( r${node.samp.get_source().uid()}, r${node.s.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="atan( a )">
		<description><![CDATA[
NAME

atan - returns arctangent of scalars and vectors.


SYNOPSIS

float atan(float a);
float1 atan(float1 a);
float2 atan(float2 a);
float3 atan(float3 a);
float4 atan(float4 a);
half atan(half a);
half1 atan(half1 a);
half2 atan(half2 a);
half3 atan(half3 a);
half4 atan(half4 a);
fixed atan(fixed a);
fixed1 atan(fixed1 a);
fixed2 atan(fixed2 a);
fixed3 atan(fixed3 a);
fixed4 atan(fixed4 a);


PARAMETERS

a Vector or scalar of which to determine the arctangent.


DESCRIPTION

Returns the arctangent of x in the range of -pi/2 to pi/2 radians.
For vectors, the returned vector contains the arctangent of each element of the input vector.


REFERENCE IMPLEMENTATION

atan for a float scalar could be implemented like this.
float atan(float x) {
return atan2(x, float(1));
}
atan2 is typically implemented as an approximation.


PROFILE SUPPORT

atan is supported in all profiles but fp20.


SEE ALSO

abs, acos, asin, atan2. sqrt, tan

		]]></description>
		<tool-tip><![CDATA[
			atan - returns arctangent of scalars and vectors.

		]]></tool-tip>
		<ports>
			<input name="a">
				<check-type method="list" target="*">
					half4,float4,half,half3,half1,fixed1,fixed4,float1,fixed3,fixed2,float3,float,fixed,half2,float2
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['float4'] = 'float4',
						['half2'] = 'half2',
						['half1'] = 'half1',
						['float'] = 'float',
						['float1'] = 'float1',
						['fixed2'] = 'fixed2',
						['fixed4'] = 'fixed4',
						['fixed3'] = 'fixed3',
						['float3'] = 'float3',
						['float2'] = 'float2',
						['fixed1'] = 'fixed1',
						['fixed'] = 'fixed',
						['half3'] = 'half3',
						['half4'] = 'half4',
						['half'] = 'half',
					}
					local types = node.a.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = atan( r${node.a.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="log2( a )">
		<description><![CDATA[
NAME

log2 - returns the base-2 logarithm of scalars and vectors


SYNOPSIS

float log2(float a);
float1 log2(float1 a);
float2 log2(float2 a);
float3 log2(float3 a);
float4 log2(float4 a);
half log2(half a);
half1 log2(half1 a);
half2 log2(half2 a);
half3 log2(half3 a);
half4 log2(half4 a);
fixed log2(fixed a);
fixed1 log2(fixed1 a);
fixed2 log2(fixed2 a);
fixed3 log2(fixed3 a);
fixed4 log2(fixed4 a);


PARAMETERS

a Vector or scalar of which to determine the base-2 logarithm.


DESCRIPTION

Returns the base-2 logarithm a.
For vectors, the returned vector contains the base-2 logarithm of each element of the input vector.


REFERENCE IMPLEMENTATION

float3 log2(float3 a)
{
float3 rv;
int i;
for (i=0; i<3; i++) {
rv[i] = log2(a[i]); // this is the ANSI C standard library log2()
}
return rv;
}
log2 is typically implemented with a native base-2 logarithm instruction.


PROFILE SUPPORT

log2 is fully supported in all profiles unless otherwise specified.
Support in the fp20 is limited to constant compile-time evaluation.


SEE ALSO

exp, log, log10, pow

		]]></description>
		<tool-tip><![CDATA[
			log2 - returns the base-2 logarithm of scalars and vectors

		]]></tool-tip>
		<ports>
			<input name="a">
				<check-type method="list" target="*">
					half4,float4,half,half3,half1,fixed1,fixed4,float1,fixed3,fixed2,float3,float,fixed,half2,float2
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['float4'] = 'float4',
						['half2'] = 'half2',
						['half1'] = 'half1',
						['float'] = 'float',
						['float1'] = 'float1',
						['fixed2'] = 'fixed2',
						['fixed4'] = 'fixed4',
						['fixed3'] = 'fixed3',
						['float3'] = 'float3',
						['float2'] = 'float2',
						['fixed1'] = 'fixed1',
						['fixed'] = 'fixed',
						['half3'] = 'half3',
						['half4'] = 'half4',
						['half'] = 'half',
					}
					local types = node.a.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = log2( r${node.a.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="texCUBEARRAY( samp, s )">
		<description><![CDATA[
NAME

texCUBEARRAY - performs a texture lookup in a given sampler array may use pre computed derivatives.


SYNOPSIS

float4 texCUBEARRAY(samplerCUBEARRAY samp, float4 s)
float4 texCUBEARRAY(samplerCUBEARRAY samp, float4 s, float3 dx, float3 dy)
int4 texCUBEARRAY(isamplerCUBEARRAY samp, float4 s)
int4 texCUBEARRAY(isamplerCUBEARRAY samp, float4 s, float3 dx, float3 dy)
uint4 texCUBEARRAY(usamplerCUBEARRAY samp, float4 s)
uint4 texCUBEARRAY(usamplerCUBEARRAY samp, float4 s, float3 dx, float3 dy)


PARAMETERS

samp Sampler array to look up.
s Coordinates to perform the lookup. The value used to select the layer is passed immediatelly after
the regular coordinates.
dx Pre computed derivative along the x axis.
dy Pre computed derivative along the y axis.
texelOff Offset to be added to obtain the final texel.


DESCRIPTION

Performs a texture lookup in sampler samp using coordinates s, the texture to be sampled is selected from
the layer specified in the coordinates. Also may use the derivatives dx and dy, the lookup may use texel
offset texelOff to compute the final texel.


REFERENCE IMPLEMENTATION



PROFILE SUPPORT

texCUBEARRAY is only supported in gp4 and newer profiles.


SEE ALSO

texCUBEARRAYbias, texCUBEARRAYlod

		]]></description>
		<tool-tip><![CDATA[
			texCUBEARRAY - performs a texture lookup in a given sampler array may use pre computed derivatives.

		]]></tool-tip>
		<ports>
			<input name="samp">
				<check-type method="list" target="*">
					samplerCUBEARRAY,isamplerCUBEARRAY,usamplerCUBEARRAY
				</check-type>
			</input>
			<input name="s">
				<check-type method="list" target="*">
					float4
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['isamplerCUBEARRAY,float4'] = 'int4',
						['samplerCUBEARRAY,float4'] = 'float4',
						['usamplerCUBEARRAY,float4'] = 'uint4',
					}
					local types = node.samp.get_type() .. ',' .. node.s.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = texCUBEARRAY( r${node.samp.get_source().uid()}, r${node.s.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="max( a, b )">
		<description><![CDATA[
NAME

max - returns the maximum of two scalars or each respective component of two vectors


SYNOPSIS

float max(float a, float b);
float1 max(float1 a, float1 b);
float2 max(float2 a, float2 b);
float3 max(float3 a, float3 b);
float4 max(float4 a, float4 b);
half max(half a, half b);
half1 max(half1 a, half1 b);
half2 max(half2 a, half2 b);
half3 max(half3 a, half3 b);
half4 max(half4 a, half4 b);
fixed max(fixed a, fixed b);
fixed1 max(fixed1 a, fixed1 b);
fixed2 max(fixed2 a, fixed2 b);
fixed3 max(fixed3 a, fixed3 b);
fixed4 max(fixed4 a, fixed4 b);


PARAMETERS

a Scalar or vector.
b Scalar or vector.


DESCRIPTION

Returns the maximum of two same-typed scalars a and b or the respective components of two same-typed
vectors a and b. The result is a three-component vector.


REFERENCE IMPLEMENTATION

max for float3 vectors could be implemented this way:
float3 max(float3 a, float3 b)
{
return float3(a.x > b.x ? a.x : b.x,
a.y > b.y ? a.y : b.y,
a.z > b.z ? a.z : b.z);
}


PROFILE SUPPORT

max is supported in all profiles. max is implemented as a compiler built-in.
Support in the fp20 is limited.


SEE ALSO

clamp, min

		]]></description>
		<tool-tip><![CDATA[
			max - returns the maximum of two scalars or each respective component of two vectors

		]]></tool-tip>
		<ports>
			<input name="a">
				<check-type method="list" target="*">
					half4,float4,half,half3,half1,fixed1,fixed4,float1,fixed3,fixed2,float3,float,fixed,half2,float2
				</check-type>
			</input>
			<input name="b">
				<check-type method="list" target="*">
					half4,float4,half,half3,half1,fixed1,fixed4,float1,fixed3,fixed2,float3,float,fixed,half2,float2
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['fixed1,fixed1'] = 'fixed1',
						['float4,float4'] = 'float4',
						['float3,float3'] = 'float3',
						['float,float'] = 'float',
						['fixed4,fixed4'] = 'fixed4',
						['fixed3,fixed3'] = 'fixed3',
						['fixed,fixed'] = 'fixed',
						['fixed2,fixed2'] = 'fixed2',
						['half4,half4'] = 'half4',
						['half3,half3'] = 'half3',
						['float1,float1'] = 'float1',
						['half,half'] = 'half',
						['half1,half1'] = 'half1',
						['float2,float2'] = 'float2',
						['half2,half2'] = 'half2',
					}
					local types = node.a.get_type() .. ',' .. node.b.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = max( r${node.a.get_source().uid()}, r${node.b.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="degrees( a )">
		<description><![CDATA[
NAME

degrees - converts values of scalars and vectors from radians to degrees


SYNOPSIS

float degrees(float a);
float1 degrees(float1 a);
float2 degrees(float2 a);
float3 degrees(float3 a);
float4 degrees(float4 a);
half degrees(half a);
half1 degrees(half1 a);
half2 degrees(half2 a);
half3 degrees(half3 a);
half4 degrees(half4 a);
fixed degrees(fixed a);
fixed1 degrees(fixed1 a);
fixed2 degrees(fixed2 a);
fixed3 degrees(fixed3 a);
fixed4 degrees(fixed4 a);


PARAMETERS

a Vector or scalar of which to convert from radians to degrees.


DESCRIPTION

Returns the scalar or vector converted from radians to degrees.
For vectors, the returned vector contains each element of the input vector converted from radians to
degrees.


REFERENCE IMPLEMENTATION

degrees for a float scalar could be implemented like this.
float degrees(float a)
{
return 57.29577951 * a;
}


PROFILE SUPPORT

degrees is supported in all profiles except fp20.


SEE ALSO

cos, radians, sin, tan

		]]></description>
		<tool-tip><![CDATA[
			degrees - converts values of scalars and vectors from radians to degrees

		]]></tool-tip>
		<ports>
			<input name="a">
				<check-type method="list" target="*">
					half4,float4,half,half3,half1,fixed1,fixed4,float1,fixed3,fixed2,float3,float,fixed,half2,float2
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['float4'] = 'float4',
						['half2'] = 'half2',
						['half1'] = 'half1',
						['float'] = 'float',
						['float1'] = 'float1',
						['fixed2'] = 'fixed2',
						['fixed4'] = 'fixed4',
						['fixed3'] = 'fixed3',
						['float3'] = 'float3',
						['float2'] = 'float2',
						['fixed1'] = 'fixed1',
						['fixed'] = 'fixed',
						['half3'] = 'half3',
						['half4'] = 'half4',
						['half'] = 'half',
					}
					local types = node.a.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = degrees( r${node.a.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="ceil( a )">
		<description><![CDATA[
NAME

ceil - returns smallest integer not less than a scalar or each vector component.


SYNOPSIS

float ceil(float a);
float1 ceil(float1 a);
float2 ceil(float2 a);
float3 ceil(float3 a);
float4 ceil(float4 a);
half ceil(half a);
half1 ceil(half1 a);
half2 ceil(half2 a);
half3 ceil(half3 a);
half4 ceil(half4 a);
fixed ceil(fixed a);
fixed1 ceil(fixed1 a);
fixed2 ceil(fixed2 a);
fixed3 ceil(fixed3 a);
fixed4 ceil(fixed4 a);


PARAMETERS

a Vector or scalar of which to determine the ceiling.


DESCRIPTION

Returns the ceiling or smallest integer not less than a scalar or each vector component.


REFERENCE IMPLEMENTATION

ceil for a float scalar could be implemented like this.
float ceil(float v)
{
return -floor(-v);
}


PROFILE SUPPORT

ceil is supported in all profiles except fp20.


SEE ALSO

floor

		]]></description>
		<tool-tip><![CDATA[
			ceil - returns smallest integer not less than a scalar or each vector component.

		]]></tool-tip>
		<ports>
			<input name="a">
				<check-type method="list" target="*">
					half4,float4,half,half3,half1,fixed1,fixed4,float1,fixed3,fixed2,float3,float,fixed,half2,float2
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['float4'] = 'float4',
						['half2'] = 'half2',
						['half1'] = 'half1',
						['float'] = 'float',
						['float1'] = 'float1',
						['fixed2'] = 'fixed2',
						['fixed4'] = 'fixed4',
						['fixed3'] = 'fixed3',
						['float3'] = 'float3',
						['float2'] = 'float2',
						['fixed1'] = 'fixed1',
						['fixed'] = 'fixed',
						['half3'] = 'half3',
						['half4'] = 'half4',
						['half'] = 'half',
					}
					local types = node.a.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = ceil( r${node.a.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="tex2DARRAYlod( samp, s, texelOff )">
		<description><![CDATA[
NAME

tex2DARRAYlod - performs a texture lookup with a specified level of detail in a given sampler array.


SYNOPSIS

float4 tex2DARRAYlod(sampler2DARRAY samp, float4 s)
float4 tex2DARRAYlod(sampler2DARRAY samp, float4 s, int texelOff)
int4 tex2DARRAYlod(isampler2DARRAY samp, float4 s)
int4 tex2DARRAYlod(isampler2DARRAY samp, float4 s, int texelOff)
uint4 tex2DARRAYlod(usampler2DARRAY samp, float4 s)
uint4 tex2DARRAYlod(usampler2DARRAY samp, float4 s, int texelOff)


PARAMETERS

samp Sampler array to lookup.
s Coordinates to perform the lookup.The value used to select the layer should be passed in the
vector component right after the regular coordinates. The level of detail value should be passed as
the last component of the coordinate vector.
texelOff Offset to be added to obtain the final texel.


DESCRIPTION

Performs a texture lookup with a specified level of detail in sampler samp using coordinates s, the texture to
be sampled is selected from the layer specified in the coordinates.


REFERENCE IMPLEMENTATION



PROFILE SUPPORT

tex2DARRAYlod is only supported in gp4 and newer profiles.


SEE ALSO

tex2DARRAY, tex2DARRAYbias.de Sh
\$1

		]]></description>
		<tool-tip><![CDATA[
			tex2DARRAYlod - performs a texture lookup with a specified level of detail in a given sampler array.

		]]></tool-tip>
		<ports>
			<input name="samp">
				<check-type method="list" target="*">
					usampler2DARRAY,isampler2DARRAY,sampler2DARRAY
				</check-type>
			</input>
			<input name="s">
				<check-type method="list" target="*">
					float4
				</check-type>
			</input>
			<input name="texelOff">
				<check-type method="list" target="*">
					int
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['sampler2DARRAY,float4,int'] = 'float4',
						['isampler2DARRAY,float4,int'] = 'int4',
						['usampler2DARRAY,float4,int'] = 'uint4',
					}
					local types = node.samp.get_type() .. ',' .. node.s.get_type() .. ',' .. node.texelOff.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = tex2DARRAYlod( r${node.samp.get_source().uid()}, r${node.s.get_source().uid()}, r${node.texelOff.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="tex2Dcmplod( samp, s, texelOff )">
		<description><![CDATA[
NAME

tex2Dcmplod - performs a texture lookup with a specified level of detail and a shadow compare in a given
sampler.


SYNOPSIS

float4 tex2Dcmplod(sampler2D samp, float4 s)
float4 tex2Dcmplod(sampler2D samp, float4 s, int texelOff)


PARAMETERS

samp Sampler to lookup.
s Coordinates to perform the lookup. The value used in the shadow comparison should be passed
right after the normal coordinates. The level of detail corresponds to the last component of the
coordinate vector.
texelOff Offset to be added to obtain the final texel.


DESCRIPTION

Performs a texture lookup with shadow compare and a specified level of detail in sampler samp using
coordinates s.


REFERENCE IMPLEMENTATION



PROFILE SUPPORT

tex2Dcmplod is supported in fragment profiles starting with fp40 and in vertex profiles starting with vp40.
Variants with texelOff are only supported in gp4 and newer profiles.


SEE ALSO

tex2Dlod, tex2Dcmpbias

		]]></description>
		<tool-tip><![CDATA[
			tex2Dcmplod - performs a texture lookup with a specified level of detail and a shadow compare in a given
sampler.

		]]></tool-tip>
		<ports>
			<input name="samp">
				<check-type method="list" target="*">
					sampler2D
				</check-type>
			</input>
			<input name="s">
				<check-type method="list" target="*">
					float4
				</check-type>
			</input>
			<input name="texelOff">
				<check-type method="list" target="*">
					int
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['sampler2D,float4,int'] = 'float4',
					}
					local types = node.samp.get_type() .. ',' .. node.s.get_type() .. ',' .. node.texelOff.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = tex2Dcmplod( r${node.samp.get_source().uid()}, r${node.s.get_source().uid()}, r${node.texelOff.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="intBitsToFloat( x )">
		<description><![CDATA[
NAME

intBitsToFloat - returns the float value corresponding to a given bit represention.of a scalar int value or
vector of int values


SYNOPSIS

float intBitsToFloat(int x);
float1 intBitsToFloat(int1 x);
float2 intBitsToFloat(int2 x);
float3 intBitsToFloat(int3 x);
float4 intBitsToFloat(int4 x);


PARAMETERS

x Integer vector or scalar to raw cast to a scalar float or vector of floats


DESCRIPTION

Returns the IEEE 754 float scalar value or vector values corresponding to a given 32-bit integer bit
represention for a scalar int value or vector of int values.
This function is based on Java's jave.lang.Float method of the same name. See:
http://java.sun.com/j2se/1.4.2/docs/api/java/lang/Float.html
The Cg compiler can typically optimize intBitsToFloat so it has no instruction cost.


REFERENCE IMPLEMENTATION

intBitsToFloat operates consistent with the following ANSI C code:
float floatToRawIntBits(int x)
{
union {
float f; // assuming 32-bit IEEE 754 single-precision
int i; // assuming 32-bit 2's complement int
} u;
u.i = x;
return u.f;
}


PROFILE SUPPORT

intBitsToFloat is supported by the gp4vp, gp4gp, and gp4vp profiles.
intBitsToFloat is not supported by pre-G80 profiles.


SEE ALSO

ceil, floatToIntBits, floatToRawIntBits, floor, round, trunc

		]]></description>
		<tool-tip><![CDATA[
			intBitsToFloat - returns the float value corresponding to a given bit represention.of a scalar int value or
vector of int values

		]]></tool-tip>
		<ports>
			<input name="x">
				<check-type method="list" target="*">
					int2,int1,int3,int4,int
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['int1'] = 'float1',
						['int4'] = 'float4',
						['int'] = 'float',
						['int2'] = 'float2',
						['int3'] = 'float3',
					}
					local types = node.x.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = intBitsToFloat( r${node.x.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="cross( a, b )">
		<description><![CDATA[
NAME

cross - returns the cross product of two three-component vectors


SYNOPSIS

float3 cross(float3 a, float3 b);
half3 cross(half3 a, half3 b);
fixed3 cross(fixed3 a, fixed3 b);


PARAMETERS

a Three-component vector.
b Three-component vector.


DESCRIPTION

Returns the cross product of three-component vectors a and b. The result is a three-component vector.


REFERENCE IMPLEMENTATION

cross for float3 vectors could be implemented this way:
float3 cross(float3 a, float3 b)
{
return a.yzx * b.zxy - a.zxy * b.yzx;
}


PROFILE SUPPORT

cross is supported in all profiles.
Support in the fp20 is limited.


SEE ALSO

dot

		]]></description>
		<tool-tip><![CDATA[
			cross - returns the cross product of two three-component vectors

		]]></tool-tip>
		<ports>
			<input name="a">
				<check-type method="list" target="*">
					float3,fixed3,half3
				</check-type>
			</input>
			<input name="b">
				<check-type method="list" target="*">
					float3,fixed3,half3
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['fixed3,fixed3'] = 'fixed3',
						['half3,half3'] = 'half3',
						['float3,float3'] = 'float3',
					}
					local types = node.a.get_type() .. ',' .. node.b.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = cross( r${node.a.get_source().uid()}, r${node.b.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="tex3Dsize( samp, lod )">
		<description><![CDATA[
NAME

tex3Dsize - returns the size of a given texture image for a given level of detail.


SYNOPSIS

int3 tex3Dsize(sampler3D samp, int lod)
int3 tex3Dsize(isampler3D samp, int lod)
int3 tex3Dsize(usampler3D samp, int lod)


PARAMETERS

samp Sampler to be queried for size.
lod Level of detail to obtain size.


DESCRIPTION

Given a sampler and a level of detail the size of the corresponding texture image is returned as the result of
the operation.


REFERENCE IMPLEMENTATION



PROFILE SUPPORT

tex3Dsize is only supported in gp4 and newer profiles.


SEE ALSO

tex3D.de Sh
\$1

		]]></description>
		<tool-tip><![CDATA[
			tex3Dsize - returns the size of a given texture image for a given level of detail.

		]]></tool-tip>
		<ports>
			<input name="samp">
				<check-type method="list" target="*">
					sampler3D,usampler3D,isampler3D
				</check-type>
			</input>
			<input name="lod">
				<check-type method="list" target="*">
					int
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['sampler3D,int'] = 'int3',
						['usampler3D,int'] = 'int3',
						['isampler3D,int'] = 'int3',
					}
					local types = node.samp.get_type() .. ',' .. node.lod.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = tex3Dsize( r${node.samp.get_source().uid()}, r${node.lod.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="texCUBEproj( samp, s )">
		<description><![CDATA[
NAME

texCUBEproj - performs a texture lookup with projection in a given sampler.


SYNOPSIS

float4 texCUBEproj(samplerCUBE samp, float4 s)
int4 texCUBEproj(isamplerCUBE samp, float4 s)
uint4 texCUBEproj(usamplerCUBE samp, float4 s)


PARAMETERS

samp Sampler to lookup.
s Coordinates to perform the lookup. The value used in the projection should be passed as the last
component of the coordinate vector.
texelOff Offset to be added to obtain the final texel.


DESCRIPTION

Performs a texture lookup in sampler samp using coordinates s, the coordinates used in the lookup are first
projected, that is, divided by the last component of the coordinate vector and them used in the lookup.


REFERENCE IMPLEMENTATION



PROFILE SUPPORT

texCUBEproj is supported in all fragment profiles and all vertex profiles starting with vp40. Variants with
integer samplers are only supported in gp4 and newer profiles.


SEE ALSO

texCUBE

		]]></description>
		<tool-tip><![CDATA[
			texCUBEproj - performs a texture lookup with projection in a given sampler.

		]]></tool-tip>
		<ports>
			<input name="samp">
				<check-type method="list" target="*">
					samplerCUBE,isamplerCUBE,usamplerCUBE
				</check-type>
			</input>
			<input name="s">
				<check-type method="list" target="*">
					float4
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['isamplerCUBE,float4'] = 'int4',
						['usamplerCUBE,float4'] = 'uint4',
						['samplerCUBE,float4'] = 'float4',
					}
					local types = node.samp.get_type() .. ',' .. node.s.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = texCUBEproj( r${node.samp.get_source().uid()}, r${node.s.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="round( a )">
		<description><![CDATA[
NAME

round - returns the rounded value of scalars or vectors


SYNOPSIS

float round(float a);
float1 round(float1 a);
float2 round(float2 a);
float3 round(float3 a);
float4 round(float4 a);
half round(half a);
half1 round(half1 a);
half2 round(half2 a);
half3 round(half3 a);
half4 round(half4 a);
fixed round(fixed a);
fixed1 round(fixed1 a);
fixed2 round(fixed2 a);
fixed3 round(fixed3 a);
fixed4 round(fixed4 a);


PARAMETERS

a Scalar or vector.


DESCRIPTION

Returns the rounded value of a scalar or vector.
For vectors, the returned vector contains the rounded value of each element of the input vector.
The round operation returns the nearest integer to the operand. The value returned by round() if the
fractional portion of the operand is 0.5 is profile dependent. On older profiles without built-in round()
support, round-to-nearest up rounding is used. On profiles newer than fp40/vp40, round-to-nearest even is
used.


REFERENCE IMPLEMENTATION

round for float could be implemented this way:
// round-to-nearest even profiles
float round(float a)
{
float x = a + 0.5;
float f = floor(x);
float r;
if (x == f) {
if (a > 0)
r = f - fmod(f, 2);
else
r = f + fmod(f, 2);
} else
r = f;
return r;
}
// round-to-nearest up profiles
float round(float a)
{
return floor(x + 0.5);
}


PROFILE SUPPORT

round is supported in all profiles except fp20.


SEE ALSO

ceil, floor, fmod, trunc

		]]></description>
		<tool-tip><![CDATA[
			round - returns the rounded value of scalars or vectors

		]]></tool-tip>
		<ports>
			<input name="a">
				<check-type method="list" target="*">
					half4,float4,half,half3,half1,fixed1,fixed4,float1,fixed3,fixed2,float3,float,fixed,half2,float2
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['float4'] = 'float4',
						['half2'] = 'half2',
						['half1'] = 'half1',
						['float'] = 'float',
						['float1'] = 'float1',
						['fixed2'] = 'fixed2',
						['fixed4'] = 'fixed4',
						['fixed3'] = 'fixed3',
						['float3'] = 'float3',
						['float2'] = 'float2',
						['fixed1'] = 'fixed1',
						['fixed'] = 'fixed',
						['half3'] = 'half3',
						['half4'] = 'half4',
						['half'] = 'half',
					}
					local types = node.a.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = round( r${node.a.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="fmod( x, y )">
		<description><![CDATA[
NAME

fmod - returns the remainder of x/y with the same sign as x


SYNOPSIS

float fmod(float x, float y);
float1 fmod(float1 x, float1 y);
float2 fmod(float2 x, float2 y);
float3 fmod(float3 x, float3 y);
float4 fmod(float4 x, float4 y);
half fmod(half x, half y);
half1 fmod(half1 x, half1 y);
half2 fmod(half2 x, half2 y);
half3 fmod(half3 x, half3 y);
half4 fmod(half4 x, half4 y);
fixed fmod(fixed x, fixed y);
fixed1 fmod(fixed1 x, fixed1 y);
fixed2 fmod(fixed2 x, fixed2 y);
fixed3 fmod(fixed3 x, fixed3 y);
fixed4 fmod(fixed4 x, fixed4 y);


PARAMETERS

x Vector or scalar numerator
y Vector or scalar denominator


DESCRIPTION

fmod returns the remainder of x divided by y with the same sign as x. If y is zero, the result is
implementation-defined because of division by zero.
For vectors, the returned vector contains the signed remainder of each element of the input vector.


REFERENCE IMPLEMENTATION

fmod for an float2 vector could be implemented as:
float2 fmod(float2 a, float2 b)
{
float2 c = frac(abs(a/b))*abs(b);
return (a < 0) ? -c : c; /* if ( a < 0 ) c = 0-c */
}


PROFILE SUPPORT

fmod is supported in all profiles but fp20.


SEE ALSO

abs, frac

		]]></description>
		<tool-tip><![CDATA[
			fmod - returns the remainder of x/y with the same sign as x

		]]></tool-tip>
		<ports>
			<input name="x">
				<check-type method="list" target="*">
					half4,float4,half,half3,half1,fixed1,fixed4,float1,fixed3,fixed2,float3,float,fixed,half2,float2
				</check-type>
			</input>
			<input name="y">
				<check-type method="list" target="*">
					half4,float4,half,half3,half1,fixed1,fixed4,float1,fixed3,fixed2,float3,float,fixed,half2,float2
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['fixed1,fixed1'] = 'fixed1',
						['float4,float4'] = 'float4',
						['float3,float3'] = 'float3',
						['float,float'] = 'float',
						['fixed4,fixed4'] = 'fixed4',
						['fixed3,fixed3'] = 'fixed3',
						['fixed,fixed'] = 'fixed',
						['fixed2,fixed2'] = 'fixed2',
						['half4,half4'] = 'half4',
						['half3,half3'] = 'half3',
						['float1,float1'] = 'float1',
						['half,half'] = 'half',
						['half1,half1'] = 'half1',
						['float2,float2'] = 'float2',
						['half2,half2'] = 'half2',
					}
					local types = node.x.get_type() .. ',' .. node.y.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = fmod( r${node.x.get_source().uid()}, r${node.y.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="pow( x, y )">
		<description><![CDATA[
NAME

pow - returns x to the y-th power of scalars and vectors


SYNOPSIS

float pow(float x, float y);
float1 pow(float1 x, float1 y);
float2 pow(float2 x, float2 y);
float3 pow(float3 x, float3 y);
float4 pow(float4 x, float4 y);
half pow(half x, half y);
half1 pow(half1 x, half1 y);
half2 pow(half2 x, half2 y);
half3 pow(half3 x, half3 y);
half4 pow(half4 x, half4 y);
fixed pow(fixed x, fixed y);
fixed1 pow(fixed1 x, fixed1 y);
fixed2 pow(fixed2 x, fixed2 y);
fixed3 pow(fixed3 x, fixed3 y);
fixed4 pow(fixed4 x, fixed4 y);


PARAMETERS

x Abase value.
y The power to raise the base.


DESCRIPTION

Returns x to the power y.
For vectors, the returned vector contains the power of each element of the base vector raised to the
respective element of the exponent vector.


REFERENCE IMPLEMENTATION

pow for float3 vectors could be implemented this way:
float3 pow(float3 x, float3 y)
{
float3 rv;
for (int i=0; i<3; i++) {
rv[i] = exp(x[i] * log(y[i]));
}
return rv;
}


PROFILE SUPPORT

exp is supported in all profiles.
Support in the fp20 is limited to constant compile-time evaluation.


SEE ALSO

exp, lit, log

		]]></description>
		<tool-tip><![CDATA[
			pow - returns x to the y-th power of scalars and vectors

		]]></tool-tip>
		<ports>
			<input name="x">
				<check-type method="list" target="*">
					half4,float4,half,half3,half1,fixed1,fixed4,float1,fixed3,fixed2,float3,float,fixed,half2,float2
				</check-type>
			</input>
			<input name="y">
				<check-type method="list" target="*">
					half4,float4,half,half3,half1,fixed1,fixed4,float1,fixed3,fixed2,float3,float,fixed,half2,float2
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['fixed1,fixed1'] = 'fixed1',
						['float4,float4'] = 'float4',
						['float3,float3'] = 'float3',
						['float,float'] = 'float',
						['fixed4,fixed4'] = 'fixed4',
						['fixed3,fixed3'] = 'fixed3',
						['fixed,fixed'] = 'fixed',
						['fixed2,fixed2'] = 'fixed2',
						['half4,half4'] = 'half4',
						['half3,half3'] = 'half3',
						['float1,float1'] = 'float1',
						['half,half'] = 'half',
						['half1,half1'] = 'half1',
						['float2,float2'] = 'float2',
						['half2,half2'] = 'half2',
					}
					local types = node.x.get_type() .. ',' .. node.y.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = pow( r${node.x.get_source().uid()}, r${node.y.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="atan2( y, x )">
		<description><![CDATA[
NAME

atan2 - returns arctangent of scalars and vectors.


SYNOPSIS

float atan2(float y, float x);
float1 atan2(float1 y, float1 x);
float2 atan2(float2 y, float2 x);
float3 atan2(float3 y, float3 x);
float4 atan2(float4 y, float4 x);
half atan2(half y, half x);
half1 atan2(half1 y, half1 x);
half2 atan2(half2 y, half2 x);
half3 atan2(half3 y, half3 x);
half4 atan2(half4 y, half4 x);
fixed atan2(fixed y, fixed x);
fixed1 atan2(fixed1 y, fixed1 x);
fixed2 atan2(fixed2 y, fixed2 x);
fixed3 atan2(fixed3 y, fixed3 x);
fixed4 atan2(fixed4 y, fixed4 x);


PARAMETERS

y Vector or scalar for numerator of ratio of which to determine the arctangent.
x Vector or scalar of denominator of ratio of which to determine the arctangent.


DESCRIPTION

atan2 calculates the arctangent of y/x. atan2 is well defined for every point other than the origin, even if x
equals 0 and y does not equal 0.
For vectors, the returned vector contains the arctangent of each element of the input vector.


REFERENCE IMPLEMENTATION

atan2 for a float2 scalar could be implemented as an approximation like this.
float2 atan2(float2 y, float2 x)
{
float2 t0, t1, t2, t3, t4;
t3 = abs(x);
t1 = abs(y);
t0 = max(t3, t1);
t1 = min(t3, t1);
t3 = float(1) / t0;
t3 = t1 * t3;
t4 = t3 * t3;
t0 = - float(0.013480470);
t0 = t0 * t4 + float(0.057477314);
t0 = t0 * t4 - float(0.121239071);
t0 = t0 * t4 + float(0.195635925);
t0 = t0 * t4 - float(0.332994597);
t0 = t0 * t4 + float(0.999995630);
t3 = t0 * t3;
t3 = (abs(y) > abs(x)) ? float(1.570796327) - t3 : t3;
t3 = (x < 0) ? float(3.141592654) - t3 : t3;
t3 = (y < 0) ? -t3 : t3;
return t3;
}


PROFILE SUPPORT

atan2 is supported in all profiles but fp20.


SEE ALSO

abs, acos, asin, atan. sqrt, tan

		]]></description>
		<tool-tip><![CDATA[
			atan2 - returns arctangent of scalars and vectors.

		]]></tool-tip>
		<ports>
			<input name="y">
				<check-type method="list" target="*">
					half4,float4,half,half3,half1,fixed1,fixed4,float1,fixed3,fixed2,float3,float,fixed,half2,float2
				</check-type>
			</input>
			<input name="x">
				<check-type method="list" target="*">
					half4,float4,half,half3,half1,fixed1,fixed4,float1,fixed3,fixed2,float3,float,fixed,half2,float2
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['fixed1,fixed1'] = 'fixed1',
						['float4,float4'] = 'float4',
						['float3,float3'] = 'float3',
						['float,float'] = 'float',
						['fixed4,fixed4'] = 'fixed4',
						['fixed3,fixed3'] = 'fixed3',
						['fixed,fixed'] = 'fixed',
						['fixed2,fixed2'] = 'fixed2',
						['half4,half4'] = 'half4',
						['half3,half3'] = 'half3',
						['float1,float1'] = 'float1',
						['half,half'] = 'half',
						['half1,half1'] = 'half1',
						['float2,float2'] = 'float2',
						['half2,half2'] = 'half2',
					}
					local types = node.y.get_type() .. ',' .. node.x.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = atan2( r${node.y.get_source().uid()}, r${node.x.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="tex1DARRAYfetch( samp, s, texelOff )">
		<description><![CDATA[
NAME

tex1DARRAYfetch - performs an unfiltered texture lookup in a given sampler array.


SYNOPSIS

float4 tex1DARRAYfetch(sampler1DARRAY samp, int4 s)
float4 tex1DARRAYfetch(sampler1DARRAY samp, int4 s, int texelOff)
int4 tex1DARRAYfetch(isampler1DARRAY samp, int4 s)
int4 tex1DARRAYfetch(isampler1DARRAY samp, int4 s, int texelOff)
uint4 tex1DARRAYfetch(usampler1DARRAY samp, int4 s)
uint4 tex1DARRAYfetch(usampler1DARRAY samp, int4 s, int texelOff)


PARAMETERS

samp Sampler array to lookup.
s Coordinates to perform the lookup, the layer is selected by the component right after the regular
coordinates, the level of detail is provided by the last component of the coordinate vector.
texelOff Offset to be added to obtain the final texel.


DESCRIPTION

Performs an unfiltered texture lookup in sampler array samp using coordinates s. The layer to be accessed is
selected by the component right after the regular coordinates, the level of detail is provided by the last
component of the coordinate vector. May use texel offset texelOff to compute final texel.


REFERENCE IMPLEMENTATION



PROFILE SUPPORT

tex1DARRAYfetch is only supported in gp4 and newer profiles.


SEE ALSO

tex1Dfetch.de Sh
\$1

		]]></description>
		<tool-tip><![CDATA[
			tex1DARRAYfetch - performs an unfiltered texture lookup in a given sampler array.

		]]></tool-tip>
		<ports>
			<input name="samp">
				<check-type method="list" target="*">
					usampler1DARRAY,sampler1DARRAY,isampler1DARRAY
				</check-type>
			</input>
			<input name="s">
				<check-type method="list" target="*">
					int4
				</check-type>
			</input>
			<input name="texelOff">
				<check-type method="list" target="*">
					int
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['isampler1DARRAY,int4,int'] = 'int4',
						['usampler1DARRAY,int4,int'] = 'uint4',
						['sampler1DARRAY,int4,int'] = 'float4',
					}
					local types = node.samp.get_type() .. ',' .. node.s.get_type() .. ',' .. node.texelOff.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = tex1DARRAYfetch( r${node.samp.get_source().uid()}, r${node.s.get_source().uid()}, r${node.texelOff.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="tex2DARRAY( samp, s, dx, dy, texelOff )">
		<description><![CDATA[
NAME

tex2DARRAY - performs a texture lookup in a given sampler array may use pre computed derivatives and,
in some cases, perform a shadow comparison.


SYNOPSIS

float4 tex2DARRAY(sampler2DARRAY samp, float3 s)
float4 tex2DARRAY(sampler2DARRAY samp, float3 s, int texelOff)
float4 tex2DARRAY(sampler2DARRAY samp, float4 s)
float4 tex2DARRAY(sampler2DARRAY samp, float4 s, int texelOff)
float4 tex2DARRAY(sampler2DARRAY samp, float3 s, float dx, float dy)
float4 tex2DARRAY(sampler2DARRAY samp, float3 s, float dx, float dy,int texelOff)
float4 tex2DARRAY(sampler2DARRAY samp, float4 s, float dx, float dy)
float4 tex2DARRAY(sampler2DARRAY samp, float4 s, float dx, float dy,int texelOff)
int4 tex2DARRAY(isampler2DARRAY samp, float3 s)
int4 tex2DARRAY(isampler2DARRAY samp, float3 s, int texelOff)
int4 tex2DARRAY(isampler2DARRAY samp, float3 s, float dx, float dy)
int4 tex2DARRAY(isampler2DARRAY samp, float3 s, float dx, float dy,int texelOff)
uint4 tex2DARRAY(usampler2DARRAY samp, float3 s)
uint4 tex2DARRAY(usampler2DARRAY samp, float3 s, int texelOff)
uint4 tex2DARRAY(usampler2DARRAY samp, float3 s, float dx, float dy)
uint4 tex2DARRAY(usampler2DARRAY samp, float3 s, float dx, float dy,int texelOff)


PARAMETERS

samp Sampler array to look up.
s Coordinates to perform the lookup. The value used to select the layer is passed immediatelly after
the regular coordinates, if an extra coordinate is present it is used to perform a shadow
comparison.
dx Pre computed derivative along the x axis.
dy Pre computed derivative along the y axis.
texelOff Offset to be added to obtain the final texel.


DESCRIPTION

Performs a texture lookup in sampler samp using coordinates s, the texture to be sampled is selected from
the layer specified in the coordinates. Also may use the derivatives dx and dy, the lookup may involve a
shadow comparison and use texel offset texelOff to compute the final texel.


REFERENCE IMPLEMENTATION



PROFILE SUPPORT

tex2DARRAY is only supported in gp4 and newer profiles.


SEE ALSO

tex2DARRAYbias, tex2DARRAYlod

		]]></description>
		<tool-tip><![CDATA[
			tex2DARRAY - performs a texture lookup in a given sampler array may use pre computed derivatives and,
in some cases, perform a shadow comparison.

		]]></tool-tip>
		<ports>
			<input name="samp">
				<check-type method="list" target="*">
					usampler2DARRAY,isampler2DARRAY,sampler2DARRAY
				</check-type>
			</input>
			<input name="s">
				<check-type method="list" target="*">
					float3,float4
				</check-type>
			</input>
			<input name="dx">
				<check-type method="list" target="*">
					float
				</check-type>
			</input>
			<input name="dy">
				<check-type method="list" target="*">
					float
				</check-type>
			</input>
			<input name="texelOff">
				<check-type method="list" target="*">
					int
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['sampler2DARRAY,float4,float,float,int'] = 'float4',
						['sampler2DARRAY,float3,float,float,int'] = 'float4',
						['isampler2DARRAY,float3,float,float,int'] = 'int4',
						['usampler2DARRAY,float3,float,float,int'] = 'uint4',
					}
					local types = node.samp.get_type() .. ',' .. node.s.get_type() .. ',' .. node.dx.get_type() .. ',' .. node.dy.get_type() .. ',' .. node.texelOff.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = tex2DARRAY( r${node.samp.get_source().uid()}, r${node.s.get_source().uid()}, r${node.dx.get_source().uid()}, r${node.dy.get_source().uid()}, r${node.texelOff.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="tex1Dcmpbias( samp, s )">
		<description><![CDATA[
NAME

tex1Dcmpbias - performs a texture lookup with bias and shadow compare in a given sampler.


SYNOPSIS

float4 tex1Dcmpbias(sampler1D samp, float4 s)
float4 tex1Dcmpbias(sampler1D samp, float4 s, int texelOff)


PARAMETERS

samp Sampler to lookup.
s Coordinates to perform the lookup. The value used in the shadow comparison should be passed
right after the normal coordinates. The bias value should be passed as the last component of the
coordinate vector.
texelOff Offset to be added to obtain the final texel.


DESCRIPTION

Performs a texture lookup with shadow compare and bias in sampler samp using coordinates s.


REFERENCE IMPLEMENTATION



PROFILE SUPPORT

tex1Dcmpbias is supported in fragment profiles starting with fp40 and in vertex profiles starting with vp40.
Variants with texelOff are only supported in gp4 and newer profiles.


SEE ALSO

tex1Dcmplod, tex1Dbias.de Sh
\$1

		]]></description>
		<tool-tip><![CDATA[
			tex1Dcmpbias - performs a texture lookup with bias and shadow compare in a given sampler.

		]]></tool-tip>
		<ports>
			<input name="samp">
				<check-type method="list" target="*">
					sampler1D
				</check-type>
			</input>
			<input name="s">
				<check-type method="list" target="*">
					float4
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['sampler1D,float4'] = 'float4',
					}
					local types = node.samp.get_type() .. ',' .. node.s.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = tex1Dcmpbias( r${node.samp.get_source().uid()}, r${node.s.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="mul( M, v )">
		<description><![CDATA[
NAME

mul - multiply a matrix by a column vector, row vector by a matrix, or matrix by a matrix


SYNOPSIS

float4 mul(float4x4 M, float4 v);
float4 mul(float4x3 M, float3 v);
float4 mul(float4x2 M, float2 v);
float4 mul(float4x1 M, float1 v);
float3 mul(float3x4 M, float4 v);
float3 mul(float3x3 M, float3 v);
float3 mul(float3x2 M, float2 v);
float3 mul(float3x1 M, float1 v);
float2 mul(float2x4 M, float4 v);
float2 mul(float2x3 M, float3 v);
float2 mul(float2x2 M, float2 v);
float2 mul(float2x1 M, float1 v);
float1 mul(float1x4 M, float4 v);
float1 mul(float1x3 M, float3 v);
float1 mul(float1x2 M, float2 v);
float1 mul(float1x1 M, float1 v);
float4 mul(float4 v, float4x4 M);
float4 mul(float3 v, float3x4 M);
float4 mul(float2 v, float2x4 M);
float4 mul(float1 v, float1x4 M);
float3 mul(float4 v, float4x3 M);
float3 mul(float3 v, float3x3 M);
float3 mul(float2 v, float2x3 M);
float3 mul(float1 v, float1x3 M);
float2 mul(float4 v, float4x2 M);
float2 mul(float3 v, float3x2 M);
float2 mul(float2 v, float2x2 M);
float2 mul(float1 v, float1x2 M);
float1 mul(float4 v, float4x1 M);
float1 mul(float3 v, float3x1 M);
float1 mul(float2 v, float2x1 M);
float1 mul(float1 v, float1x1 M);
half4 mul(half4x4 M, half4 v);
half4 mul(half4x3 M, half3 v);
half4 mul(half4x2 M, half2 v);
half4 mul(half4x1 M, half1 v);
half3 mul(half3x4 M, half4 v);
half3 mul(half3x3 M, half3 v);
half3 mul(half3x2 M, half2 v);
half3 mul(half3x1 M, half1 v);
half2 mul(half2x4 M, half4 v);
half2 mul(half2x3 M, half3 v);
half2 mul(half2x2 M, half2 v);
half2 mul(half2x1 M, half1 v);
half1 mul(half1x4 M, half4 v);
half1 mul(half1x3 M, half3 v);
half1 mul(half1x2 M, half2 v);
half1 mul(half1x1 M, half1 v);
half4 mul(half4 v, half4x4 M);
half4 mul(half3 v, half3x4 M);
half4 mul(half2 v, half2x4 M);
half4 mul(half1 v, half1x4 M);
half3 mul(half4 v, half4x3 M);
half3 mul(half3 v, half3x3 M);
half3 mul(half2 v, half2x3 M);
half3 mul(half1 v, half1x3 M);
half2 mul(half4 v, half4x2 M);
half2 mul(half3 v, half3x2 M);
half2 mul(half2 v, half2x2 M);
half2 mul(half1 v, half1x2 M);
half1 mul(half4 v, half4x1 M);
half1 mul(half3 v, half3x1 M);
half1 mul(half2 v, half2x1 M);
half1 mul(half1 v, half1x1 M);
fixed4 mul(fixed4x4 M, fixed4 v);
fixed4 mul(fixed4x3 M, fixed3 v);
fixed4 mul(fixed4x2 M, fixed2 v);
fixed4 mul(fixed4x1 M, fixed1 v);
fixed3 mul(fixed3x4 M, fixed4 v);
fixed3 mul(fixed3x3 M, fixed3 v);
fixed3 mul(fixed3x2 M, fixed2 v);
fixed3 mul(fixed3x1 M, fixed1 v);
fixed2 mul(fixed2x4 M, fixed4 v);
fixed2 mul(fixed2x3 M, fixed3 v);
fixed2 mul(fixed2x2 M, fixed2 v);
fixed2 mul(fixed2x1 M, fixed1 v);
fixed1 mul(fixed1x4 M, fixed4 v);
fixed1 mul(fixed1x3 M, fixed3 v);
fixed1 mul(fixed1x2 M, fixed2 v);
fixed1 mul(fixed1x1 M, fixed1 v);
fixed4 mul(fixed4 v, fixed4x4 M);
fixed4 mul(fixed3 v, fixed3x4 M);
fixed4 mul(fixed2 v, fixed2x4 M);
fixed4 mul(fixed1 v, fixed1x4 M);
fixed3 mul(fixed4 v, fixed4x3 M);
fixed3 mul(fixed3 v, fixed3x3 M);
fixed3 mul(fixed2 v, fixed2x3 M);
fixed3 mul(fixed1 v, fixed1x3 M);
fixed2 mul(fixed4 v, fixed4x2 M);
fixed2 mul(fixed3 v, fixed3x2 M);
fixed2 mul(fixed2 v, fixed2x2 M);
fixed2 mul(fixed1 v, fixed1x2 M);
fixed1 mul(fixed4 v, fixed4x1 M);
fixed1 mul(fixed3 v, fixed3x1 M);
fixed1 mul(fixed2 v, fixed2x1 M);
fixed1 mul(fixed1 v, fixed1x1 M);
float1x1 mul(float1x1 A, float1x1 B);
float1x2 mul(float1x1 A, float1x2 B);
float1x3 mul(float1x1 A, float1x3 B);
float1x4 mul(float1x1 A, float1x4 B);
float1x1 mul(float1x2 A, float2x1 B);
float1x2 mul(float1x2 A, float2x2 B);
float1x3 mul(float1x2 A, float2x3 B);
float1x4 mul(float1x2 A, float2x4 B);
float1x1 mul(float1x3 A, float3x1 B);
float1x2 mul(float1x3 A, float3x2 B);
float1x3 mul(float1x3 A, float3x3 B);
float1x4 mul(float1x3 A, float3x4 B);
float1x1 mul(float1x4 A, float4x1 B);
float1x2 mul(float1x4 A, float4x2 B);
float1x3 mul(float1x4 A, float4x3 B);
float1x4 mul(float1x4 A, float4x4 B);
float2x1 mul(float2x1 A, float1x1 B);
float2x2 mul(float2x1 A, float1x2 B);
float2x3 mul(float2x1 A, float1x3 B);
float2x4 mul(float2x1 A, float1x4 B);
float2x1 mul(float2x2 A, float2x1 B);
float2x2 mul(float2x2 A, float2x2 B);
float2x3 mul(float2x2 A, float2x3 B);
float2x4 mul(float2x2 A, float2x4 B);
float2x1 mul(float2x3 A, float3x1 B);
float2x2 mul(float2x3 A, float3x2 B);
float2x3 mul(float2x3 A, float3x3 B);
float2x4 mul(float2x3 A, float3x4 B);
float2x1 mul(float2x4 A, float4x1 B);
float2x2 mul(float2x4 A, float4x2 B);
float2x3 mul(float2x4 A, float4x3 B);
float2x4 mul(float2x4 A, float4x4 B);
float3x1 mul(float3x1 A, float1x1 B);
float3x2 mul(float3x1 A, float1x2 B);
float3x3 mul(float3x1 A, float1x3 B);
float3x4 mul(float3x1 A, float1x4 B);
float3x1 mul(float3x2 A, float2x1 B);
float3x2 mul(float3x2 A, float2x2 B);
float3x3 mul(float3x2 A, float2x3 B);
float3x4 mul(float3x2 A, float2x4 B);
float3x1 mul(float3x3 A, float3x1 B);
float3x2 mul(float3x3 A, float3x2 B);
float3x3 mul(float3x3 A, float3x3 B);
float3x4 mul(float3x3 A, float3x4 B);
float3x1 mul(float3x4 A, float4x1 B);
float3x2 mul(float3x4 A, float4x2 B);
float3x3 mul(float3x4 A, float4x3 B);
float3x4 mul(float3x4 A, float4x4 B);
float4x1 mul(float4x1 A, float1x1 B);
float4x2 mul(float4x1 A, float1x2 B);
float4x3 mul(float4x1 A, float1x3 B);
float4x4 mul(float4x1 A, float1x4 B);
float4x1 mul(float4x2 A, float2x1 B);
float4x2 mul(float4x2 A, float2x2 B);
float4x3 mul(float4x2 A, float2x3 B);
float4x4 mul(float4x2 A, float2x4 B);
float4x1 mul(float4x3 A, float3x1 B);
float4x2 mul(float4x3 A, float3x2 B);
float4x3 mul(float4x3 A, float3x3 B);
float4x4 mul(float4x3 A, float3x4 B);
float4x1 mul(float4x4 A, float4x1 B);
float4x2 mul(float4x4 A, float4x2 B);
float4x3 mul(float4x4 A, float4x3 B);
float4x4 mul(float4x4 A, float4x4 B);


PARAMETERS

M Matrix
v Vector
A Matrix
B Matrix


DESCRIPTION

Returns the vector result of multiplying a matrix M by a column vector v; a row vector v by a matrix M; or a
matrix A by a second matrix B.
The following are algebrically equal (if not necessarily numerically equal):
mul(M,v) == mul(v, tranpose(M))
mul(v,M) == mul(tranpose(M), v)


REFERENCE IMPLEMENTATION

mul for a float4x3 matrix by a float3 column vector could be implemented this way:
float4 mul(float4x3 M, float3 v)
{
float4 r;
r.x = dot( M._m00_m01_m02, v );
r.y = dot( M._m10_m11_m12, v );
r.z = dot( M._m20_m21_m22, v );
r.w = dot( M._m30_m31_m32, v );
return r;
}


PROFILE SUPPORT

mul is supported in all profiles.
The fifixed3 matrix-by-vector and vector-by-matrix multiplies are very efficient in the fp20 and fp30 profiles.


SEE ALSO

cross, dot, transpose

		]]></description>
		<tool-tip><![CDATA[
			mul - multiply a matrix by a column vector, row vector by a matrix, or matrix by a matrix

		]]></tool-tip>
		<ports>
			<input name="M">
				<check-type method="list" target="*">
					fixed3x3,half2x3,float2x2,half2x1,fixed3x4,half3x1,float4x1,float2x1,float1x3,half1x1,half4x4,fixed1x2,fixed2x3,float3x2,half2x2,fixed3x2,fixed1x4,fixed2x1,fixed3x1,fixed2x4,fixed2x2,half4x1,fixed1x3,fixed4x1,fixed4x4,half4x2,fixed4x3,float1x1,float4x3,half3x2,fixed4x2,float4x2,float1x2,half4x3,float3x4,float1x4,half1x4,half2x4,float3x3,float2x3,half1x2,half3x3,float3x1,float2x4,float4x4,fixed1x1,half3x4,half1x3
				</check-type>
			</input>
			<input name="v">
				<check-type method="list" target="*">
					half4,float4,half3,half2,fixed4,float3,fixed1,fixed2,fixed3,float1,half1,float2
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['half4x3,half3'] = 'half4',
						['half3x1,half1'] = 'half3',
						['half4x1,half1'] = 'half4',
						['float2x2,float2'] = 'float2',
						['float3x2,float2'] = 'float3',
						['half2x1,half1'] = 'half2',
						['float3x3,float3'] = 'float3',
						['fixed3x4,fixed4'] = 'fixed3',
						['float2x3,float3'] = 'float2',
						['fixed4x4,fixed4'] = 'fixed4',
						['half3x2,half2'] = 'half3',
						['half4x2,half2'] = 'half4',
						['half3x3,half3'] = 'half3',
						['float3x1,float1'] = 'float3',
						['float1x3,float3'] = 'float1',
						['half3x4,half4'] = 'half3',
						['fixed1x2,fixed2'] = 'fixed1',
						['float3x4,float4'] = 'float3',
						['half1x4,half4'] = 'half1',
						['float2x1,float1'] = 'float2',
						['fixed4x1,fixed1'] = 'fixed4',
						['float4x2,float2'] = 'float4',
						['fixed1x1,fixed1'] = 'fixed1',
						['fixed1x3,fixed3'] = 'fixed1',
						['fixed3x3,fixed3'] = 'fixed3',
						['fixed1x4,fixed4'] = 'fixed1',
						['half2x4,half4'] = 'half2',
						['float1x2,float2'] = 'float1',
						['fixed2x1,fixed1'] = 'fixed2',
						['fixed3x1,fixed1'] = 'fixed3',
						['fixed2x2,fixed2'] = 'fixed2',
						['fixed2x3,fixed3'] = 'fixed2',
						['fixed4x2,fixed2'] = 'fixed4',
						['half4x4,half4'] = 'half4',
						['half2x2,half2'] = 'half2',
						['float4x1,float1'] = 'float4',
						['float1x4,float4'] = 'float1',
						['fixed3x2,fixed2'] = 'fixed3',
						['fixed2x4,fixed4'] = 'fixed2',
						['fixed4x3,fixed3'] = 'fixed4',
						['half1x1,half1'] = 'half1',
						['float4x4,float4'] = 'float4',
						['float4x3,float3'] = 'float4',
						['float2x4,float4'] = 'float2',
						['half1x2,half2'] = 'half1',
						['half1x3,half3'] = 'half1',
						['float1x1,float1'] = 'float1',
						['half2x3,half3'] = 'half2',
					}
					local types = node.M.get_type() .. ',' .. node.v.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = mul( r${node.M.get_source().uid()}, r${node.v.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="ddx( a )">
		<description><![CDATA[
NAME

ddx - returns approximate partial derivative with respect to window-space X


SYNOPSIS

float ddx(float a);
float1 ddx(float1 a);
float2 ddx(float2 a);
float3 ddx(float3 a);
float4 ddx(float4 a);
half ddx(half a);
half1 ddx(half1 a);
half2 ddx(half2 a);
half3 ddx(half3 a);
half4 ddx(half4 a);
fixed ddx(fixed a);
fixed1 ddx(fixed1 a);
fixed2 ddx(fixed2 a);
fixed3 ddx(fixed3 a);
fixed4 ddx(fixed4 a);


PARAMETERS

a Vector or scalar of which to approximate the partial derivative with respect to window-space X.


DESCRIPTION

Returns approximate partial derivative of a with respect to the window-space (horizontal) x coordinate.
For vectors, the returned vector contains the approximate partial derivative of each element of the input
vector.
This function is only available in fragment program profiles (but not all of them).
The specific way the partial derivative is computed is implementation-dependent. Typically fragments are
rasterized in 2x2 arrangements of fragments (called quad-fragments) and the partial derivatives of a
variable is computed by differencing with the adjacent horizontal fragment in the quad-fragment.
The partial derivative computation may incorrect when ddx is used in control flow paths where not all the
fragments within a quad-fragment have branched the same way.
The partial derivative computation may be less exact (wobbly) when the variable is computed based on
varying parameters interpolated with centroid interpolation.


REFERENCE IMPLEMENTATION

ddx is not expressible in Cg code.


PROFILE SUPPORT

ddx is supported only in fragment profiles. Vertex and geometry profiles lack the concept of window
space.
ddx is unsupported in the fp20, ps_1_1, ps_1_2, ps_1_3, and arbfp1 profiles.


SEE ALSO

ddy, fp30, fp40, fwidth, gp4fp

		]]></description>
		<tool-tip><![CDATA[
			ddx - returns approximate partial derivative with respect to window-space X

		]]></tool-tip>
		<ports>
			<input name="a">
				<check-type method="list" target="*">
					half4,float4,half,half3,half1,fixed1,fixed4,float1,fixed3,fixed2,float3,float,fixed,half2,float2
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['float4'] = 'float4',
						['half2'] = 'half2',
						['half1'] = 'half1',
						['float'] = 'float',
						['float1'] = 'float1',
						['fixed2'] = 'fixed2',
						['fixed4'] = 'fixed4',
						['fixed3'] = 'fixed3',
						['float3'] = 'float3',
						['float2'] = 'float2',
						['fixed1'] = 'fixed1',
						['fixed'] = 'fixed',
						['half3'] = 'half3',
						['half4'] = 'half4',
						['half'] = 'half',
					}
					local types = node.a.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = ddx( r${node.a.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="tex1D( samp, s, dx, dy, texelOff )">
		<description><![CDATA[
NAME

tex1D - performs a texture lookup in a given 1D sampler and, in some cases, a shadow comparison. May
also use pre computed derivatives if those are provided.


SYNOPSIS

float4 tex1D(sampler1D samp, float s)
float4 tex1D(sampler1D samp, float s, int texelOff)
float4 tex1D(sampler1D samp, float2 s)
float4 tex1D(sampler1D samp, float2 s, int texelOff)
float4 tex1D(sampler1D samp, float s, float dx, float dy)
float4 tex1D(sampler1D samp, float s, float dx, float dy, int texelOff)
float4 tex1D(sampler1D samp, float2 s, float dx, float dy)
float4 tex1D(sampler1D samp, float2 s, float dx, float dy, int texelOff)
int4 tex1D(isampler1D samp, float s);
int4 tex1D(isampler1D samp, float s, int texelOff);
int4 tex1D(isampler1D samp, float s, float dx, float dy)
int4 tex1D(isampler1D samp, float s, float dx, float dy, int texelOff)
uint4 tex1D(usampler1D samp, float s);
uint4 tex1D(usampler1D samp, float s, int texelOff);
uint4 tex1D(usampler1D samp, float s, float dx, float dy)
uint4 tex1D(usampler1D samp, float s, float dx, float dy,int texelOff)


PARAMETERS

samp Sampler to lookup.
s Coordinates to perform the lookup. If an extra coordinate compared to the texture dimensionality
is present it is used to perform a shadow comparison. The value used in the shadow comparison is
always the last component of the coordinate vector.
dx Pre computed derivative along the x axis.
dy Pre computed derivative along the y axis.
texelOff Offset to be added to obtain the final texel.


DESCRIPTION

Performs a texture lookup in sampler samp using coordinates s, may use and derivatives dx and dy, also
may perform shadow comparison and use texel offset texelOff to compute final texel.


REFERENCE IMPLEMENTATION



PROFILE SUPPORT

tex1D is supported in all fragment profiles and all vertex profiles starting with vp40, variants with shadow
comparison are only supported in fp40 and newer profiles, variants with texel offsets are only supported in
gp4 and newer profiles, variants with integer textures are also only supported in gp4 and newer profiles.


SEE ALSO

tex1Dbias, tex1Dlod, tex1Dproj

		]]></description>
		<tool-tip><![CDATA[
			tex1D - performs a texture lookup in a given 1D sampler and, in some cases, a shadow comparison. May
also use pre computed derivatives if those are provided.

		]]></tool-tip>
		<ports>
			<input name="samp">
				<check-type method="list" target="*">
					usampler1D,isampler1D,sampler1D
				</check-type>
			</input>
			<input name="s">
				<check-type method="list" target="*">
					float,float2
				</check-type>
			</input>
			<input name="dx">
				<check-type method="list" target="*">
					float
				</check-type>
			</input>
			<input name="dy">
				<check-type method="list" target="*">
					float
				</check-type>
			</input>
			<input name="texelOff">
				<check-type method="list" target="*">
					int
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['usampler1D,float,float,float,int'] = 'uint4',
						['sampler1D,float,float,float,int'] = 'float4',
						['sampler1D,float2,float,float,int'] = 'float4',
						['isampler1D,float,float,float,int'] = 'int4',
					}
					local types = node.samp.get_type() .. ',' .. node.s.get_type() .. ',' .. node.dx.get_type() .. ',' .. node.dy.get_type() .. ',' .. node.texelOff.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = tex1D( r${node.samp.get_source().uid()}, r${node.s.get_source().uid()}, r${node.dx.get_source().uid()}, r${node.dy.get_source().uid()}, r${node.texelOff.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="saturate( x )">
		<description><![CDATA[
NAME

saturate - returns smallest integer not less than a scalar or each vector component.


SYNOPSIS

float saturate(float x);
float1 saturate(float1 x);
float2 saturate(float2 x);
float3 saturate(float3 x);
float4 saturate(float4 x);
half saturate(half x);
half1 saturate(half1 x);
half2 saturate(half2 x);
half3 saturate(half3 x);
half4 saturate(half4 x);
fixed saturate(fixed x);
fixed1 saturate(fixed1 x);
fixed2 saturate(fixed2 x);
fixed3 saturate(fixed3 x);
fixed4 saturate(fixed4 x);


PARAMETERS

x Vector or scalar to saturate.


DESCRIPTION

Returns x saturated to the range [0,1] as follows:
1) Returns 0 if x is less than 0; else
2) Returns 1 if x is greater than 1; else
3) Returns x otherwise.
For vectors, the returned vector contains the saturated result of each element of the vector x saturated to
[0,1].


REFERENCE IMPLEMENTATION

saturate for float scalars could be implemented like this.
float saturate(float x)
{
return max(0, min(1, x));
}


PROFILE SUPPORT

saturate is supported in all profiles.
saturate is very efficient in the fp20, fp30, and fp40 profiles.


SEE ALSO

clamp, max, min

		]]></description>
		<tool-tip><![CDATA[
			saturate - returns smallest integer not less than a scalar or each vector component.

		]]></tool-tip>
		<ports>
			<input name="x">
				<check-type method="list" target="*">
					half4,float4,half,half3,half1,fixed1,fixed4,float1,fixed3,fixed2,float3,float,fixed,half2,float2
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['float4'] = 'float4',
						['half2'] = 'half2',
						['half1'] = 'half1',
						['float'] = 'float',
						['float1'] = 'float1',
						['fixed2'] = 'fixed2',
						['fixed4'] = 'fixed4',
						['fixed3'] = 'fixed3',
						['float3'] = 'float3',
						['float2'] = 'float2',
						['fixed1'] = 'fixed1',
						['fixed'] = 'fixed',
						['half3'] = 'half3',
						['half4'] = 'half4',
						['half'] = 'half',
					}
					local types = node.x.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = saturate( r${node.x.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="texRECTlod( samp, s )">
		<description><![CDATA[
NAME

texRECTlod - performs a texture lookup with a specified level of detail in a given sampler.


SYNOPSIS

float4 texRECTlod(samplerRECT samp, float4 s)
float4 texRECTlod(samplerRECT samp, float4 s, int texelOff)
int4 texRECTlod(isamplerRECT samp, float4 s)
int4 texRECTlod(isamplerRECT samp, float4 s, int texelOff)
uint4 texRECTlod(usamplerRECT samp, float4 s)
uint4 texRECTlod(usamplerRECT samp, float4 s, int texelOff)


PARAMETERS

samp Sampler to lookup.
s Coordinates to perform the lookup. The level of detail should be passed as the last component of
the coordinate vector.
texelOff Offset to be added to obtain the final texel.


DESCRIPTION

Performs a texture lookup with a specified level of detail in sampler samp using coordinates s.


REFERENCE IMPLEMENTATION



PROFILE SUPPORT

texRECTlod is supported in fragment profiles starting with fp40 and in vertex profiles starting with vp40.
Variants with texelOff are only supported in gp4 and newer profiles. Variants with integer samplers are also
only suppported in gp4 and newer profiles.


SEE ALSO

texRECTbias.de Sh
\$1

		]]></description>
		<tool-tip><![CDATA[
			texRECTlod - performs a texture lookup with a specified level of detail in a given sampler.

		]]></tool-tip>
		<ports>
			<input name="samp">
				<check-type method="list" target="*">
					isamplerRECT,usamplerRECT,samplerRECT
				</check-type>
			</input>
			<input name="s">
				<check-type method="list" target="*">
					float4
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['samplerRECT,float4'] = 'float4',
						['usamplerRECT,float4'] = 'uint4',
						['isamplerRECT,float4'] = 'int4',
					}
					local types = node.samp.get_type() .. ',' .. node.s.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = texRECTlod( r${node.samp.get_source().uid()}, r${node.s.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="abs( a )">
		<description><![CDATA[
NAME

abs - returns absolute value of scalars and vectors.


SYNOPSIS

float abs(float a);
float1 abs(float1 a);
float2 abs(float2 a);
float3 abs(float3 a);
float4 abs(float4 a);
half abs(half a);
half1 abs(half1 a);
half2 abs(half2 a);
half3 abs(half3 a);
half4 abs(half4 a);
fixed abs(fixed a);
fixed1 abs(fixed1 a);
fixed2 abs(fixed2 a);
fixed3 abs(fixed3 a);
fixed4 abs(fixed4 a);


PARAMETERS

a Vector or scalar of which to determine the absolute value.


DESCRIPTION

Returns the absolute value of a scalar or vector.
For vectors, the returned vector contains the absolute value of each element of the input vector.


REFERENCE IMPLEMENTATION

abs for a float scalar could be implemented like this.
float abs(float a)
{
return max(-a, a);
}


PROFILE SUPPORT

abs is supported in all profiles.
Support in the fp20 is limited.
Consider abs to be free or extremely inexpensive.


SEE ALSO

max

		]]></description>
		<tool-tip><![CDATA[
			abs - returns absolute value of scalars and vectors.

		]]></tool-tip>
		<ports>
			<input name="a">
				<check-type method="list" target="*">
					half4,float4,half,half3,half1,fixed1,fixed4,float1,fixed3,fixed2,float3,float,fixed,half2,float2
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['float4'] = 'float4',
						['half2'] = 'half2',
						['half1'] = 'half1',
						['float'] = 'float',
						['float1'] = 'float1',
						['fixed2'] = 'fixed2',
						['fixed4'] = 'fixed4',
						['fixed3'] = 'fixed3',
						['float3'] = 'float3',
						['float2'] = 'float2',
						['fixed1'] = 'fixed1',
						['fixed'] = 'fixed',
						['half3'] = 'half3',
						['half4'] = 'half4',
						['half'] = 'half',
					}
					local types = node.a.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = abs( r${node.a.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="tex1DARRAYsize( samp, lod )">
		<description><![CDATA[
NAME

tex1DARRAYsize - returns the size of a given texture array image for a given level of detail.


SYNOPSIS

int3 tex1DARRAYsize(sampler1DARRAY samp, int lod)
int3 tex1DARRAYsize(isampler1DARRAY samp, int lod)
int3 tex1DARRAYsize(usampler1DARRAY samp, int lod)


PARAMETERS

samp Sampler to be queried for size.
lod Level of detail to obtain size.


DESCRIPTION

Given a sampler array and a level of detail the size of one element of the corresponding texture array for a
given level of detail is returned as a result of the operation.


REFERENCE IMPLEMENTATION



PROFILE SUPPORT

tex1DARRAYsize is only supported in gp4 and newer profiles.


SEE ALSO

tex1Dsize.de Sh
\$1

		]]></description>
		<tool-tip><![CDATA[
			tex1DARRAYsize - returns the size of a given texture array image for a given level of detail.

		]]></tool-tip>
		<ports>
			<input name="samp">
				<check-type method="list" target="*">
					usampler1DARRAY,sampler1DARRAY,isampler1DARRAY
				</check-type>
			</input>
			<input name="lod">
				<check-type method="list" target="*">
					int
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['isampler1DARRAY,int'] = 'int3',
						['usampler1DARRAY,int'] = 'int3',
						['sampler1DARRAY,int'] = 'int3',
					}
					local types = node.samp.get_type() .. ',' .. node.lod.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = tex1DARRAYsize( r${node.samp.get_source().uid()}, r${node.lod.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="tex1DARRAYlod( samp, s, texelOff )">
		<description><![CDATA[
NAME

tex1DARRAYlod - performs a texture lookup with a specified level of detail in a given sampler array.


SYNOPSIS

float4 tex1DARRAYlod(sampler1DARRAY samp, float4 s)
float4 tex1DARRAYlod(sampler1DARRAY samp, float4 s, int texelOff)
int4 tex1DARRAYlod(isampler1DARRAY samp, float4 s)
int4 tex1DARRAYlod(isampler1DARRAY samp, float4 s, int texelOff)
uint4 tex1DARRAYlod(usampler1DARRAY samp, float4 s)
uint4 tex1DARRAYlod(usampler1DARRAY samp, float4 s, int texelOff)


PARAMETERS

samp Sampler array to lookup.
s Coordinates to perform the lookup.The value used to select the layer should be passed in the
vector component right after the regular coordinates. The level of detail value should be passed as
the last component of the coordinate vector.
texelOff Offset to be added to obtain the final texel.


DESCRIPTION

Performs a texture lookup with a specified level of detail in sampler samp using coordinates s, the texture to
be sampled is selected from the layer specified in the coordinates.


REFERENCE IMPLEMENTATION



PROFILE SUPPORT

tex1DARRAYlod is only supported in gp4 and newer profiles.


SEE ALSO

tex1DARRAY, tex1DARRAYbias.de Sh
\$1

		]]></description>
		<tool-tip><![CDATA[
			tex1DARRAYlod - performs a texture lookup with a specified level of detail in a given sampler array.

		]]></tool-tip>
		<ports>
			<input name="samp">
				<check-type method="list" target="*">
					usampler1DARRAY,sampler1DARRAY,isampler1DARRAY
				</check-type>
			</input>
			<input name="s">
				<check-type method="list" target="*">
					float4
				</check-type>
			</input>
			<input name="texelOff">
				<check-type method="list" target="*">
					int
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['isampler1DARRAY,float4,int'] = 'int4',
						['sampler1DARRAY,float4,int'] = 'float4',
						['usampler1DARRAY,float4,int'] = 'uint4',
					}
					local types = node.samp.get_type() .. ',' .. node.s.get_type() .. ',' .. node.texelOff.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = tex1DARRAYlod( r${node.samp.get_source().uid()}, r${node.s.get_source().uid()}, r${node.texelOff.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="log( a )">
		<description><![CDATA[
NAME

log - returns the natural logarithm of scalars and vectors


SYNOPSIS

float log(float a);
float1 log(float1 a);
float2 log(float2 a);
float3 log(float3 a);
float4 log(float4 a);
half log(half a);
half1 log(half1 a);
half2 log(half2 a);
half3 log(half3 a);
half4 log(half4 a);
fixed log(fixed a);
fixed1 log(fixed1 a);
fixed2 log(fixed2 a);
fixed3 log(fixed3 a);
fixed4 log(fixed4 a);


PARAMETERS

a Vector or scalar of which to determine the natural logarithm.


DESCRIPTION

Returns the natural logarithm a.
For vectors, the returned vector contains the natural logarithm of each element of the input vector.


REFERENCE IMPLEMENTATION

float3 log(float3 a)
{
float3 rv;
int i;
for (i=0; i<3; i++) {
rv[i] = log(a[i]); // this is the ANSI C standard library log()
}
return rv;
}
log is typically implemented with a native base-2 logarithm instruction.


PROFILE SUPPORT

log is fully supported in all profiles unless otherwise specified.
Support in the fp20 is limited to constant compile-time evaluation.


SEE ALSO

exp, log10, log2, pow

		]]></description>
		<tool-tip><![CDATA[
			log - returns the natural logarithm of scalars and vectors

		]]></tool-tip>
		<ports>
			<input name="a">
				<check-type method="list" target="*">
					half4,float4,half,half3,half1,fixed1,fixed4,float1,fixed3,fixed2,float3,float,fixed,half2,float2
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['float4'] = 'float4',
						['half2'] = 'half2',
						['half1'] = 'half1',
						['float'] = 'float',
						['float1'] = 'float1',
						['fixed2'] = 'fixed2',
						['fixed4'] = 'fixed4',
						['fixed3'] = 'fixed3',
						['float3'] = 'float3',
						['float2'] = 'float2',
						['fixed1'] = 'fixed1',
						['fixed'] = 'fixed',
						['half3'] = 'half3',
						['half4'] = 'half4',
						['half'] = 'half',
					}
					local types = node.a.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = log( r${node.a.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="tex1DARRAYfetch( samp, s )">
		<description><![CDATA[
NAME

tex1DARRAYfetch - performs an unfiltered texture lookup in a given sampler array.


SYNOPSIS

float4 tex1DARRAYfetch(sampler1DARRAY samp, int4 s)
float4 tex1DARRAYfetch(sampler1DARRAY samp, int4 s, int texelOff)
int4 tex1DARRAYfetch(isampler1DARRAY samp, int4 s)
int4 tex1DARRAYfetch(isampler1DARRAY samp, int4 s, int texelOff)
uint4 tex1DARRAYfetch(usampler1DARRAY samp, int4 s)
uint4 tex1DARRAYfetch(usampler1DARRAY samp, int4 s, int texelOff)


PARAMETERS

samp Sampler array to lookup.
s Coordinates to perform the lookup, the layer is selected by the component right after the regular
coordinates, the level of detail is provided by the last component of the coordinate vector.
texelOff Offset to be added to obtain the final texel.


DESCRIPTION

Performs an unfiltered texture lookup in sampler array samp using coordinates s. The layer to be accessed is
selected by the component right after the regular coordinates, the level of detail is provided by the last
component of the coordinate vector. May use texel offset texelOff to compute final texel.


REFERENCE IMPLEMENTATION



PROFILE SUPPORT

tex1DARRAYfetch is only supported in gp4 and newer profiles.


SEE ALSO

tex1Dfetch.de Sh
\$1

		]]></description>
		<tool-tip><![CDATA[
			tex1DARRAYfetch - performs an unfiltered texture lookup in a given sampler array.

		]]></tool-tip>
		<ports>
			<input name="samp">
				<check-type method="list" target="*">
					usampler1DARRAY,sampler1DARRAY,isampler1DARRAY
				</check-type>
			</input>
			<input name="s">
				<check-type method="list" target="*">
					int4
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['sampler1DARRAY,int4'] = 'float4',
						['isampler1DARRAY,int4'] = 'int4',
						['usampler1DARRAY,int4'] = 'uint4',
					}
					local types = node.samp.get_type() .. ',' .. node.s.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = tex1DARRAYfetch( r${node.samp.get_source().uid()}, r${node.s.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="faceforward( N, I, Ng )">
		<description><![CDATA[
NAME

faceforward - returns a normal as-is if a vertex's eye-space position vector points in the opposite direction
of a geometric normal, otherwise return the negated version of the normal


SYNOPSIS

float faceforward(float N, float I, float Ng);
float1 faceforward(float1 N, float1 I, float1 Ng);
float2 faceforward(float2 N, float2 I, float2 Ng);
float3 faceforward(float3 N, float3 I, float3 Ng);
float4 faceforward(float4 N, float4 I, float4 Ng);
half faceforward(half N, half I, half Ng);
half1 faceforward(half1 N, half1 I, half1 Ng);
half2 faceforward(half2 N, half2 I, half2 Ng);
half3 faceforward(half3 N, half3 I, half3 Ng);
half4 faceforward(half4 N, half4 I, half4 Ng);
fixed faceforward(fixed N, fixed I, fixed Ng);
fixed1 faceforward(fixed1 N, fixed1 I, fixed1 Ng);
fixed2 faceforward(fixed2 N, fixed2 I, fixed2 Ng);
fixed3 faceforward(fixed3 N, fixed3 I, fixed3 Ng);
fixed4 faceforward(fixed4 N, fixed4 I, fixed4 Ng);


PARAMETERS

N Peturbed normal vector.
I Incidence vector (typically a direction vector from the eye to a vertex).
Ng Geometric normal vector (for some facet the peturbed normal belongs).


DESCRIPTION

Returns a (peturbed) normal as-is if a vertex's eye-space position vector points in the opposite direction of a
geometric normal, otherwise return the negated version of the (peturbed) normal
Mathematically, if the dot product of I and Ng is negative, N is returned unchanged; otherwise -N is
returned.
This function is inspired by a RenderMan funciton of the same name though the RenderMan version has
only two parameters.


REFERENCE IMPLEMENTATION

faceforward for float3 vectors could be implemented this way:
float3 faceforward( float3 N, float3 I, float Ng )
{
return dot(I, Ng) < 0 ? N : -N;
}


PROFILE SUPPORT

refract is supported in all profiles.


SEE ALSO

dot, reflect, refract, normalize

		]]></description>
		<tool-tip><![CDATA[
			faceforward - returns a normal as-is if a vertex's eye-space position vector points in the opposite direction
of a geometric normal, otherwise return the negated version of the normal

		]]></tool-tip>
		<ports>
			<input name="N">
				<check-type method="list" target="*">
					half4,float4,half,half3,half1,fixed1,fixed4,float1,fixed3,fixed2,float3,float,fixed,half2,float2
				</check-type>
			</input>
			<input name="I">
				<check-type method="list" target="*">
					half4,float4,half,half3,half1,fixed1,fixed4,float1,fixed3,fixed2,float3,float,fixed,half2,float2
				</check-type>
			</input>
			<input name="Ng">
				<check-type method="list" target="*">
					half4,float4,half,half3,half1,fixed1,fixed4,float1,fixed3,fixed2,float3,float,fixed,half2,float2
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['half3,half3,half3'] = 'half3',
						['fixed2,fixed2,fixed2'] = 'fixed2',
						['fixed4,fixed4,fixed4'] = 'fixed4',
						['half,half,half'] = 'half',
						['fixed3,fixed3,fixed3'] = 'fixed3',
						['float,float,float'] = 'float',
						['half2,half2,half2'] = 'half2',
						['fixed,fixed,fixed'] = 'fixed',
						['fixed1,fixed1,fixed1'] = 'fixed1',
						['float3,float3,float3'] = 'float3',
						['half1,half1,half1'] = 'half1',
						['half4,half4,half4'] = 'half4',
						['float4,float4,float4'] = 'float4',
						['float1,float1,float1'] = 'float1',
						['float2,float2,float2'] = 'float2',
					}
					local types = node.N.get_type() .. ',' .. node.I.get_type() .. ',' .. node.Ng.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = faceforward( r${node.N.get_source().uid()}, r${node.I.get_source().uid()}, r${node.Ng.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="texCUBE( samp, s )">
		<description><![CDATA[
NAME

texCUBE - performs a texture lookup in a given CUBE sampler and, in some cases, a shadow comparison.
May also use pre computed derivatives if those are provided.


SYNOPSIS

float4 texCUBE(samplerCUBE samp, float3 s)
float4 texCUBE(samplerCUBE samp, float4 s)
float4 texCUBE(samplerCUBE samp, float3 s, float3 dx, float3 dy)
float4 texCUBE(samplerCUBE samp, float4 s, float3 dx, float3 dy)
int4 texCUBE(isamplerCUBE samp, float3 s)
int4 texCUBE(isamplerCUBE samp, float3 s, float3 dx, float3 dy)
uint4 texCUBE(usamplerCUBE samp, float3 s)
uint4 texCUBE(usamplerCUBE samp, float3 s, float3 dx, float3 dy)


PARAMETERS

samp Sampler to lookup.
s Coordinates to perform the lookup. If an extra coordinate compared to the texture dimensionality
is present it is used to perform a shadow comparison. The value used in the shadow comparison is
always the last component of the coordinate vector.
dx Pre computed derivative along the x axis.
dy Pre computed derivative along the y axis.


DESCRIPTION

Performs a texture lookup in sampler samp using coordinates s, may use and derivatives dx and dy, also
may perform shadow comparison.


REFERENCE IMPLEMENTATION



PROFILE SUPPORT

texCUBE is supported in all fragment profiles and all vertex profiles starting with vp40, variants with
shadow comparison are only supported in gp4 and newer profiles. Variants with integer samplers are also
only suppported in gp4 and newer profiles.


SEE ALSO

texCUBEbias, texCUBElod, texCUBEproj

		]]></description>
		<tool-tip><![CDATA[
			texCUBE - performs a texture lookup in a given CUBE sampler and, in some cases, a shadow comparison.
May also use pre computed derivatives if those are provided.

		]]></tool-tip>
		<ports>
			<input name="samp">
				<check-type method="list" target="*">
					samplerCUBE,isamplerCUBE,usamplerCUBE
				</check-type>
			</input>
			<input name="s">
				<check-type method="list" target="*">
					float3,float4
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['usamplerCUBE,float3'] = 'uint4',
						['samplerCUBE,float4'] = 'float4',
						['isamplerCUBE,float3'] = 'int4',
						['samplerCUBE,float3'] = 'float4',
					}
					local types = node.samp.get_type() .. ',' .. node.s.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = texCUBE( r${node.samp.get_source().uid()}, r${node.s.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="determinant( A )">
		<description><![CDATA[
NAME

determinant - returns the scalar determinant of a square matrix


SYNOPSIS

float determinant(float1x1 A);
float determinant(float2x2 A);
float determinant(float3x3 A);
float determinant(float4x4 A);


PARAMETERS

A Square matrix of which to compute the determinant.


DESCRIPTION

Returns the determinant of the square matrix A.


REFERENCE IMPLEMENTATION

The various determinant functions can be implemented like this:
float determinant(float1x1 A)
{
return A._m00;
}
float determinant(float2x2 A)
{
return A._m00*A._m11 - A._m01*A._m10;
}
float determinant(float3x3 A)
{
return dot(A._m00_m01_m02,
A._m11_m12_m10 * A._m22_m20_m21
- A._m12_m10_m11 * A._m21_m22_m20);
}
float determinant(float4x4 A) {
return dot(float4(1,-1,1,-1) * A._m00_m01_m02_m03,
A._m11_m12_m13_m10*( A._m22_m23_m20_m21*A._m33_m30_m31_m32
- A._m23_m20_m21_m22*A._m32_m33_m30_m31)
+ A._m12_m13_m10_m11*( A._m23_m20_m21_m22*A._m31_m32_m33_m30
- A._m21_m22_m23_m20*A._m33_m30_m31_m32)
+ A._m13_m10_m11_m12*( A._m21_m22_m23_m20*A._m32_m33_m30_m31
- A._m22_m23_m20_m21*A._m31_m32_m33_m30));
}


PROFILE SUPPORT

determinant is supported in all profiles. However profiles such as fp20 and ps_2 without native floatingpoint
will have problems computing the larger determinants and may have ranges issues computing even
small determinants.


SEE ALSO

mul, transpose

		]]></description>
		<tool-tip><![CDATA[
			determinant - returns the scalar determinant of a square matrix

		]]></tool-tip>
		<ports>
			<input name="A">
				<check-type method="list" target="*">
					float4x4,float3x3,float2x2,float1x1
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['float2x2'] = 'float',
						['float3x3'] = 'float',
						['float4x4'] = 'float',
						['float1x1'] = 'float',
					}
					local types = node.A.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = determinant( r${node.A.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="tex1Dfetch( samp, s )">
		<description><![CDATA[
NAME

tex1Dfetch - performs an unfiltered texture lookup in a given sampler.


SYNOPSIS

float4 tex1Dfetch(sampler1D samp, int4 s)
float4 tex1Dfetch(sampler1D samp, int4 s, int texelOff)
int4 tex1Dfetch(isampler1D samp, int4 s)
int4 tex1Dfetch(isampler1D samp, int4 s, int texelOff)
uint4 tex1Dfetch(usampler1D samp, int4 s)
uint4 tex1Dfetch(usampler1D samp, int4 s, int texelOff)


PARAMETERS

samp Sampler to lookup.
s Coordinates to perform the lookup. The level of detail is stored in the last component of the
coordinate vector.
texelOff Offset to be added to obtain the final texel.


DESCRIPTION

Performs an unfiltered texture lookup in sampler samp using coordinates s. The level of detail is provided
by the last component of the coordinate vector. May use texel offset texelOff to compute final texel.


REFERENCE IMPLEMENTATION



PROFILE SUPPORT

tex1Dfetch is only supported in gp4 and newer profiles.


SEE ALSO

tex1D, tex1DARRAYfetch.de Sh
\$1

		]]></description>
		<tool-tip><![CDATA[
			tex1Dfetch - performs an unfiltered texture lookup in a given sampler.

		]]></tool-tip>
		<ports>
			<input name="samp">
				<check-type method="list" target="*">
					usampler1D,isampler1D,sampler1D
				</check-type>
			</input>
			<input name="s">
				<check-type method="list" target="*">
					int4
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['isampler1D,int4'] = 'int4',
						['usampler1D,int4'] = 'uint4',
						['sampler1D,int4'] = 'float4',
					}
					local types = node.samp.get_type() .. ',' .. node.s.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = tex1Dfetch( r${node.samp.get_source().uid()}, r${node.s.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="tex2Dcmpbias( samp, s )">
		<description><![CDATA[
NAME

tex2Dcmpbias - performs a texture lookup with bias and shadow compare in a given sampler.


SYNOPSIS

float4 tex2Dcmpbias(sampler2D samp, float4 s)
float4 tex2Dcmpbias(sampler2D samp, float4 s, int texelOff)


PARAMETERS

samp Sampler to lookup.
s Coordinates to perform the lookup. The value used in the shadow comparison should be passed
right after the normal coordinates. The bias value should be passed as the last component of the
coordinate vector.
texelOff Offset to be added to obtain the final texel.


DESCRIPTION

Performs a texture lookup with shadow compare and bias in sampler samp using coordinates s.


REFERENCE IMPLEMENTATION



PROFILE SUPPORT

tex2Dcmpbias is supported in fragment profiles starting with fp40 and in vertex profiles starting with vp40.
Variants with texelOff are only supported in gp4 and newer profiles.


SEE ALSO

tex2Dcmplod, tex2Dbias.de Sh
\$1

		]]></description>
		<tool-tip><![CDATA[
			tex2Dcmpbias - performs a texture lookup with bias and shadow compare in a given sampler.

		]]></tool-tip>
		<ports>
			<input name="samp">
				<check-type method="list" target="*">
					sampler2D
				</check-type>
			</input>
			<input name="s">
				<check-type method="list" target="*">
					float4
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['sampler2D,float4'] = 'float4',
					}
					local types = node.samp.get_type() .. ',' .. node.s.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = tex2Dcmpbias( r${node.samp.get_source().uid()}, r${node.s.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="tex2Dlod( samp, s, texelOff )">
		<description><![CDATA[
NAME

tex2Dlod - performs a texture lookup with a specified level of detail in a given sampler.


SYNOPSIS

float4 tex2Dlod(sampler2D samp, float4 s)
float4 tex2Dlod(sampler2D samp, float4 s, int texelOff)
int4 tex2Dlod(isampler2D samp, float4 s)
int4 tex2Dlod(isampler2D samp, float4 s, int texelOff)
uint4 tex2Dlod(usampler2D samp, float4 s)
uint4 tex2Dlod(usampler2D samp, float4 s, int texelOff)


PARAMETERS

samp Sampler to lookup.
s Coordinates to perform the lookup. The level of detail should be passed as the last component of
the coordinate vector.
texelOff Offset to be added to obtain the final texel.


DESCRIPTION

Performs a texture lookup with a specified level of detail in sampler samp using coordinates s.


REFERENCE IMPLEMENTATION



PROFILE SUPPORT

tex2Dlod is supported in fragment profiles starting with fp40 and in vertex profiles starting with vp40.
Variants with texelOff are only supported in gp4 and newer profiles. Variants with integer samplers are also
only suppported in gp4 and newer profiles.


SEE ALSO

tex2Dbias, tex2Dcmplod.de Sh
\$1

		]]></description>
		<tool-tip><![CDATA[
			tex2Dlod - performs a texture lookup with a specified level of detail in a given sampler.

		]]></tool-tip>
		<ports>
			<input name="samp">
				<check-type method="list" target="*">
					sampler2D,isampler2D,usampler2D
				</check-type>
			</input>
			<input name="s">
				<check-type method="list" target="*">
					float4
				</check-type>
			</input>
			<input name="texelOff">
				<check-type method="list" target="*">
					int
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['usampler2D,float4,int'] = 'uint4',
						['isampler2D,float4,int'] = 'int4',
						['sampler2D,float4,int'] = 'float4',
					}
					local types = node.samp.get_type() .. ',' .. node.s.get_type() .. ',' .. node.texelOff.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = tex2Dlod( r${node.samp.get_source().uid()}, r${node.s.get_source().uid()}, r${node.texelOff.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="tex1Dlod( samp, s, texelOff )">
		<description><![CDATA[
NAME

tex1Dlod - performs a texture lookup with a specified level of detail in a given sampler.


SYNOPSIS

float4 tex1Dlod(sampler1D samp, float4 s)
float4 tex1Dlod(sampler1D samp, float4 s, int texelOff)
int4 tex1Dlod(isampler1D samp, float4 s)
int4 tex1Dlod(isampler1D samp, float4 s, int texelOff)
uint4 tex1Dlod(usampler1D samp, float4 s)
uint4 tex1Dlod(usampler1D samp, float4 s, int texelOff)


PARAMETERS

samp Sampler to lookup.
s Coordinates to perform the lookup. The level of detail should be passed as the last component of
the coordinate vector.
texelOff Offset to be added to obtain the final texel.


DESCRIPTION

Performs a texture lookup with a specified level of detail in sampler samp using coordinates s.


REFERENCE IMPLEMENTATION



PROFILE SUPPORT

tex1Dlod is supported in fragment profiles starting with fp40 and in vertex profiles starting with vp40.
Variants with texelOff are only supported in gp4 and newer profiles. Variants with integer samplers are also
only suppported in gp4 and newer profiles.


SEE ALSO

tex1Dbias, tex1Dcmplod.de Sh
\$1

		]]></description>
		<tool-tip><![CDATA[
			tex1Dlod - performs a texture lookup with a specified level of detail in a given sampler.

		]]></tool-tip>
		<ports>
			<input name="samp">
				<check-type method="list" target="*">
					usampler1D,isampler1D,sampler1D
				</check-type>
			</input>
			<input name="s">
				<check-type method="list" target="*">
					float4
				</check-type>
			</input>
			<input name="texelOff">
				<check-type method="list" target="*">
					int
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['sampler1D,float4,int'] = 'float4',
						['isampler1D,float4,int'] = 'int4',
						['usampler1D,float4,int'] = 'uint4',
					}
					local types = node.samp.get_type() .. ',' .. node.s.get_type() .. ',' .. node.texelOff.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = tex1Dlod( r${node.samp.get_source().uid()}, r${node.s.get_source().uid()}, r${node.texelOff.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="tex1DARRAY( samp, s, dx, dy, texelOff )">
		<description><![CDATA[
NAME

tex1DARRAY - performs a texture lookup in a given sampler array may use pre computed derivatives and,
in some cases, perform a shadow comparison.


SYNOPSIS

float4 tex1DARRAY(sampler1DARRAY samp, float2 s)
float4 tex1DARRAY(sampler1DARRAY samp, float2 s, int texelOff)
float4 tex1DARRAY(sampler1DARRAY samp, float3 s)
float4 tex1DARRAY(sampler1DARRAY samp, float3 s, int texelOff)
float4 tex1DARRAY(sampler1DARRAY samp, float2 s, float dx, float dy)
float4 tex1DARRAY(sampler1DARRAY samp, float2 s, float dx, float dy,int texelOff)
float4 tex1DARRAY(sampler1DARRAY samp, float3 s, float dx, float dy)
float4 tex1DARRAY(sampler1DARRAY samp, float3 s, float dx, float dy,int texelOff)
int4 tex1DARRAY(isampler1DARRAY samp, float2 s)
int4 tex1DARRAY(isampler1DARRAY samp, float2 s, int texelOff)
int4 tex1DARRAY(isampler1DARRAY samp, float2 s, float dx, float dy)
int4 tex1DARRAY(isampler1DARRAY samp, float2 s, float dx, float dy,int texelOff)
uint4 tex1DARRAY(usampler1DARRAY samp, float2 s)
uint4 tex1DARRAY(usampler1DARRAY samp, float2 s, int texelOff)
uint4 tex1DARRAY(usampler1DARRAY samp, float2 s, float dx, float dy)
uint4 tex1DARRAY(usampler1DARRAY samp, float2 s, float dx, float dy,int texelOff)


PARAMETERS

samp Sampler array to look up.
s Coordinates to perform the lookup. The value used to select the layer is passed immediatelly after
the regular coordinates, if an extra coordinate is present it is used to perform a shadow
comparison.
dx Pre computed derivative along the x axis.
dy Pre computed derivative along the y axis.
texelOff Offset to be added to obtain the final texel.


DESCRIPTION

Performs a texture lookup in sampler samp using coordinates s, the texture to be sampled is selected from
the layer specified in the coordinates. Also may use the derivatives dx and dy, the lookup may involve a
shadow comparison and use texel offset texelOff to compute the final texel.


REFERENCE IMPLEMENTATION



PROFILE SUPPORT

tex1DARRAY is only supported in gp4 and newer profiles.


SEE ALSO

tex1DARRAYbias, tex1DARRAYlod

		]]></description>
		<tool-tip><![CDATA[
			tex1DARRAY - performs a texture lookup in a given sampler array may use pre computed derivatives and,
in some cases, perform a shadow comparison.

		]]></tool-tip>
		<ports>
			<input name="samp">
				<check-type method="list" target="*">
					usampler1DARRAY,sampler1DARRAY,isampler1DARRAY
				</check-type>
			</input>
			<input name="s">
				<check-type method="list" target="*">
					float3,float2
				</check-type>
			</input>
			<input name="dx">
				<check-type method="list" target="*">
					float
				</check-type>
			</input>
			<input name="dy">
				<check-type method="list" target="*">
					float
				</check-type>
			</input>
			<input name="texelOff">
				<check-type method="list" target="*">
					int
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['isampler1DARRAY,float2,float,float,int'] = 'int4',
						['sampler1DARRAY,float3,float,float,int'] = 'float4',
						['sampler1DARRAY,float2,float,float,int'] = 'float4',
						['usampler1DARRAY,float2,float,float,int'] = 'uint4',
					}
					local types = node.samp.get_type() .. ',' .. node.s.get_type() .. ',' .. node.dx.get_type() .. ',' .. node.dy.get_type() .. ',' .. node.texelOff.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = tex1DARRAY( r${node.samp.get_source().uid()}, r${node.s.get_source().uid()}, r${node.dx.get_source().uid()}, r${node.dy.get_source().uid()}, r${node.texelOff.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="tex2Dsize( samp, lod )">
		<description><![CDATA[
NAME

tex2Dsize - returns the size of a given texture image for a given level of detail.


SYNOPSIS

int3 tex2Dsize(sampler2D samp, int lod)
int3 tex2Dsize(isampler2D samp, int lod)
int3 tex2Dsize(usampler2D samp, int lod)


PARAMETERS

samp Sampler to be queried for size.
lod Level of detail to obtain size.


DESCRIPTION

Given a sampler and a level of detail the size of the corresponding texture image is returned as the result of
the operation.


REFERENCE IMPLEMENTATION



PROFILE SUPPORT

tex2Dsize is only supported in gp4 and newer profiles.


SEE ALSO

tex2D, tex2DARRAYsize.de Sh
\$1

		]]></description>
		<tool-tip><![CDATA[
			tex2Dsize - returns the size of a given texture image for a given level of detail.

		]]></tool-tip>
		<ports>
			<input name="samp">
				<check-type method="list" target="*">
					sampler2D,isampler2D,usampler2D
				</check-type>
			</input>
			<input name="lod">
				<check-type method="list" target="*">
					int
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['isampler2D,int'] = 'int3',
						['usampler2D,int'] = 'int3',
						['sampler2D,int'] = 'int3',
					}
					local types = node.samp.get_type() .. ',' .. node.lod.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = tex2Dsize( r${node.samp.get_source().uid()}, r${node.lod.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="tex2D( samp, s, dx, dy, texelOff )">
		<description><![CDATA[
NAME

tex2D - performs a texture lookup in a given 2D sampler and, in some cases, a shadow comparison. May
also use pre computed derivatives if those are provided.


SYNOPSIS

float4 tex2D(sampler2D samp, float2 s)
float4 tex2D(sampler2D samp, float2 s, int texelOff)
float4 tex2D(sampler2D samp, float3 s)
float4 tex2D(sampler2D samp, float3 s, int texelOff)
float4 tex2D(sampler2D samp, float2 s, float2 dx, float2 dy)
float4 tex2D(sampler2D samp, float2 s, float2 dx, float2 dy, int texelOff)
float4 tex2D(sampler2D samp, float3 s, float2 dx, float2 dy)
float4 tex2D(sampler2D samp, float3 s, float2 dx, float2 dy, int texelOff)
int4 tex2D(isampler2D samp, float2 s)
int4 tex2D(isampler2D samp, float2 s, int texelOff)
int4 tex2D(isampler2D samp, float2 s, float2 dx, float2 dy)
int4 tex2D(isampler2D samp, float2 s, float2 dx, float2 dy, int texelOff)
uint4 tex2D(usampler2D samp, float2 s)
uint4 tex2D(usampler2D samp, float2 s, int texelOff)
uint4 tex2D(usampler2D samp, float2 s, float2 dx, float2 dy)
uint4 tex2D(usampler2D samp, float2 s, float2 dx, float2 dy,int texelOff)


PARAMETERS

samp Sampler to lookup.
s Coordinates to perform the lookup. If an extra coordinate compared to the texture dimensionality
is present it is used to perform a shadow comparison. The value used in the shadow comparison is
always the last component of the coordinate vector.
dx Pre computed derivative along the x axis.
dy Pre computed derivative along the y axis.
texelOff Offset to be added to obtain the final texel.


DESCRIPTION

Performs a texture lookup in sampler samp using coordinates s, may use and derivatives dx and dy, also
may perform shadow comparison and use texel offset texelOff to compute final texel.


REFERENCE IMPLEMENTATION



PROFILE SUPPORT

tex2D is supported in all fragment profiles and all vertex profiles starting with vp40, variants with shadow
comparison are only supported in fp40 and newer profiles, variants with texel offsets are only supported in
gp4 and newer profiles. Variants with integer textures are also only supported in gp4 and newer profiles.


SEE ALSO

tex2Dbias, tex2Dlod, tex2Dproj

		]]></description>
		<tool-tip><![CDATA[
			tex2D - performs a texture lookup in a given 2D sampler and, in some cases, a shadow comparison. May
also use pre computed derivatives if those are provided.

		]]></tool-tip>
		<ports>
			<input name="samp">
				<check-type method="list" target="*">
					sampler2D,isampler2D,usampler2D
				</check-type>
			</input>
			<input name="s">
				<check-type method="list" target="*">
					float3,float2
				</check-type>
			</input>
			<input name="dx">
				<check-type method="list" target="*">
					float2
				</check-type>
			</input>
			<input name="dy">
				<check-type method="list" target="*">
					float2
				</check-type>
			</input>
			<input name="texelOff">
				<check-type method="list" target="*">
					int
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['usampler2D,float2,float2,float2,int'] = 'uint4',
						['isampler2D,float2,float2,float2,int'] = 'int4',
						['sampler2D,float2,float2,float2,int'] = 'float4',
						['sampler2D,float3,float2,float2,int'] = 'float4',
					}
					local types = node.samp.get_type() .. ',' .. node.s.get_type() .. ',' .. node.dx.get_type() .. ',' .. node.dy.get_type() .. ',' .. node.texelOff.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = tex2D( r${node.samp.get_source().uid()}, r${node.s.get_source().uid()}, r${node.dx.get_source().uid()}, r${node.dy.get_source().uid()}, r${node.texelOff.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="texCUBEbias( samp, s )">
		<description><![CDATA[
NAME

texCUBEbias - performs a texture lookup with bias in a given sampler.


SYNOPSIS

float4 texCUBEbias(samplerCUBE samp, float4 s)
int4 texCUBEbias(isamplerCUBE samp, float4 s)
uint4 texCUBEbias(usamplerCUBE samp, float4 s)


PARAMETERS

samp Sampler to lookup.
s Coordinates to perform the lookup. The bias value should be passed as the last component of the
coordinate vector.
texelOff Offset to be added to obtain the final texel.


DESCRIPTION

Performs a texture lookup with bias in sampler samp using coordinates s.


REFERENCE IMPLEMENTATION



PROFILE SUPPORT

texCUBEbias is supported in fragment profiles starting with fp30 and in vertex profiles starting with vp40.
Variants with integer samplers are only supported in gp4 and newer profiles.


SEE ALSO

texCUBElod.de Sh
\$1

		]]></description>
		<tool-tip><![CDATA[
			texCUBEbias - performs a texture lookup with bias in a given sampler.

		]]></tool-tip>
		<ports>
			<input name="samp">
				<check-type method="list" target="*">
					samplerCUBE,isamplerCUBE,usamplerCUBE
				</check-type>
			</input>
			<input name="s">
				<check-type method="list" target="*">
					float4
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['isamplerCUBE,float4'] = 'int4',
						['usamplerCUBE,float4'] = 'uint4',
						['samplerCUBE,float4'] = 'float4',
					}
					local types = node.samp.get_type() .. ',' .. node.s.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = texCUBEbias( r${node.samp.get_source().uid()}, r${node.s.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="acos( a )">
		<description><![CDATA[
NAME

acos - returns arccosine of scalars and vectors.


SYNOPSIS

float acos(float a);
float1 acos(float1 a);
float2 acos(float2 a);
float3 acos(float3 a);
float4 acos(float4 a);
half acos(half a);
half1 acos(half1 a);
half2 acos(half2 a);
half3 acos(half3 a);
half4 acos(half4 a);
fixed acos(fixed a);
fixed1 acos(fixed1 a);
fixed2 acos(fixed2 a);
fixed3 acos(fixed3 a);
fixed4 acos(fixed4 a);


PARAMETERS

a Vector or scalar of which to determine the arccosine.


DESCRIPTION

Returns the arccosine of a in the range [0,pi], expecting a to be in the range [-1,+1].
For vectors, the returned vector contains the arccosine of each element of the input vector.


REFERENCE IMPLEMENTATION

acos for a float scalar could be implemented like this.
// Handbook of Mathematical Functions
// M. Abramowitz and I.A. Stegun, Ed.
// Absolute error <= 6.7e-5
float acos(float x) {
float negate = float(x < 0);
x = abs(x);
float ret = -0.0187293;
ret = ret * x;
ret = ret + 0.0742610;
ret = ret * x;
ret = ret - 0.2121144;
ret = ret * x;
ret = ret + 1.5707288;
ret = ret * sqrt(1.0-x);
ret = ret - 2 * negate * ret;
return negate * 3.14159265358979 + ret;
}


PROFILE SUPPORT

acos is supported in all profiles.
Support in the fp20 is limited.


SEE ALSO

abs, asin, cos, sqrt

		]]></description>
		<tool-tip><![CDATA[
			acos - returns arccosine of scalars and vectors.

		]]></tool-tip>
		<ports>
			<input name="a">
				<check-type method="list" target="*">
					half4,float4,half,half3,half1,fixed1,fixed4,float1,fixed3,fixed2,float3,float,fixed,half2,float2
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['float4'] = 'float4',
						['half2'] = 'half2',
						['half1'] = 'half1',
						['float'] = 'float',
						['float1'] = 'float1',
						['fixed2'] = 'fixed2',
						['fixed4'] = 'fixed4',
						['fixed3'] = 'fixed3',
						['float3'] = 'float3',
						['float2'] = 'float2',
						['fixed1'] = 'fixed1',
						['fixed'] = 'fixed',
						['half3'] = 'half3',
						['half4'] = 'half4',
						['half'] = 'half',
					}
					local types = node.a.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = acos( r${node.a.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="tex1DARRAY( samp, s, texelOff )">
		<description><![CDATA[
NAME

tex1DARRAY - performs a texture lookup in a given sampler array may use pre computed derivatives and,
in some cases, perform a shadow comparison.


SYNOPSIS

float4 tex1DARRAY(sampler1DARRAY samp, float2 s)
float4 tex1DARRAY(sampler1DARRAY samp, float2 s, int texelOff)
float4 tex1DARRAY(sampler1DARRAY samp, float3 s)
float4 tex1DARRAY(sampler1DARRAY samp, float3 s, int texelOff)
float4 tex1DARRAY(sampler1DARRAY samp, float2 s, float dx, float dy)
float4 tex1DARRAY(sampler1DARRAY samp, float2 s, float dx, float dy,int texelOff)
float4 tex1DARRAY(sampler1DARRAY samp, float3 s, float dx, float dy)
float4 tex1DARRAY(sampler1DARRAY samp, float3 s, float dx, float dy,int texelOff)
int4 tex1DARRAY(isampler1DARRAY samp, float2 s)
int4 tex1DARRAY(isampler1DARRAY samp, float2 s, int texelOff)
int4 tex1DARRAY(isampler1DARRAY samp, float2 s, float dx, float dy)
int4 tex1DARRAY(isampler1DARRAY samp, float2 s, float dx, float dy,int texelOff)
uint4 tex1DARRAY(usampler1DARRAY samp, float2 s)
uint4 tex1DARRAY(usampler1DARRAY samp, float2 s, int texelOff)
uint4 tex1DARRAY(usampler1DARRAY samp, float2 s, float dx, float dy)
uint4 tex1DARRAY(usampler1DARRAY samp, float2 s, float dx, float dy,int texelOff)


PARAMETERS

samp Sampler array to look up.
s Coordinates to perform the lookup. The value used to select the layer is passed immediatelly after
the regular coordinates, if an extra coordinate is present it is used to perform a shadow
comparison.
dx Pre computed derivative along the x axis.
dy Pre computed derivative along the y axis.
texelOff Offset to be added to obtain the final texel.


DESCRIPTION

Performs a texture lookup in sampler samp using coordinates s, the texture to be sampled is selected from
the layer specified in the coordinates. Also may use the derivatives dx and dy, the lookup may involve a
shadow comparison and use texel offset texelOff to compute the final texel.


REFERENCE IMPLEMENTATION



PROFILE SUPPORT

tex1DARRAY is only supported in gp4 and newer profiles.


SEE ALSO

tex1DARRAYbias, tex1DARRAYlod

		]]></description>
		<tool-tip><![CDATA[
			tex1DARRAY - performs a texture lookup in a given sampler array may use pre computed derivatives and,
in some cases, perform a shadow comparison.

		]]></tool-tip>
		<ports>
			<input name="samp">
				<check-type method="list" target="*">
					usampler1DARRAY,sampler1DARRAY,isampler1DARRAY
				</check-type>
			</input>
			<input name="s">
				<check-type method="list" target="*">
					float3,float2
				</check-type>
			</input>
			<input name="texelOff">
				<check-type method="list" target="*">
					int
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['usampler1DARRAY,float2,int'] = 'uint4',
						['sampler1DARRAY,float2,int'] = 'float4',
						['isampler1DARRAY,float2,int'] = 'int4',
						['sampler1DARRAY,float3,int'] = 'float4',
					}
					local types = node.samp.get_type() .. ',' .. node.s.get_type() .. ',' .. node.texelOff.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = tex1DARRAY( r${node.samp.get_source().uid()}, r${node.s.get_source().uid()}, r${node.texelOff.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="tex2Dproj( samp, s )">
		<description><![CDATA[
NAME

tex2Dproj - performs a texture lookup with projection in a given sampler. May perform a shadow
comparison if argument for shadow comparison is provided.


SYNOPSIS

float4 tex2Dproj(sampler2D samp, float3 s)
float4 tex2Dproj(sampler2D samp, float3 s, int texelOff)
float4 tex2Dproj(sampler2D samp, float4 s)
float4 tex2Dproj(sampler2D samp, float4 s, int texelOff)
int4 tex2Dproj(isampler2D samp, float3 s)
int4 tex2Dproj(isampler2D samp, float3 s, int texelOff)
uint4 tex2Dproj(usampler2D samp, float3 s)
uint4 tex2Dproj(usampler2D samp, float3 s, int texelOff)


PARAMETERS

samp Sampler to lookup.
s Coordinates to perform the lookup. The value used in the projection should be passed as the last
component of the coordinate vector. The value used in the shadow comparison, if present, should
be passed as the next-to-last component of the coordinate vector.
texelOff Offset to be added to obtain the final texel.


DESCRIPTION

Performs a texture lookup in sampler samp using coordinates s, the coordinates used in the lookup are first
projected, that is, divided by the last component of the coordinate vector and them used in the lookup. If an
extra coordinate is present it is used to perform a shadow comparison, the value used in the shadow
comparison is always the next-to-last component in the coordinate vector.


REFERENCE IMPLEMENTATION



PROFILE SUPPORT

tex2Dproj is supported in all fragment profiles and all vertex profiles starting with vp40, variants with
shadow comparison are only supported in fp40 and newer profiles, variants with texel offsets are only
supported in gp4 and newer profiles.


SEE ALSO

tex2D, tex2DARRAYproj

		]]></description>
		<tool-tip><![CDATA[
			tex2Dproj - performs a texture lookup with projection in a given sampler. May perform a shadow
comparison if argument for shadow comparison is provided.

		]]></tool-tip>
		<ports>
			<input name="samp">
				<check-type method="list" target="*">
					sampler2D,isampler2D,usampler2D
				</check-type>
			</input>
			<input name="s">
				<check-type method="list" target="*">
					float3,float4
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['sampler2D,float3'] = 'float4',
						['usampler2D,float3'] = 'uint4',
						['sampler2D,float4'] = 'float4',
						['isampler2D,float3'] = 'int4',
					}
					local types = node.samp.get_type() .. ',' .. node.s.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = tex2Dproj( r${node.samp.get_source().uid()}, r${node.s.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="tex2DARRAY( samp, s )">
		<description><![CDATA[
NAME

tex2DARRAY - performs a texture lookup in a given sampler array may use pre computed derivatives and,
in some cases, perform a shadow comparison.


SYNOPSIS

float4 tex2DARRAY(sampler2DARRAY samp, float3 s)
float4 tex2DARRAY(sampler2DARRAY samp, float3 s, int texelOff)
float4 tex2DARRAY(sampler2DARRAY samp, float4 s)
float4 tex2DARRAY(sampler2DARRAY samp, float4 s, int texelOff)
float4 tex2DARRAY(sampler2DARRAY samp, float3 s, float dx, float dy)
float4 tex2DARRAY(sampler2DARRAY samp, float3 s, float dx, float dy,int texelOff)
float4 tex2DARRAY(sampler2DARRAY samp, float4 s, float dx, float dy)
float4 tex2DARRAY(sampler2DARRAY samp, float4 s, float dx, float dy,int texelOff)
int4 tex2DARRAY(isampler2DARRAY samp, float3 s)
int4 tex2DARRAY(isampler2DARRAY samp, float3 s, int texelOff)
int4 tex2DARRAY(isampler2DARRAY samp, float3 s, float dx, float dy)
int4 tex2DARRAY(isampler2DARRAY samp, float3 s, float dx, float dy,int texelOff)
uint4 tex2DARRAY(usampler2DARRAY samp, float3 s)
uint4 tex2DARRAY(usampler2DARRAY samp, float3 s, int texelOff)
uint4 tex2DARRAY(usampler2DARRAY samp, float3 s, float dx, float dy)
uint4 tex2DARRAY(usampler2DARRAY samp, float3 s, float dx, float dy,int texelOff)


PARAMETERS

samp Sampler array to look up.
s Coordinates to perform the lookup. The value used to select the layer is passed immediatelly after
the regular coordinates, if an extra coordinate is present it is used to perform a shadow
comparison.
dx Pre computed derivative along the x axis.
dy Pre computed derivative along the y axis.
texelOff Offset to be added to obtain the final texel.


DESCRIPTION

Performs a texture lookup in sampler samp using coordinates s, the texture to be sampled is selected from
the layer specified in the coordinates. Also may use the derivatives dx and dy, the lookup may involve a
shadow comparison and use texel offset texelOff to compute the final texel.


REFERENCE IMPLEMENTATION



PROFILE SUPPORT

tex2DARRAY is only supported in gp4 and newer profiles.


SEE ALSO

tex2DARRAYbias, tex2DARRAYlod

		]]></description>
		<tool-tip><![CDATA[
			tex2DARRAY - performs a texture lookup in a given sampler array may use pre computed derivatives and,
in some cases, perform a shadow comparison.

		]]></tool-tip>
		<ports>
			<input name="samp">
				<check-type method="list" target="*">
					usampler2DARRAY,isampler2DARRAY,sampler2DARRAY
				</check-type>
			</input>
			<input name="s">
				<check-type method="list" target="*">
					float3,float4
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['usampler2DARRAY,float3'] = 'uint4',
						['isampler2DARRAY,float3'] = 'int4',
						['sampler2DARRAY,float4'] = 'float4',
						['sampler2DARRAY,float3'] = 'float4',
					}
					local types = node.samp.get_type() .. ',' .. node.s.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = tex2DARRAY( r${node.samp.get_source().uid()}, r${node.s.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="tex2DARRAYfetch( samp, s, texelOff )">
		<description><![CDATA[
NAME

tex2DARRAYfetch - performs an unfiltered texture lookup in a given sampler array.


SYNOPSIS

float4 tex2DARRAYfetch(sampler2DARRAY samp, int4 s)
float4 tex2DARRAYfetch(sampler2DARRAY samp, int4 s, int texelOff)
int4 tex2DARRAYfetch(isampler2DARRAY samp, int4 s)
int4 tex2DARRAYfetch(isampler2DARRAY samp, int4 s, int texelOff)
uint4 tex2DARRAYfetch(usampler2DARRAY samp, int4 s)
uint4 tex2DARRAYfetch(usampler2DARRAY samp, int4 s, int texelOff)


PARAMETERS

samp Sampler array to lookup.
s Coordinates to perform the lookup, the layer is selected by the component right after the regular
coordinates, the level of detail is provided by the last component of the coordinate vector.
texelOff Offset to be added to obtain the final texel.


DESCRIPTION

Performs an unfiltered texture lookup in sampler array samp using coordinates s. The layer to be accessed is
selected by the component right after the regular coordinates, the level of detail is provided by the last
component of the coordinate vector. May use texel offset texelOff to compute final texel.


REFERENCE IMPLEMENTATION



PROFILE SUPPORT

tex2DARRAYfetch is only supported in gp4 and newer profiles.


SEE ALSO

tex2Dfetch.de Sh
\$1

		]]></description>
		<tool-tip><![CDATA[
			tex2DARRAYfetch - performs an unfiltered texture lookup in a given sampler array.

		]]></tool-tip>
		<ports>
			<input name="samp">
				<check-type method="list" target="*">
					usampler2DARRAY,isampler2DARRAY,sampler2DARRAY
				</check-type>
			</input>
			<input name="s">
				<check-type method="list" target="*">
					int4
				</check-type>
			</input>
			<input name="texelOff">
				<check-type method="list" target="*">
					int
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['isampler2DARRAY,int4,int'] = 'int4',
						['usampler2DARRAY,int4,int'] = 'uint4',
						['sampler2DARRAY,int4,int'] = 'float4',
					}
					local types = node.samp.get_type() .. ',' .. node.s.get_type() .. ',' .. node.texelOff.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = tex2DARRAYfetch( r${node.samp.get_source().uid()}, r${node.s.get_source().uid()}, r${node.texelOff.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="tex3Dbias( samp, s )">
		<description><![CDATA[
NAME

tex3Dbias - performs a texture lookup with bias in a given sampler.


SYNOPSIS

float4 tex3Dbias(sampler3D samp, float4 s)
float4 tex3Dbias(sampler3D samp, float4 s, int texelOff)
int4 tex3Dbias(isampler3D samp, float4 s)
int4 tex3Dbias(isampler3D samp, float4 s, int texelOff)
uint4 tex3Dbias(usampler3D samp, float4 s)
uint4 tex3Dbias(usampler3D samp, float4 s, int texelOff)


PARAMETERS

samp Sampler to lookup.
s Coordinates to perform the lookup. The bias value should be passed as the last component of the
coordinate vector.
texelOff Offset to be added to obtain the final texel.


DESCRIPTION

Performs a texture lookup with bias in sampler samp using coordinates s.


REFERENCE IMPLEMENTATION



PROFILE SUPPORT

tex3Dbias is supported in fragment profiles starting with fp30 and in vertex profiles starting with vp40.
Variants with texelOff are only supported in gp4 and newer profiles. Variants with integer samplers are also
only suppported in gp4 and newer profiles.


SEE ALSO

tex3Dlod.de Sh
\$1

		]]></description>
		<tool-tip><![CDATA[
			tex3Dbias - performs a texture lookup with bias in a given sampler.

		]]></tool-tip>
		<ports>
			<input name="samp">
				<check-type method="list" target="*">
					sampler3D,usampler3D,isampler3D
				</check-type>
			</input>
			<input name="s">
				<check-type method="list" target="*">
					float4
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['sampler3D,float4'] = 'float4',
						['usampler3D,float4'] = 'uint4',
						['isampler3D,float4'] = 'int4',
					}
					local types = node.samp.get_type() .. ',' .. node.s.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = tex3Dbias( r${node.samp.get_source().uid()}, r${node.s.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="tex1DARRAYproj( samp, s )">
		<description><![CDATA[
NAME

tex1DARRAYproj - performs a texture lookup with projection in a given sampler array. May perform a
shadow comparison if argument for shadow comparison is provided.


SYNOPSIS

float4 tex1DARRAYproj(sampler1DARRAY samp, float3 s)
float4 tex1DARRAYproj(sampler1DARRAY samp, float3 s, int texelOff)
float4 tex1DARRAYproj(sampler1DARRAY samp, float4 s)
float4 tex1DARRAYproj(sampler1DARRAY samp, float4 s, int texelOff)
int4 tex1DARRAYproj(isampler1DARRAY samp, float3 s)
int4 tex1DARRAYproj(isampler1DARRAY samp, float3 s, int texelOff)
uint4 tex1DARRAYproj(usampler1DARRAY samp, float3 s)
uint4 tex1DARRAYproj(usampler1DARRAY samp, float3 s, int texelOff)


PARAMETERS

samp Sampler array to lookup.
s Coordinates to perform the lookup. The value used to select the layer should be passed as the
component right after the lookup coordinates. The value used in the projection should be passed
as the last component of the coordinate vector. The value used in the shadow comparison, if
present, should be passed as the next-to-last component of the coordinate vector.
texelOff Offset to be added to obtain the final texel.


DESCRIPTION

Performs a texture lookup in sampler array samp using coordinates s, the layer used in the lookup is first
selected using the coordinate component right after the regular coordinates. The coordinates used in the
lookup are then projected, that is, divided by the last component of the coordinate vector and them used in
the lookup. If an extra coordinate is present it is used to perform a shadow comparison, the value used in
the shadow comparison is always the next-to-last component in the coordinate vector.


REFERENCE IMPLEMENTATION



PROFILE SUPPORT

tex1DARRAYproj is only supported in gp4 and newer profiles.


SEE ALSO

tex1D, tex1Dproj

		]]></description>
		<tool-tip><![CDATA[
			tex1DARRAYproj - performs a texture lookup with projection in a given sampler array. May perform a
shadow comparison if argument for shadow comparison is provided.

		]]></tool-tip>
		<ports>
			<input name="samp">
				<check-type method="list" target="*">
					usampler1DARRAY,sampler1DARRAY,isampler1DARRAY
				</check-type>
			</input>
			<input name="s">
				<check-type method="list" target="*">
					float3,float4
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['usampler1DARRAY,float3'] = 'uint4',
						['sampler1DARRAY,float3'] = 'float4',
						['isampler1DARRAY,float3'] = 'int4',
						['sampler1DARRAY,float4'] = 'float4',
					}
					local types = node.samp.get_type() .. ',' .. node.s.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = tex1DARRAYproj( r${node.samp.get_source().uid()}, r${node.s.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="texRECTsize( samp, lod )">
		<description><![CDATA[
NAME

texRECTsize - returns the size of a given texture image for a given level of detail.


SYNOPSIS

int3 texRECTsize(samplerRECT samp, int lod)
int3 texRECTsize(isamplerRECT samp, int lod)
int3 texRECTsize(usamplerRECT samp, int lod)


PARAMETERS

samp Sampler to be queried for size.
lod Level of detail to obtain size.


DESCRIPTION

Given a sampler and a level of detail the size of the corresponding texture image is returned as the result of
the operation.


REFERENCE IMPLEMENTATION



PROFILE SUPPORT

texRECTsize is only supported in gp4 and newer profiles.


SEE ALSO

texRECT.de Sh
\$1

		]]></description>
		<tool-tip><![CDATA[
			texRECTsize - returns the size of a given texture image for a given level of detail.

		]]></tool-tip>
		<ports>
			<input name="samp">
				<check-type method="list" target="*">
					isamplerRECT,usamplerRECT,samplerRECT
				</check-type>
			</input>
			<input name="lod">
				<check-type method="list" target="*">
					int
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['isamplerRECT,int'] = 'int3',
						['samplerRECT,int'] = 'int3',
						['usamplerRECT,int'] = 'int3',
					}
					local types = node.samp.get_type() .. ',' .. node.lod.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = texRECTsize( r${node.samp.get_source().uid()}, r${node.lod.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="length( v )">
		<description><![CDATA[
NAME

length - return scalar Euclidean length of a vector


SYNOPSIS

float length(float v);
float length(float1 v);
float length(float2 v);
float length(float3 v);
float length(float4 v);
half length(half v);
half length(half1 v);
half length(half2 v);
half length(half3 v);
half length(half4 v);
fixed length(fixed v);
fixed length(fixed1 v);
fixed length(fixed2 v);
fixed length(fixed3 v);
fixed length(fixed4 v);


PARAMETERS

v Vector of which to determine the length.


DESCRIPTION

Returns the Euclidean length of a vector.


REFERENCE IMPLEMENTATION

length for a float3 vector could be implemented like this.
float length(float3 v)
{
return sqrt(dot(v,v));
}


PROFILE SUPPORT

length is supported in all profiles.
Support in the fp20 is limited.


SEE ALSO

max, normalize, sqrt, dot

		]]></description>
		<tool-tip><![CDATA[
			length - return scalar Euclidean length of a vector

		]]></tool-tip>
		<ports>
			<input name="v">
				<check-type method="list" target="*">
					half4,float4,half,half3,half1,fixed1,fixed4,float1,fixed3,fixed2,float3,float,fixed,half2,float2
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['float4'] = 'float',
						['half2'] = 'half',
						['half1'] = 'half',
						['float'] = 'float',
						['float1'] = 'float',
						['fixed2'] = 'fixed',
						['fixed4'] = 'fixed',
						['fixed3'] = 'fixed',
						['float3'] = 'float',
						['float2'] = 'float',
						['fixed1'] = 'fixed',
						['fixed'] = 'fixed',
						['half3'] = 'half',
						['half4'] = 'half',
						['half'] = 'half',
					}
					local types = node.v.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = length( r${node.v.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="normalize( a )">
		<description><![CDATA[
NAME

normalize - returns unit length vector of input a


SYNOPSIS

float2 normalize(float2 a);
float3 normalize(float3 a);
float4 normalize(float4 a);
half2 normalize(half2 a);
half3 normalize(half3 a);
half4 normalize(half4 a);
fixed2 normalize(fixed2 a);
fixed3 normalize(fixed3 a);
fixed4 normalize(fixed4 a);


PARAMETERS

a Vector of which to normalize to unit length


DESCRIPTION

Returns unit length vector of vector input


REFERENCE IMPLEMENTATION

(Missing)


PROFILE SUPPORT

(Missing)


SEE ALSO

(Missing)

		]]></description>
		<tool-tip><![CDATA[
			normalize - returns unit length vector of input a

		]]></tool-tip>
		<ports>
			<input name="a">
				<check-type method="list" target="*">
					half4,float4,fixed2,half2,fixed4,float3,fixed3,half3,float2
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['half3'] = 'half3',
						['half2'] = 'half2',
						['fixed3'] = 'fixed3',
						['fixed2'] = 'fixed2',
						['float3'] = 'float3',
						['float2'] = 'float2',
						['fixed4'] = 'fixed4',
						['half4'] = 'half4',
						['float4'] = 'float4',
					}
					local types = node.a.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = normalize( r${node.a.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="texRECTproj( samp, s, texelOff )">
		<description><![CDATA[
NAME

texRECTproj - performs a texture lookup with projection in a given sampler. May perform a shadow
comparison if argument for shadow comparison is provided.


SYNOPSIS

float4 texRECTproj(samplerRECT samp, float3 s)
float4 texRECTproj(samplerRECT samp, float3 s, int texelOff)
float4 texRECTproj(samplerRECT samp, float4 s)
float4 texRECTproj(samplerRECT samp, float4 s, int texelOff)
int4 texRECTproj(isamplerRECT samp, float3 s)
int4 texRECTproj(isamplerRECT samp, float3 s, int texelOff)
uint4 texRECTproj(usamplerRECT samp, float3 s)
uint4 texRECTproj(usamplerRECT samp, float3 s, int texelOff)


PARAMETERS

samp Sampler to lookup.
s Coordinates to perform the lookup. The value used in the projection should be passed as the last
component of the coordinate vector. The value used in the shadow comparison, if present, should
be passed as the next-to-last component of the coordinate vector.
texelOff Offset to be added to obtain the final texel.


DESCRIPTION

Performs a texture lookup in sampler samp using coordinates s, the coordinates used in the lookup are first
projected, that is, divided by the last component of the coordinate vector and them used in the lookup. If an
extra coordinate is present it is used to perform a shadow comparison, the value used in the shadow
comparison is always the next-to-last component in the coordinate vector.


REFERENCE IMPLEMENTATION



PROFILE SUPPORT

texRECTproj is supported in all fragment profiles and all vertex profiles starting with vp40, variants with
shadow comparison are only supported in fp40 and newer profiles, variants with texel offsets are only
supported in gp4 and newer profiles.


SEE ALSO

texRECT

		]]></description>
		<tool-tip><![CDATA[
			texRECTproj - performs a texture lookup with projection in a given sampler. May perform a shadow
comparison if argument for shadow comparison is provided.

		]]></tool-tip>
		<ports>
			<input name="samp">
				<check-type method="list" target="*">
					isamplerRECT,usamplerRECT,samplerRECT
				</check-type>
			</input>
			<input name="s">
				<check-type method="list" target="*">
					float3,float4
				</check-type>
			</input>
			<input name="texelOff">
				<check-type method="list" target="*">
					int
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['samplerRECT,float3,int'] = 'float4',
						['isamplerRECT,float3,int'] = 'int4',
						['usamplerRECT,float3,int'] = 'uint4',
						['samplerRECT,float4,int'] = 'float4',
					}
					local types = node.samp.get_type() .. ',' .. node.s.get_type() .. ',' .. node.texelOff.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = texRECTproj( r${node.samp.get_source().uid()}, r${node.s.get_source().uid()}, r${node.texelOff.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="texRECTproj( samp, s )">
		<description><![CDATA[
NAME

texRECTproj - performs a texture lookup with projection in a given sampler. May perform a shadow
comparison if argument for shadow comparison is provided.


SYNOPSIS

float4 texRECTproj(samplerRECT samp, float3 s)
float4 texRECTproj(samplerRECT samp, float3 s, int texelOff)
float4 texRECTproj(samplerRECT samp, float4 s)
float4 texRECTproj(samplerRECT samp, float4 s, int texelOff)
int4 texRECTproj(isamplerRECT samp, float3 s)
int4 texRECTproj(isamplerRECT samp, float3 s, int texelOff)
uint4 texRECTproj(usamplerRECT samp, float3 s)
uint4 texRECTproj(usamplerRECT samp, float3 s, int texelOff)


PARAMETERS

samp Sampler to lookup.
s Coordinates to perform the lookup. The value used in the projection should be passed as the last
component of the coordinate vector. The value used in the shadow comparison, if present, should
be passed as the next-to-last component of the coordinate vector.
texelOff Offset to be added to obtain the final texel.


DESCRIPTION

Performs a texture lookup in sampler samp using coordinates s, the coordinates used in the lookup are first
projected, that is, divided by the last component of the coordinate vector and them used in the lookup. If an
extra coordinate is present it is used to perform a shadow comparison, the value used in the shadow
comparison is always the next-to-last component in the coordinate vector.


REFERENCE IMPLEMENTATION



PROFILE SUPPORT

texRECTproj is supported in all fragment profiles and all vertex profiles starting with vp40, variants with
shadow comparison are only supported in fp40 and newer profiles, variants with texel offsets are only
supported in gp4 and newer profiles.


SEE ALSO

texRECT

		]]></description>
		<tool-tip><![CDATA[
			texRECTproj - performs a texture lookup with projection in a given sampler. May perform a shadow
comparison if argument for shadow comparison is provided.

		]]></tool-tip>
		<ports>
			<input name="samp">
				<check-type method="list" target="*">
					isamplerRECT,usamplerRECT,samplerRECT
				</check-type>
			</input>
			<input name="s">
				<check-type method="list" target="*">
					float3,float4
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['samplerRECT,float4'] = 'float4',
						['isamplerRECT,float3'] = 'int4',
						['samplerRECT,float3'] = 'float4',
						['usamplerRECT,float3'] = 'uint4',
					}
					local types = node.samp.get_type() .. ',' .. node.s.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = texRECTproj( r${node.samp.get_source().uid()}, r${node.s.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="any( a )">
		<description><![CDATA[
NAME

any - returns true if a boolean scalar or any component of a boolean vector is true.


SYNOPSIS

bool any(bool a);
bool any(bool1 a);
bool any(bool2 a);
bool any(bool3 a);
bool any(bool4 a);


PARAMETERS

a Boolean vector or scalar of which to determine if any component is true.


DESCRIPTION

Returns true if a boolean scalar or any component of a boolean vector is true.


REFERENCE IMPLEMENTATION

any for a bool4 vector could be implemented like this.
bool any(bool4 a)
{
return a.x || a.y || a.z || a.w;
}


PROFILE SUPPORT

any is supported in all profiles.
Support in the fp20 is limited.


SEE ALSO

all

		]]></description>
		<tool-tip><![CDATA[
			any - returns true if a boolean scalar or any component of a boolean vector is true.

		]]></tool-tip>
		<ports>
			<input name="a">
				<check-type method="list" target="*">
					bool3,bool4,bool2,bool,bool1
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['bool3'] = 'bool',
						['bool2'] = 'bool',
						['bool'] = 'bool',
						['bool1'] = 'bool',
						['bool4'] = 'bool',
					}
					local types = node.a.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = any( r${node.a.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="tex2Dcmpbias( samp, s, texelOff )">
		<description><![CDATA[
NAME

tex2Dcmpbias - performs a texture lookup with bias and shadow compare in a given sampler.


SYNOPSIS

float4 tex2Dcmpbias(sampler2D samp, float4 s)
float4 tex2Dcmpbias(sampler2D samp, float4 s, int texelOff)


PARAMETERS

samp Sampler to lookup.
s Coordinates to perform the lookup. The value used in the shadow comparison should be passed
right after the normal coordinates. The bias value should be passed as the last component of the
coordinate vector.
texelOff Offset to be added to obtain the final texel.


DESCRIPTION

Performs a texture lookup with shadow compare and bias in sampler samp using coordinates s.


REFERENCE IMPLEMENTATION



PROFILE SUPPORT

tex2Dcmpbias is supported in fragment profiles starting with fp40 and in vertex profiles starting with vp40.
Variants with texelOff are only supported in gp4 and newer profiles.


SEE ALSO

tex2Dcmplod, tex2Dbias.de Sh
\$1

		]]></description>
		<tool-tip><![CDATA[
			tex2Dcmpbias - performs a texture lookup with bias and shadow compare in a given sampler.

		]]></tool-tip>
		<ports>
			<input name="samp">
				<check-type method="list" target="*">
					sampler2D
				</check-type>
			</input>
			<input name="s">
				<check-type method="list" target="*">
					float4
				</check-type>
			</input>
			<input name="texelOff">
				<check-type method="list" target="*">
					int
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['sampler2D,float4,int'] = 'float4',
					}
					local types = node.samp.get_type() .. ',' .. node.s.get_type() .. ',' .. node.texelOff.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = tex2Dcmpbias( r${node.samp.get_source().uid()}, r${node.s.get_source().uid()}, r${node.texelOff.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="tex1Dproj( samp, s )">
		<description><![CDATA[
NAME

tex1Dproj - performs a texture lookup with projection in a given sampler. May perform a shadow
comparison if argument for shadow comparison is provided.


SYNOPSIS

float4 tex1Dproj(sampler1D samp, float2 s)
float4 tex1Dproj(sampler1D samp, float2 s, int texelOff)
float4 tex1Dproj(sampler1D samp, float3 s)
float4 tex1Dproj(sampler1D samp, float3 s, int texelOff)
int4 tex1Dproj(isampler1D samp, float2 s)
int4 tex1Dproj(isampler1D samp, float2 s, int texelOff)
uint4 tex1Dproj(usampler1D samp, float2 s)
uint4 tex1Dproj(usampler1D samp, float2 s, int texelOff)


PARAMETERS

samp Sampler to lookup.
s Coordinates to perform the lookup. The value used in the projection should be passed as the last
component of the coordinate vector. The value used in the shadow comparison, if present, should
be passed as the next-to-last component of the coordinate vector.
texelOff Offset to be added to obtain the final texel.


DESCRIPTION

Performs a texture lookup in sampler samp using coordinates s, the coordinates used in the lookup are first
projected, that is, divided by the last component of the coordinate vector and them used in the lookup. If an
extra coordinate is present it is used to perform a shadow comparison, the value used in the shadow
comparison is always the next-to-last component in the coordinate vector.


REFERENCE IMPLEMENTATION



PROFILE SUPPORT

tex1Dproj is supported in all fragment profiles and all vertex profiles starting with vp40, variants with
shadow comparison are only supported in fp40 and newer profiles, variants with texel offsets are only
supported in gp4 and newer profiles.


SEE ALSO

tex1D, tex1DARRAYproj

		]]></description>
		<tool-tip><![CDATA[
			tex1Dproj - performs a texture lookup with projection in a given sampler. May perform a shadow
comparison if argument for shadow comparison is provided.

		]]></tool-tip>
		<ports>
			<input name="samp">
				<check-type method="list" target="*">
					usampler1D,isampler1D,sampler1D
				</check-type>
			</input>
			<input name="s">
				<check-type method="list" target="*">
					float3,float2
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['isampler1D,float2'] = 'int4',
						['usampler1D,float2'] = 'uint4',
						['sampler1D,float3'] = 'float4',
						['sampler1D,float2'] = 'float4',
					}
					local types = node.samp.get_type() .. ',' .. node.s.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = tex1Dproj( r${node.samp.get_source().uid()}, r${node.s.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="tex2D( samp, s, dx, dy )">
		<description><![CDATA[
NAME

tex2D - performs a texture lookup in a given 2D sampler and, in some cases, a shadow comparison. May
also use pre computed derivatives if those are provided.


SYNOPSIS

float4 tex2D(sampler2D samp, float2 s)
float4 tex2D(sampler2D samp, float2 s, int texelOff)
float4 tex2D(sampler2D samp, float3 s)
float4 tex2D(sampler2D samp, float3 s, int texelOff)
float4 tex2D(sampler2D samp, float2 s, float2 dx, float2 dy)
float4 tex2D(sampler2D samp, float2 s, float2 dx, float2 dy, int texelOff)
float4 tex2D(sampler2D samp, float3 s, float2 dx, float2 dy)
float4 tex2D(sampler2D samp, float3 s, float2 dx, float2 dy, int texelOff)
int4 tex2D(isampler2D samp, float2 s)
int4 tex2D(isampler2D samp, float2 s, int texelOff)
int4 tex2D(isampler2D samp, float2 s, float2 dx, float2 dy)
int4 tex2D(isampler2D samp, float2 s, float2 dx, float2 dy, int texelOff)
uint4 tex2D(usampler2D samp, float2 s)
uint4 tex2D(usampler2D samp, float2 s, int texelOff)
uint4 tex2D(usampler2D samp, float2 s, float2 dx, float2 dy)
uint4 tex2D(usampler2D samp, float2 s, float2 dx, float2 dy,int texelOff)


PARAMETERS

samp Sampler to lookup.
s Coordinates to perform the lookup. If an extra coordinate compared to the texture dimensionality
is present it is used to perform a shadow comparison. The value used in the shadow comparison is
always the last component of the coordinate vector.
dx Pre computed derivative along the x axis.
dy Pre computed derivative along the y axis.
texelOff Offset to be added to obtain the final texel.


DESCRIPTION

Performs a texture lookup in sampler samp using coordinates s, may use and derivatives dx and dy, also
may perform shadow comparison and use texel offset texelOff to compute final texel.


REFERENCE IMPLEMENTATION



PROFILE SUPPORT

tex2D is supported in all fragment profiles and all vertex profiles starting with vp40, variants with shadow
comparison are only supported in fp40 and newer profiles, variants with texel offsets are only supported in
gp4 and newer profiles. Variants with integer textures are also only supported in gp4 and newer profiles.


SEE ALSO

tex2Dbias, tex2Dlod, tex2Dproj

		]]></description>
		<tool-tip><![CDATA[
			tex2D - performs a texture lookup in a given 2D sampler and, in some cases, a shadow comparison. May
also use pre computed derivatives if those are provided.

		]]></tool-tip>
		<ports>
			<input name="samp">
				<check-type method="list" target="*">
					sampler2D,isampler2D,usampler2D
				</check-type>
			</input>
			<input name="s">
				<check-type method="list" target="*">
					float3,float2
				</check-type>
			</input>
			<input name="dx">
				<check-type method="list" target="*">
					float2
				</check-type>
			</input>
			<input name="dy">
				<check-type method="list" target="*">
					float2
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['usampler2D,float2,float2,float2'] = 'uint4',
						['sampler2D,float3,float2,float2'] = 'float4',
						['isampler2D,float2,float2,float2'] = 'int4',
						['sampler2D,float2,float2,float2'] = 'float4',
					}
					local types = node.samp.get_type() .. ',' .. node.s.get_type() .. ',' .. node.dx.get_type() .. ',' .. node.dy.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = tex2D( r${node.samp.get_source().uid()}, r${node.s.get_source().uid()}, r${node.dx.get_source().uid()}, r${node.dy.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="tex1D( samp, s, texelOff )">
		<description><![CDATA[
NAME

tex1D - performs a texture lookup in a given 1D sampler and, in some cases, a shadow comparison. May
also use pre computed derivatives if those are provided.


SYNOPSIS

float4 tex1D(sampler1D samp, float s)
float4 tex1D(sampler1D samp, float s, int texelOff)
float4 tex1D(sampler1D samp, float2 s)
float4 tex1D(sampler1D samp, float2 s, int texelOff)
float4 tex1D(sampler1D samp, float s, float dx, float dy)
float4 tex1D(sampler1D samp, float s, float dx, float dy, int texelOff)
float4 tex1D(sampler1D samp, float2 s, float dx, float dy)
float4 tex1D(sampler1D samp, float2 s, float dx, float dy, int texelOff)
int4 tex1D(isampler1D samp, float s);
int4 tex1D(isampler1D samp, float s, int texelOff);
int4 tex1D(isampler1D samp, float s, float dx, float dy)
int4 tex1D(isampler1D samp, float s, float dx, float dy, int texelOff)
uint4 tex1D(usampler1D samp, float s);
uint4 tex1D(usampler1D samp, float s, int texelOff);
uint4 tex1D(usampler1D samp, float s, float dx, float dy)
uint4 tex1D(usampler1D samp, float s, float dx, float dy,int texelOff)


PARAMETERS

samp Sampler to lookup.
s Coordinates to perform the lookup. If an extra coordinate compared to the texture dimensionality
is present it is used to perform a shadow comparison. The value used in the shadow comparison is
always the last component of the coordinate vector.
dx Pre computed derivative along the x axis.
dy Pre computed derivative along the y axis.
texelOff Offset to be added to obtain the final texel.


DESCRIPTION

Performs a texture lookup in sampler samp using coordinates s, may use and derivatives dx and dy, also
may perform shadow comparison and use texel offset texelOff to compute final texel.


REFERENCE IMPLEMENTATION



PROFILE SUPPORT

tex1D is supported in all fragment profiles and all vertex profiles starting with vp40, variants with shadow
comparison are only supported in fp40 and newer profiles, variants with texel offsets are only supported in
gp4 and newer profiles, variants with integer textures are also only supported in gp4 and newer profiles.


SEE ALSO

tex1Dbias, tex1Dlod, tex1Dproj

		]]></description>
		<tool-tip><![CDATA[
			tex1D - performs a texture lookup in a given 1D sampler and, in some cases, a shadow comparison. May
also use pre computed derivatives if those are provided.

		]]></tool-tip>
		<ports>
			<input name="samp">
				<check-type method="list" target="*">
					usampler1D,isampler1D,sampler1D
				</check-type>
			</input>
			<input name="s">
				<check-type method="list" target="*">
					float,float2
				</check-type>
			</input>
			<input name="texelOff">
				<check-type method="list" target="*">
					int
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['usampler1D,float,int'] = 'uint4',
						['sampler1D,float,int'] = 'float4',
						['isampler1D,float,int'] = 'int4',
						['sampler1D,float2,int'] = 'float4',
					}
					local types = node.samp.get_type() .. ',' .. node.s.get_type() .. ',' .. node.texelOff.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = tex1D( r${node.samp.get_source().uid()}, r${node.s.get_source().uid()}, r${node.texelOff.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="texRECTfetch( samp, s, texelOff )">
		<description><![CDATA[
NAME

texRECTfetch - performs an unfiltered texture lookup in a given sampler.


SYNOPSIS

float4 texRECTfetch(samplerRECT samp, int4 s)
float4 texRECTfetch(samplerRECT samp, int4 s, int2 texelOff)
int4 texRECTfetch(isamplerRECT samp, int4 s)
int4 texRECTfetch(isamplerRECT samp, int4 s, int2 texelOff)
uint4 texRECTfetch(usamplerRECT samp, int4 s)
uint4 texRECTfetch(usamplerRECT samp, int4 s, int2 texelOff)


PARAMETERS

samp Sampler to lookup.
s Coordinates to perform the lookup. The level of detail is stored in the last component of the
coordinate vector.
texelOff Offset to be added to obtain the final texel.


DESCRIPTION

Performs an unfiltered texture lookup in sampler samp using coordinates s. The level of detail is provided
by the last component of the coordinate vector. May use texel offset texelOff to compute final texel.


REFERENCE IMPLEMENTATION



PROFILE SUPPORT

texRECTfetch is only supported in gp4 and newer profiles.


SEE ALSO

texRECT, texRECTARRAYfetch.de Sh
\$1

		]]></description>
		<tool-tip><![CDATA[
			texRECTfetch - performs an unfiltered texture lookup in a given sampler.

		]]></tool-tip>
		<ports>
			<input name="samp">
				<check-type method="list" target="*">
					isamplerRECT,usamplerRECT,samplerRECT
				</check-type>
			</input>
			<input name="s">
				<check-type method="list" target="*">
					int4
				</check-type>
			</input>
			<input name="texelOff">
				<check-type method="list" target="*">
					int2
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['usamplerRECT,int4,int2'] = 'uint4',
						['samplerRECT,int4,int2'] = 'float4',
						['isamplerRECT,int4,int2'] = 'int4',
					}
					local types = node.samp.get_type() .. ',' .. node.s.get_type() .. ',' .. node.texelOff.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = texRECTfetch( r${node.samp.get_source().uid()}, r${node.s.get_source().uid()}, r${node.texelOff.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="texRECTfetch( samp, s )">
		<description><![CDATA[
NAME

texRECTfetch - performs an unfiltered texture lookup in a given sampler.


SYNOPSIS

float4 texRECTfetch(samplerRECT samp, int4 s)
float4 texRECTfetch(samplerRECT samp, int4 s, int2 texelOff)
int4 texRECTfetch(isamplerRECT samp, int4 s)
int4 texRECTfetch(isamplerRECT samp, int4 s, int2 texelOff)
uint4 texRECTfetch(usamplerRECT samp, int4 s)
uint4 texRECTfetch(usamplerRECT samp, int4 s, int2 texelOff)


PARAMETERS

samp Sampler to lookup.
s Coordinates to perform the lookup. The level of detail is stored in the last component of the
coordinate vector.
texelOff Offset to be added to obtain the final texel.


DESCRIPTION

Performs an unfiltered texture lookup in sampler samp using coordinates s. The level of detail is provided
by the last component of the coordinate vector. May use texel offset texelOff to compute final texel.


REFERENCE IMPLEMENTATION



PROFILE SUPPORT

texRECTfetch is only supported in gp4 and newer profiles.


SEE ALSO

texRECT, texRECTARRAYfetch.de Sh
\$1

		]]></description>
		<tool-tip><![CDATA[
			texRECTfetch - performs an unfiltered texture lookup in a given sampler.

		]]></tool-tip>
		<ports>
			<input name="samp">
				<check-type method="list" target="*">
					isamplerRECT,usamplerRECT,samplerRECT
				</check-type>
			</input>
			<input name="s">
				<check-type method="list" target="*">
					int4
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['usamplerRECT,int4'] = 'uint4',
						['isamplerRECT,int4'] = 'int4',
						['samplerRECT,int4'] = 'float4',
					}
					local types = node.samp.get_type() .. ',' .. node.s.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = texRECTfetch( r${node.samp.get_source().uid()}, r${node.s.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="mul( v, M )">
		<description><![CDATA[
NAME

mul - multiply a matrix by a column vector, row vector by a matrix, or matrix by a matrix


SYNOPSIS

float4 mul(float4x4 M, float4 v);
float4 mul(float4x3 M, float3 v);
float4 mul(float4x2 M, float2 v);
float4 mul(float4x1 M, float1 v);
float3 mul(float3x4 M, float4 v);
float3 mul(float3x3 M, float3 v);
float3 mul(float3x2 M, float2 v);
float3 mul(float3x1 M, float1 v);
float2 mul(float2x4 M, float4 v);
float2 mul(float2x3 M, float3 v);
float2 mul(float2x2 M, float2 v);
float2 mul(float2x1 M, float1 v);
float1 mul(float1x4 M, float4 v);
float1 mul(float1x3 M, float3 v);
float1 mul(float1x2 M, float2 v);
float1 mul(float1x1 M, float1 v);
float4 mul(float4 v, float4x4 M);
float4 mul(float3 v, float3x4 M);
float4 mul(float2 v, float2x4 M);
float4 mul(float1 v, float1x4 M);
float3 mul(float4 v, float4x3 M);
float3 mul(float3 v, float3x3 M);
float3 mul(float2 v, float2x3 M);
float3 mul(float1 v, float1x3 M);
float2 mul(float4 v, float4x2 M);
float2 mul(float3 v, float3x2 M);
float2 mul(float2 v, float2x2 M);
float2 mul(float1 v, float1x2 M);
float1 mul(float4 v, float4x1 M);
float1 mul(float3 v, float3x1 M);
float1 mul(float2 v, float2x1 M);
float1 mul(float1 v, float1x1 M);
half4 mul(half4x4 M, half4 v);
half4 mul(half4x3 M, half3 v);
half4 mul(half4x2 M, half2 v);
half4 mul(half4x1 M, half1 v);
half3 mul(half3x4 M, half4 v);
half3 mul(half3x3 M, half3 v);
half3 mul(half3x2 M, half2 v);
half3 mul(half3x1 M, half1 v);
half2 mul(half2x4 M, half4 v);
half2 mul(half2x3 M, half3 v);
half2 mul(half2x2 M, half2 v);
half2 mul(half2x1 M, half1 v);
half1 mul(half1x4 M, half4 v);
half1 mul(half1x3 M, half3 v);
half1 mul(half1x2 M, half2 v);
half1 mul(half1x1 M, half1 v);
half4 mul(half4 v, half4x4 M);
half4 mul(half3 v, half3x4 M);
half4 mul(half2 v, half2x4 M);
half4 mul(half1 v, half1x4 M);
half3 mul(half4 v, half4x3 M);
half3 mul(half3 v, half3x3 M);
half3 mul(half2 v, half2x3 M);
half3 mul(half1 v, half1x3 M);
half2 mul(half4 v, half4x2 M);
half2 mul(half3 v, half3x2 M);
half2 mul(half2 v, half2x2 M);
half2 mul(half1 v, half1x2 M);
half1 mul(half4 v, half4x1 M);
half1 mul(half3 v, half3x1 M);
half1 mul(half2 v, half2x1 M);
half1 mul(half1 v, half1x1 M);
fixed4 mul(fixed4x4 M, fixed4 v);
fixed4 mul(fixed4x3 M, fixed3 v);
fixed4 mul(fixed4x2 M, fixed2 v);
fixed4 mul(fixed4x1 M, fixed1 v);
fixed3 mul(fixed3x4 M, fixed4 v);
fixed3 mul(fixed3x3 M, fixed3 v);
fixed3 mul(fixed3x2 M, fixed2 v);
fixed3 mul(fixed3x1 M, fixed1 v);
fixed2 mul(fixed2x4 M, fixed4 v);
fixed2 mul(fixed2x3 M, fixed3 v);
fixed2 mul(fixed2x2 M, fixed2 v);
fixed2 mul(fixed2x1 M, fixed1 v);
fixed1 mul(fixed1x4 M, fixed4 v);
fixed1 mul(fixed1x3 M, fixed3 v);
fixed1 mul(fixed1x2 M, fixed2 v);
fixed1 mul(fixed1x1 M, fixed1 v);
fixed4 mul(fixed4 v, fixed4x4 M);
fixed4 mul(fixed3 v, fixed3x4 M);
fixed4 mul(fixed2 v, fixed2x4 M);
fixed4 mul(fixed1 v, fixed1x4 M);
fixed3 mul(fixed4 v, fixed4x3 M);
fixed3 mul(fixed3 v, fixed3x3 M);
fixed3 mul(fixed2 v, fixed2x3 M);
fixed3 mul(fixed1 v, fixed1x3 M);
fixed2 mul(fixed4 v, fixed4x2 M);
fixed2 mul(fixed3 v, fixed3x2 M);
fixed2 mul(fixed2 v, fixed2x2 M);
fixed2 mul(fixed1 v, fixed1x2 M);
fixed1 mul(fixed4 v, fixed4x1 M);
fixed1 mul(fixed3 v, fixed3x1 M);
fixed1 mul(fixed2 v, fixed2x1 M);
fixed1 mul(fixed1 v, fixed1x1 M);
float1x1 mul(float1x1 A, float1x1 B);
float1x2 mul(float1x1 A, float1x2 B);
float1x3 mul(float1x1 A, float1x3 B);
float1x4 mul(float1x1 A, float1x4 B);
float1x1 mul(float1x2 A, float2x1 B);
float1x2 mul(float1x2 A, float2x2 B);
float1x3 mul(float1x2 A, float2x3 B);
float1x4 mul(float1x2 A, float2x4 B);
float1x1 mul(float1x3 A, float3x1 B);
float1x2 mul(float1x3 A, float3x2 B);
float1x3 mul(float1x3 A, float3x3 B);
float1x4 mul(float1x3 A, float3x4 B);
float1x1 mul(float1x4 A, float4x1 B);
float1x2 mul(float1x4 A, float4x2 B);
float1x3 mul(float1x4 A, float4x3 B);
float1x4 mul(float1x4 A, float4x4 B);
float2x1 mul(float2x1 A, float1x1 B);
float2x2 mul(float2x1 A, float1x2 B);
float2x3 mul(float2x1 A, float1x3 B);
float2x4 mul(float2x1 A, float1x4 B);
float2x1 mul(float2x2 A, float2x1 B);
float2x2 mul(float2x2 A, float2x2 B);
float2x3 mul(float2x2 A, float2x3 B);
float2x4 mul(float2x2 A, float2x4 B);
float2x1 mul(float2x3 A, float3x1 B);
float2x2 mul(float2x3 A, float3x2 B);
float2x3 mul(float2x3 A, float3x3 B);
float2x4 mul(float2x3 A, float3x4 B);
float2x1 mul(float2x4 A, float4x1 B);
float2x2 mul(float2x4 A, float4x2 B);
float2x3 mul(float2x4 A, float4x3 B);
float2x4 mul(float2x4 A, float4x4 B);
float3x1 mul(float3x1 A, float1x1 B);
float3x2 mul(float3x1 A, float1x2 B);
float3x3 mul(float3x1 A, float1x3 B);
float3x4 mul(float3x1 A, float1x4 B);
float3x1 mul(float3x2 A, float2x1 B);
float3x2 mul(float3x2 A, float2x2 B);
float3x3 mul(float3x2 A, float2x3 B);
float3x4 mul(float3x2 A, float2x4 B);
float3x1 mul(float3x3 A, float3x1 B);
float3x2 mul(float3x3 A, float3x2 B);
float3x3 mul(float3x3 A, float3x3 B);
float3x4 mul(float3x3 A, float3x4 B);
float3x1 mul(float3x4 A, float4x1 B);
float3x2 mul(float3x4 A, float4x2 B);
float3x3 mul(float3x4 A, float4x3 B);
float3x4 mul(float3x4 A, float4x4 B);
float4x1 mul(float4x1 A, float1x1 B);
float4x2 mul(float4x1 A, float1x2 B);
float4x3 mul(float4x1 A, float1x3 B);
float4x4 mul(float4x1 A, float1x4 B);
float4x1 mul(float4x2 A, float2x1 B);
float4x2 mul(float4x2 A, float2x2 B);
float4x3 mul(float4x2 A, float2x3 B);
float4x4 mul(float4x2 A, float2x4 B);
float4x1 mul(float4x3 A, float3x1 B);
float4x2 mul(float4x3 A, float3x2 B);
float4x3 mul(float4x3 A, float3x3 B);
float4x4 mul(float4x3 A, float3x4 B);
float4x1 mul(float4x4 A, float4x1 B);
float4x2 mul(float4x4 A, float4x2 B);
float4x3 mul(float4x4 A, float4x3 B);
float4x4 mul(float4x4 A, float4x4 B);


PARAMETERS

M Matrix
v Vector
A Matrix
B Matrix


DESCRIPTION

Returns the vector result of multiplying a matrix M by a column vector v; a row vector v by a matrix M; or a
matrix A by a second matrix B.
The following are algebrically equal (if not necessarily numerically equal):
mul(M,v) == mul(v, tranpose(M))
mul(v,M) == mul(tranpose(M), v)


REFERENCE IMPLEMENTATION

mul for a float4x3 matrix by a float3 column vector could be implemented this way:
float4 mul(float4x3 M, float3 v)
{
float4 r;
r.x = dot( M._m00_m01_m02, v );
r.y = dot( M._m10_m11_m12, v );
r.z = dot( M._m20_m21_m22, v );
r.w = dot( M._m30_m31_m32, v );
return r;
}


PROFILE SUPPORT

mul is supported in all profiles.
The fifixed3 matrix-by-vector and vector-by-matrix multiplies are very efficient in the fp20 and fp30 profiles.


SEE ALSO

cross, dot, transpose

		]]></description>
		<tool-tip><![CDATA[
			mul - multiply a matrix by a column vector, row vector by a matrix, or matrix by a matrix

		]]></tool-tip>
		<ports>
			<input name="v">
				<check-type method="list" target="*">
					half4,float4,half3,half2,fixed4,float3,fixed1,fixed2,fixed3,float1,half1,float2
				</check-type>
			</input>
			<input name="M">
				<check-type method="list" target="*">
					fixed3x3,half2x3,float2x2,half2x1,fixed3x4,half3x1,float4x1,float2x1,float1x3,half1x1,half4x4,fixed1x2,fixed2x3,float3x2,half4x3,fixed2x1,fixed3x1,fixed4x3,fixed4x4,fixed3x2,fixed2x2,half3x4,fixed1x3,fixed4x1,fixed1x4,half4x2,fixed2x4,float3x3,half3x3,half3x2,fixed4x2,float4x2,float1x2,half2x2,float3x4,float1x4,half1x4,half2x4,float2x3,half4x1,half1x2,float4x3,float3x1,float2x4,float4x4,fixed1x1,float1x1,half1x3
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['float1,float1x2'] = 'float2',
						['float2,float2x4'] = 'float4',
						['fixed1,fixed1x4'] = 'fixed4',
						['half2,half2x2'] = 'half2',
						['fixed4,fixed4x4'] = 'fixed4',
						['float3,float3x2'] = 'float2',
						['float1,float1x4'] = 'float4',
						['fixed2,fixed2x4'] = 'fixed4',
						['float2,float2x1'] = 'float1',
						['float2,float2x2'] = 'float2',
						['half1,half1x4'] = 'half4',
						['fixed1,fixed1x1'] = 'fixed1',
						['half1,half1x2'] = 'half2',
						['fixed3,fixed3x2'] = 'fixed2',
						['fixed2,fixed2x1'] = 'fixed1',
						['half4,half4x4'] = 'half4',
						['float4,float4x4'] = 'float4',
						['float4,float4x1'] = 'float1',
						['fixed3,fixed3x1'] = 'fixed1',
						['float4,float4x3'] = 'float3',
						['float3,float3x4'] = 'float4',
						['float1,float1x1'] = 'float1',
						['half3,half3x1'] = 'half1',
						['fixed4,fixed4x1'] = 'fixed1',
						['fixed1,fixed1x2'] = 'fixed2',
						['fixed2,fixed2x3'] = 'fixed3',
						['half2,half2x3'] = 'half3',
						['float1,float1x3'] = 'float3',
						['fixed4,fixed4x2'] = 'fixed2',
						['fixed1,fixed1x3'] = 'fixed3',
						['half1,half1x3'] = 'half3',
						['fixed2,fixed2x2'] = 'fixed2',
						['half1,half1x1'] = 'half1',
						['half2,half2x1'] = 'half1',
						['float4,float4x2'] = 'float2',
						['fixed3,fixed3x4'] = 'fixed4',
						['fixed3,fixed3x3'] = 'fixed3',
						['half3,half3x3'] = 'half3',
						['fixed4,fixed4x3'] = 'fixed3',
						['half2,half2x4'] = 'half4',
						['half3,half3x4'] = 'half4',
						['half4,half4x1'] = 'half1',
						['float3,float3x1'] = 'float1',
						['half3,half3x2'] = 'half2',
						['half4,half4x2'] = 'half2',
						['half4,half4x3'] = 'half3',
						['float3,float3x3'] = 'float3',
						['float2,float2x3'] = 'float3',
					}
					local types = node.v.get_type() .. ',' .. node.M.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = mul( r${node.v.get_source().uid()}, r${node.M.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="min( a, b )">
		<description><![CDATA[
NAME

min - returns the minimum of two scalars or each respective component of two vectors


SYNOPSIS

float min(float a, float b);
float1 min(float1 a, float1 b);
float2 min(float2 a, float2 b);
float3 min(float3 a, float3 b);
float4 min(float4 a, float4 b);
half min(half a, half b);
half1 min(half1 a, half1 b);
half2 min(half2 a, half2 b);
half3 min(half3 a, half3 b);
half4 min(half4 a, half4 b);
fixed min(fixed a, fixed b);
fixed1 min(fixed1 a, fixed1 b);
fixed2 min(fixed2 a, fixed2 b);
fixed3 min(fixed3 a, fixed3 b);
fixed4 min(fixed4 a, fixed4 b);


PARAMETERS

a Scalar or vector.
b Scalar or vector.


DESCRIPTION

Returns the minimum of two same-typed scalars a and b or the respective components of two same-typed
vectors a and b. The result is a three-component vector.


REFERENCE IMPLEMENTATION

min for float3 vectors could be implemented this way:
float3 min(float3 a, float3 b)
{
return float3(a.x < b.x ? a.x : b.x,
a.y < b.y ? a.y : b.y,
a.z < b.z ? a.z : b.z);
}


PROFILE SUPPORT

min is supported in all profiles. min is implemented as a compiler built-in.
Support in the fp20 is limited.


SEE ALSO

clamp, max

		]]></description>
		<tool-tip><![CDATA[
			min - returns the minimum of two scalars or each respective component of two vectors

		]]></tool-tip>
		<ports>
			<input name="a">
				<check-type method="list" target="*">
					half4,float4,half,half3,half1,fixed1,fixed4,float1,fixed3,fixed2,float3,float,fixed,half2,float2
				</check-type>
			</input>
			<input name="b">
				<check-type method="list" target="*">
					half4,float4,half,half3,half1,fixed1,fixed4,float1,fixed3,fixed2,float3,float,fixed,half2,float2
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['fixed1,fixed1'] = 'fixed1',
						['float4,float4'] = 'float4',
						['float3,float3'] = 'float3',
						['float,float'] = 'float',
						['fixed4,fixed4'] = 'fixed4',
						['fixed3,fixed3'] = 'fixed3',
						['fixed,fixed'] = 'fixed',
						['fixed2,fixed2'] = 'fixed2',
						['half4,half4'] = 'half4',
						['half3,half3'] = 'half3',
						['float1,float1'] = 'float1',
						['half,half'] = 'half',
						['half1,half1'] = 'half1',
						['float2,float2'] = 'float2',
						['half2,half2'] = 'half2',
					}
					local types = node.a.get_type() .. ',' .. node.b.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = min( r${node.a.get_source().uid()}, r${node.b.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="tex1Dfetch( samp, s, texelOff )">
		<description><![CDATA[
NAME

tex1Dfetch - performs an unfiltered texture lookup in a given sampler.


SYNOPSIS

float4 tex1Dfetch(sampler1D samp, int4 s)
float4 tex1Dfetch(sampler1D samp, int4 s, int texelOff)
int4 tex1Dfetch(isampler1D samp, int4 s)
int4 tex1Dfetch(isampler1D samp, int4 s, int texelOff)
uint4 tex1Dfetch(usampler1D samp, int4 s)
uint4 tex1Dfetch(usampler1D samp, int4 s, int texelOff)


PARAMETERS

samp Sampler to lookup.
s Coordinates to perform the lookup. The level of detail is stored in the last component of the
coordinate vector.
texelOff Offset to be added to obtain the final texel.


DESCRIPTION

Performs an unfiltered texture lookup in sampler samp using coordinates s. The level of detail is provided
by the last component of the coordinate vector. May use texel offset texelOff to compute final texel.


REFERENCE IMPLEMENTATION



PROFILE SUPPORT

tex1Dfetch is only supported in gp4 and newer profiles.


SEE ALSO

tex1D, tex1DARRAYfetch.de Sh
\$1

		]]></description>
		<tool-tip><![CDATA[
			tex1Dfetch - performs an unfiltered texture lookup in a given sampler.

		]]></tool-tip>
		<ports>
			<input name="samp">
				<check-type method="list" target="*">
					usampler1D,isampler1D,sampler1D
				</check-type>
			</input>
			<input name="s">
				<check-type method="list" target="*">
					int4
				</check-type>
			</input>
			<input name="texelOff">
				<check-type method="list" target="*">
					int
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['isampler1D,int4,int'] = 'int4',
						['sampler1D,int4,int'] = 'float4',
						['usampler1D,int4,int'] = 'uint4',
					}
					local types = node.samp.get_type() .. ',' .. node.s.get_type() .. ',' .. node.texelOff.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = tex1Dfetch( r${node.samp.get_source().uid()}, r${node.s.get_source().uid()}, r${node.texelOff.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="tex1DARRAYlod( samp, s )">
		<description><![CDATA[
NAME

tex1DARRAYlod - performs a texture lookup with a specified level of detail in a given sampler array.


SYNOPSIS

float4 tex1DARRAYlod(sampler1DARRAY samp, float4 s)
float4 tex1DARRAYlod(sampler1DARRAY samp, float4 s, int texelOff)
int4 tex1DARRAYlod(isampler1DARRAY samp, float4 s)
int4 tex1DARRAYlod(isampler1DARRAY samp, float4 s, int texelOff)
uint4 tex1DARRAYlod(usampler1DARRAY samp, float4 s)
uint4 tex1DARRAYlod(usampler1DARRAY samp, float4 s, int texelOff)


PARAMETERS

samp Sampler array to lookup.
s Coordinates to perform the lookup.The value used to select the layer should be passed in the
vector component right after the regular coordinates. The level of detail value should be passed as
the last component of the coordinate vector.
texelOff Offset to be added to obtain the final texel.


DESCRIPTION

Performs a texture lookup with a specified level of detail in sampler samp using coordinates s, the texture to
be sampled is selected from the layer specified in the coordinates.


REFERENCE IMPLEMENTATION



PROFILE SUPPORT

tex1DARRAYlod is only supported in gp4 and newer profiles.


SEE ALSO

tex1DARRAY, tex1DARRAYbias.de Sh
\$1

		]]></description>
		<tool-tip><![CDATA[
			tex1DARRAYlod - performs a texture lookup with a specified level of detail in a given sampler array.

		]]></tool-tip>
		<ports>
			<input name="samp">
				<check-type method="list" target="*">
					usampler1DARRAY,sampler1DARRAY,isampler1DARRAY
				</check-type>
			</input>
			<input name="s">
				<check-type method="list" target="*">
					float4
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['usampler1DARRAY,float4'] = 'uint4',
						['isampler1DARRAY,float4'] = 'int4',
						['sampler1DARRAY,float4'] = 'float4',
					}
					local types = node.samp.get_type() .. ',' .. node.s.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = tex1DARRAYlod( r${node.samp.get_source().uid()}, r${node.s.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="texRECT( samp, s, dx, dy, texelOff )">
		<description><![CDATA[
NAME

texRECT - performs a texture lookup in a given RECT sampler and, in some cases, a shadow comparison.
May also use pre computed derivatives if those are provided.


SYNOPSIS

float4 texRECT(samplerRECT samp, float2 s)
float4 texRECT(samplerRECT samp, float2 s, int texelOff)
float4 texRECT(samplerRECT samp, float3 s)
float4 texRECT(samplerRECT samp, float3 s, int texelOff)
float4 texRECT(samplerRECT samp, float2 s, float2 dx, float2 dy)
float4 texRECT(samplerRECT samp, float2 s, float2 dx, float2 dy, int texelOff)
float4 texRECT(samplerRECT samp, float3 s, float2 dx, float2 dy)
float4 texRECT(samplerRECT samp, float3 s, float2 dx, float2 dy, int texelOff)
int4 texRECT(isamplerRECT samp, float2 s)
int4 texRECT(isamplerRECT samp, float2 s, int texelOff)
int4 texRECT(isamplerRECT samp, float2 s, float2 dx, float2 dy)
int4 texRECT(isamplerRECT samp, float2 s, float2 dx, float2 dy, int texelOff)
uint4 texRECT(usamplerRECT samp, float2 s)
uint4 texRECT(usamplerRECT samp, float2 s, int texelOff)
uint4 texRECT(usamplerRECT samp, float2 s, float2 dx, float2 dy)
uint4 texRECT(usamplerRECT samp, float2 s, float2 dx, float2 dy,int texelOff)


PARAMETERS

samp Sampler to lookup.
s Coordinates to perform the lookup. If an extra coordinate compared to the texture dimensionality
is present it is used to perform a shadow comparison. The value used in the shadow comparison is
always the last component of the coordinate vector.
dx Pre computed derivative along the x axis.
dy Pre computed derivative along the y axis.
texelOff Offset to be added to obtain the final texel.


DESCRIPTION

Performs a texture lookup in sampler samp using coordinates s, may use and derivatives dx and dy, also
may perform shadow comparison and use texel offset texelOff to compute final texel.


REFERENCE IMPLEMENTATION



PROFILE SUPPORT

texRECT is supported in all fragment profiles and all vertex profiles starting with vp40, variants with
shadow comparison are only supported in fp40 and newer profiles, variants with texel offsets are only
supported in gp4 and newer profiles. Variants with integer samplers are only supported in gp4 and newer
profiles.


SEE ALSO

texRECTbias, texRECTlod, texRECTproj

		]]></description>
		<tool-tip><![CDATA[
			texRECT - performs a texture lookup in a given RECT sampler and, in some cases, a shadow comparison.
May also use pre computed derivatives if those are provided.

		]]></tool-tip>
		<ports>
			<input name="samp">
				<check-type method="list" target="*">
					isamplerRECT,usamplerRECT,samplerRECT
				</check-type>
			</input>
			<input name="s">
				<check-type method="list" target="*">
					float3,float2
				</check-type>
			</input>
			<input name="dx">
				<check-type method="list" target="*">
					float2
				</check-type>
			</input>
			<input name="dy">
				<check-type method="list" target="*">
					float2
				</check-type>
			</input>
			<input name="texelOff">
				<check-type method="list" target="*">
					int
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['isamplerRECT,float2,float2,float2,int'] = 'int4',
						['samplerRECT,float2,float2,float2,int'] = 'float4',
						['samplerRECT,float3,float2,float2,int'] = 'float4',
						['usamplerRECT,float2,float2,float2,int'] = 'uint4',
					}
					local types = node.samp.get_type() .. ',' .. node.s.get_type() .. ',' .. node.dx.get_type() .. ',' .. node.dy.get_type() .. ',' .. node.texelOff.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = texRECT( r${node.samp.get_source().uid()}, r${node.s.get_source().uid()}, r${node.dx.get_source().uid()}, r${node.dy.get_source().uid()}, r${node.texelOff.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="tex1Dsize( samp, lod )">
		<description><![CDATA[
NAME

tex1Dsize - returns the size of a given texture image for a given level of detail.


SYNOPSIS

int3 tex1Dsize(sampler1D samp, int lod)
int3 tex1Dsize(isampler1D samp, int lod)
int3 tex1Dsize(usampler1D samp, int lod)


PARAMETERS

samp Sampler to be queried for size.
lod Level of detail to obtain size.


DESCRIPTION

Given a sampler and a level of detail the size of the corresponding texture image is returned as the result of
the operation.


REFERENCE IMPLEMENTATION



PROFILE SUPPORT

tex1Dsize is only supported in gp4 and newer profiles.


SEE ALSO

tex1D, tex1DARRAYsize.de Sh
\$1

		]]></description>
		<tool-tip><![CDATA[
			tex1Dsize - returns the size of a given texture image for a given level of detail.

		]]></tool-tip>
		<ports>
			<input name="samp">
				<check-type method="list" target="*">
					usampler1D,isampler1D,sampler1D
				</check-type>
			</input>
			<input name="lod">
				<check-type method="list" target="*">
					int
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['sampler1D,int'] = 'int3',
						['isampler1D,int'] = 'int3',
						['usampler1D,int'] = 'int3',
					}
					local types = node.samp.get_type() .. ',' .. node.lod.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = tex1Dsize( r${node.samp.get_source().uid()}, r${node.lod.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="texRECT( samp, s, dx, dy )">
		<description><![CDATA[
NAME

texRECT - performs a texture lookup in a given RECT sampler and, in some cases, a shadow comparison.
May also use pre computed derivatives if those are provided.


SYNOPSIS

float4 texRECT(samplerRECT samp, float2 s)
float4 texRECT(samplerRECT samp, float2 s, int texelOff)
float4 texRECT(samplerRECT samp, float3 s)
float4 texRECT(samplerRECT samp, float3 s, int texelOff)
float4 texRECT(samplerRECT samp, float2 s, float2 dx, float2 dy)
float4 texRECT(samplerRECT samp, float2 s, float2 dx, float2 dy, int texelOff)
float4 texRECT(samplerRECT samp, float3 s, float2 dx, float2 dy)
float4 texRECT(samplerRECT samp, float3 s, float2 dx, float2 dy, int texelOff)
int4 texRECT(isamplerRECT samp, float2 s)
int4 texRECT(isamplerRECT samp, float2 s, int texelOff)
int4 texRECT(isamplerRECT samp, float2 s, float2 dx, float2 dy)
int4 texRECT(isamplerRECT samp, float2 s, float2 dx, float2 dy, int texelOff)
uint4 texRECT(usamplerRECT samp, float2 s)
uint4 texRECT(usamplerRECT samp, float2 s, int texelOff)
uint4 texRECT(usamplerRECT samp, float2 s, float2 dx, float2 dy)
uint4 texRECT(usamplerRECT samp, float2 s, float2 dx, float2 dy,int texelOff)


PARAMETERS

samp Sampler to lookup.
s Coordinates to perform the lookup. If an extra coordinate compared to the texture dimensionality
is present it is used to perform a shadow comparison. The value used in the shadow comparison is
always the last component of the coordinate vector.
dx Pre computed derivative along the x axis.
dy Pre computed derivative along the y axis.
texelOff Offset to be added to obtain the final texel.


DESCRIPTION

Performs a texture lookup in sampler samp using coordinates s, may use and derivatives dx and dy, also
may perform shadow comparison and use texel offset texelOff to compute final texel.


REFERENCE IMPLEMENTATION



PROFILE SUPPORT

texRECT is supported in all fragment profiles and all vertex profiles starting with vp40, variants with
shadow comparison are only supported in fp40 and newer profiles, variants with texel offsets are only
supported in gp4 and newer profiles. Variants with integer samplers are only supported in gp4 and newer
profiles.


SEE ALSO

texRECTbias, texRECTlod, texRECTproj

		]]></description>
		<tool-tip><![CDATA[
			texRECT - performs a texture lookup in a given RECT sampler and, in some cases, a shadow comparison.
May also use pre computed derivatives if those are provided.

		]]></tool-tip>
		<ports>
			<input name="samp">
				<check-type method="list" target="*">
					isamplerRECT,usamplerRECT,samplerRECT
				</check-type>
			</input>
			<input name="s">
				<check-type method="list" target="*">
					float3,float2
				</check-type>
			</input>
			<input name="dx">
				<check-type method="list" target="*">
					float2
				</check-type>
			</input>
			<input name="dy">
				<check-type method="list" target="*">
					float2
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['usamplerRECT,float2,float2,float2'] = 'uint4',
						['isamplerRECT,float2,float2,float2'] = 'int4',
						['samplerRECT,float3,float2,float2'] = 'float4',
						['samplerRECT,float2,float2,float2'] = 'float4',
					}
					local types = node.samp.get_type() .. ',' .. node.s.get_type() .. ',' .. node.dx.get_type() .. ',' .. node.dy.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = texRECT( r${node.samp.get_source().uid()}, r${node.s.get_source().uid()}, r${node.dx.get_source().uid()}, r${node.dy.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="texBUF( samp, s )">
		<description><![CDATA[
NAME

texBUF - performs an unfiltered texture lookup in a given texture buffer sampler.


SYNOPSIS

float4 texBUF(samplerBUF samp, int s)
int4 texBUF(isamplerBUF samp, int s)
uint4 texBUF(usamplerBUF samp, int s)


PARAMETERS

samp Sampler to lookup.
s Coordinates to perform the lookup.


DESCRIPTION

Performs an unfiltered texture lookup in texture buffer sampler samp using coordinates s.
Texture buffer samplers are created with the EXT_texture_buffer_object extension. See:
http://developer.download.nvidia.com/opengl/specs/GL_EXT_texture_buffer_object.txt
Texture buffer object samplers roughly correspond to the tbuffer functionality of DirectX 10.


REFERENCE IMPLEMENTATION



PROFILE SUPPORT

texBUF is supported in gp4vp, gp4gp, and gp4fp profiles.


SEE ALSO

tex1D, texBUFsize

		]]></description>
		<tool-tip><![CDATA[
			texBUF - performs an unfiltered texture lookup in a given texture buffer sampler.

		]]></tool-tip>
		<ports>
			<input name="samp">
				<check-type method="list" target="*">
					usamplerBUF,isamplerBUF,samplerBUF
				</check-type>
			</input>
			<input name="s">
				<check-type method="list" target="*">
					int
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['samplerBUF,int'] = 'float4',
						['usamplerBUF,int'] = 'uint4',
						['isamplerBUF,int'] = 'int4',
					}
					local types = node.samp.get_type() .. ',' .. node.s.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = texBUF( r${node.samp.get_source().uid()}, r${node.s.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="isinf( x )">
		<description><![CDATA[
NAME

isinf - test whether or not a scalar or each vector component is infinite


SYNOPSIS

bool isinf(float x);
bool1 isinf(float1 x);
bool2 isinf(float2 x);
bool3 isinf(float3 x);
bool4 isinf(float4 x);
bool isinf(half x);
bool1 isinf(half1 x);
bool2 isinf(half2 x);
bool3 isinf(half3 x);
bool4 isinf(half4 x);
bool isinf(fixed x);
bool1 isinf(fixed1 x);
bool2 isinf(fixed2 x);
bool3 isinf(fixed3 x);
bool4 isinf(fixed4 x);


PARAMETERS

x Vector or scalar to test if infinite.


DESCRIPTION

Returns whether or not a scalar or each vector component is a (negative or positive) infinite value. Finite
and not-a-number (NaN) values are not infinite.


REFERENCE IMPLEMENTATION

isinf for float3 vectors could be implemented like this.
bool3 isinf(float3 x)
{
// By IEEE 754 rule, 2*Inf equals Inf
return (2*s == s) && (s != 0);
}


PROFILE SUPPORT

isinf is supported in all profiles except fp20.


SEE ALSO

isfinite, isnan

		]]></description>
		<tool-tip><![CDATA[
			isinf - test whether or not a scalar or each vector component is infinite

		]]></tool-tip>
		<ports>
			<input name="x">
				<check-type method="list" target="*">
					half4,float4,half,half3,half1,fixed1,fixed4,float1,fixed3,fixed2,float3,float,fixed,half2,float2
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['float4'] = 'bool4',
						['half2'] = 'bool2',
						['half1'] = 'bool1',
						['float'] = 'bool',
						['float1'] = 'bool1',
						['fixed2'] = 'bool2',
						['fixed4'] = 'bool4',
						['fixed3'] = 'bool3',
						['float3'] = 'bool3',
						['float2'] = 'bool2',
						['fixed1'] = 'bool1',
						['fixed'] = 'bool',
						['half3'] = 'bool3',
						['half4'] = 'bool4',
						['half'] = 'bool',
					}
					local types = node.x.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = isinf( r${node.x.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="floor( a )">
		<description><![CDATA[
NAME

floor - returns largest integer not greater than a scalar or each vector component.


SYNOPSIS

float floor(float a);
float1 floor(float1 a);
float2 floor(float2 a);
float3 floor(float3 a);
float4 floor(float4 a);
half floor(half a);
half1 floor(half1 a);
half2 floor(half2 a);
half3 floor(half3 a);
half4 floor(half4 a);
fixed floor(fixed a);
fixed1 floor(fixed1 a);
fixed2 floor(fixed2 a);
fixed3 floor(fixed3 a);
fixed4 floor(fixed4 a);


PARAMETERS

a Vector or scalar of which to determine the floor.


DESCRIPTION

Returns the floor or largest integer not greater than a scalar or each vector component.


REFERENCE IMPLEMENTATION

floor for a float3 vector could be implemented like this.
float3 floor(float3 v)
{
float3 rv;
int i;
for (i=0; i<3; i++) {
rv[i] = v[i] - frac(v[i]);
}
return rv;
}


PROFILE SUPPORT

floor is supported in all profiles except fp20.


SEE ALSO

ceil, round

		]]></description>
		<tool-tip><![CDATA[
			floor - returns largest integer not greater than a scalar or each vector component.

		]]></tool-tip>
		<ports>
			<input name="a">
				<check-type method="list" target="*">
					half4,float4,half,half3,half1,fixed1,fixed4,float1,fixed3,fixed2,float3,float,fixed,half2,float2
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['float4'] = 'float4',
						['half2'] = 'half2',
						['half1'] = 'half1',
						['float'] = 'float',
						['float1'] = 'float1',
						['fixed2'] = 'fixed2',
						['fixed4'] = 'fixed4',
						['fixed3'] = 'fixed3',
						['float3'] = 'float3',
						['float2'] = 'float2',
						['fixed1'] = 'fixed1',
						['fixed'] = 'fixed',
						['half3'] = 'half3',
						['half4'] = 'half4',
						['half'] = 'half',
					}
					local types = node.a.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = floor( r${node.a.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="tex1DARRAY( samp, s )">
		<description><![CDATA[
NAME

tex1DARRAY - performs a texture lookup in a given sampler array may use pre computed derivatives and,
in some cases, perform a shadow comparison.


SYNOPSIS

float4 tex1DARRAY(sampler1DARRAY samp, float2 s)
float4 tex1DARRAY(sampler1DARRAY samp, float2 s, int texelOff)
float4 tex1DARRAY(sampler1DARRAY samp, float3 s)
float4 tex1DARRAY(sampler1DARRAY samp, float3 s, int texelOff)
float4 tex1DARRAY(sampler1DARRAY samp, float2 s, float dx, float dy)
float4 tex1DARRAY(sampler1DARRAY samp, float2 s, float dx, float dy,int texelOff)
float4 tex1DARRAY(sampler1DARRAY samp, float3 s, float dx, float dy)
float4 tex1DARRAY(sampler1DARRAY samp, float3 s, float dx, float dy,int texelOff)
int4 tex1DARRAY(isampler1DARRAY samp, float2 s)
int4 tex1DARRAY(isampler1DARRAY samp, float2 s, int texelOff)
int4 tex1DARRAY(isampler1DARRAY samp, float2 s, float dx, float dy)
int4 tex1DARRAY(isampler1DARRAY samp, float2 s, float dx, float dy,int texelOff)
uint4 tex1DARRAY(usampler1DARRAY samp, float2 s)
uint4 tex1DARRAY(usampler1DARRAY samp, float2 s, int texelOff)
uint4 tex1DARRAY(usampler1DARRAY samp, float2 s, float dx, float dy)
uint4 tex1DARRAY(usampler1DARRAY samp, float2 s, float dx, float dy,int texelOff)


PARAMETERS

samp Sampler array to look up.
s Coordinates to perform the lookup. The value used to select the layer is passed immediatelly after
the regular coordinates, if an extra coordinate is present it is used to perform a shadow
comparison.
dx Pre computed derivative along the x axis.
dy Pre computed derivative along the y axis.
texelOff Offset to be added to obtain the final texel.


DESCRIPTION

Performs a texture lookup in sampler samp using coordinates s, the texture to be sampled is selected from
the layer specified in the coordinates. Also may use the derivatives dx and dy, the lookup may involve a
shadow comparison and use texel offset texelOff to compute the final texel.


REFERENCE IMPLEMENTATION



PROFILE SUPPORT

tex1DARRAY is only supported in gp4 and newer profiles.


SEE ALSO

tex1DARRAYbias, tex1DARRAYlod

		]]></description>
		<tool-tip><![CDATA[
			tex1DARRAY - performs a texture lookup in a given sampler array may use pre computed derivatives and,
in some cases, perform a shadow comparison.

		]]></tool-tip>
		<ports>
			<input name="samp">
				<check-type method="list" target="*">
					usampler1DARRAY,sampler1DARRAY,isampler1DARRAY
				</check-type>
			</input>
			<input name="s">
				<check-type method="list" target="*">
					float3,float2
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['usampler1DARRAY,float2'] = 'uint4',
						['sampler1DARRAY,float3'] = 'float4',
						['sampler1DARRAY,float2'] = 'float4',
						['isampler1DARRAY,float2'] = 'int4',
					}
					local types = node.samp.get_type() .. ',' .. node.s.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = tex1DARRAY( r${node.samp.get_source().uid()}, r${node.s.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="texCUBElod( samp, s )">
		<description><![CDATA[
NAME

texCUBElod - performs a texture lookup with a specified level of detail in a given sampler.


SYNOPSIS

float4 texCUBElod(samplerCUBE samp, float4 s)
int4 texCUBElod(isamplerCUBE samp, float4 s)
uint4 texCUBElod(usamplerCUBE samp, float4 s)


PARAMETERS

samp Sampler to lookup.
s Coordinates to perform the lookup. The level of detail should be passed as the last component of
the coordinate vector.


DESCRIPTION

Performs a texture lookup with a specified level of detail in sampler samp using coordinates s.


REFERENCE IMPLEMENTATION



PROFILE SUPPORT

texCUBElod is supported in fragment profiles starting with fp40 and in vertex profiles starting with vp40.
Variants with integer samplers are only supported in gp4 and newer profiles.


SEE ALSO

texCUBEbias.de Sh
\$1

		]]></description>
		<tool-tip><![CDATA[
			texCUBElod - performs a texture lookup with a specified level of detail in a given sampler.

		]]></tool-tip>
		<ports>
			<input name="samp">
				<check-type method="list" target="*">
					samplerCUBE,isamplerCUBE,usamplerCUBE
				</check-type>
			</input>
			<input name="s">
				<check-type method="list" target="*">
					float4
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['isamplerCUBE,float4'] = 'int4',
						['usamplerCUBE,float4'] = 'uint4',
						['samplerCUBE,float4'] = 'float4',
					}
					local types = node.samp.get_type() .. ',' .. node.s.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = texCUBElod( r${node.samp.get_source().uid()}, r${node.s.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="texCUBEARRAYsize( samp, lod )">
		<description><![CDATA[
NAME

texCUBEARRAYsize - returns the size of a given texture array image for a given level of detail.


SYNOPSIS

int3 texCUBEARRAYsize(samplerCUBEARRAY samp, int lod)
int3 texCUBEARRAYsize(isamplerCUBEARRAY samp, int lod)
int3 texCUBEARRAYsize(usamplerCUBEARRAY samp, int lod)


PARAMETERS

samp Sampler to be queried for size.
lod Level of detail to obtain size.


DESCRIPTION

Given a sampler array and a level of detail the size of one element of the corresponding texture array for a
given level of detail is returned as a result of the operation.


REFERENCE IMPLEMENTATION



PROFILE SUPPORT

texCUBEARRAYsize is only supported in gp4 and newer profiles.


SEE ALSO

texCUBEsize.de Sh
\$1

		]]></description>
		<tool-tip><![CDATA[
			texCUBEARRAYsize - returns the size of a given texture array image for a given level of detail.

		]]></tool-tip>
		<ports>
			<input name="samp">
				<check-type method="list" target="*">
					samplerCUBEARRAY,isamplerCUBEARRAY,usamplerCUBEARRAY
				</check-type>
			</input>
			<input name="lod">
				<check-type method="list" target="*">
					int
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['isamplerCUBEARRAY,int'] = 'int3',
						['samplerCUBEARRAY,int'] = 'int3',
						['usamplerCUBEARRAY,int'] = 'int3',
					}
					local types = node.samp.get_type() .. ',' .. node.lod.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = texCUBEARRAYsize( r${node.samp.get_source().uid()}, r${node.lod.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="texRECTbias( samp, s, texelOff )">
		<description><![CDATA[
NAME

texRECTbias - performs a texture lookup with bias in a given sampler.


SYNOPSIS

float4 texRECTbias(samplerRECT samp, float4 s)
float4 texRECTbias(samplerRECT samp, float4 s, int2 texelOff)
int4 texRECTbias(isamplerRECT samp, float4 s)
int4 texRECTbias(isamplerRECT samp, float4 s, int2 texelOff)
uint4 texRECTbias(usamplerRECT samp, float4 s)
uint4 texRECTbias(usamplerRECT samp, float4 s, int2 texelOff)


PARAMETERS

samp Sampler to lookup.
s Coordinates to perform the lookup. The bias value should be passed as the last component of the
coordinate vector.
texelOff Offset to be added to obtain the final texel.


DESCRIPTION

Performs a texture lookup with bias in sampler samp using coordinates s.


REFERENCE IMPLEMENTATION



PROFILE SUPPORT

texRECTbias is supported in fragment profiles starting with fp30 and in vertex profiles starting with vp40.
Variants with texelOff are only supported in gp4 and newer profiles. Variants with integer samplers are also
only suppported in gp4 and newer profiles.


SEE ALSO

texRECTlod.de Sh
\$1

		]]></description>
		<tool-tip><![CDATA[
			texRECTbias - performs a texture lookup with bias in a given sampler.

		]]></tool-tip>
		<ports>
			<input name="samp">
				<check-type method="list" target="*">
					isamplerRECT,usamplerRECT,samplerRECT
				</check-type>
			</input>
			<input name="s">
				<check-type method="list" target="*">
					float4
				</check-type>
			</input>
			<input name="texelOff">
				<check-type method="list" target="*">
					int2
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['usamplerRECT,float4,int2'] = 'uint4',
						['samplerRECT,float4,int2'] = 'float4',
						['isamplerRECT,float4,int2'] = 'int4',
					}
					local types = node.samp.get_type() .. ',' .. node.s.get_type() .. ',' .. node.texelOff.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = texRECTbias( r${node.samp.get_source().uid()}, r${node.s.get_source().uid()}, r${node.texelOff.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="texCUBE( samp, s, dx, dy )">
		<description><![CDATA[
NAME

texCUBE - performs a texture lookup in a given CUBE sampler and, in some cases, a shadow comparison.
May also use pre computed derivatives if those are provided.


SYNOPSIS

float4 texCUBE(samplerCUBE samp, float3 s)
float4 texCUBE(samplerCUBE samp, float4 s)
float4 texCUBE(samplerCUBE samp, float3 s, float3 dx, float3 dy)
float4 texCUBE(samplerCUBE samp, float4 s, float3 dx, float3 dy)
int4 texCUBE(isamplerCUBE samp, float3 s)
int4 texCUBE(isamplerCUBE samp, float3 s, float3 dx, float3 dy)
uint4 texCUBE(usamplerCUBE samp, float3 s)
uint4 texCUBE(usamplerCUBE samp, float3 s, float3 dx, float3 dy)


PARAMETERS

samp Sampler to lookup.
s Coordinates to perform the lookup. If an extra coordinate compared to the texture dimensionality
is present it is used to perform a shadow comparison. The value used in the shadow comparison is
always the last component of the coordinate vector.
dx Pre computed derivative along the x axis.
dy Pre computed derivative along the y axis.


DESCRIPTION

Performs a texture lookup in sampler samp using coordinates s, may use and derivatives dx and dy, also
may perform shadow comparison.


REFERENCE IMPLEMENTATION



PROFILE SUPPORT

texCUBE is supported in all fragment profiles and all vertex profiles starting with vp40, variants with
shadow comparison are only supported in gp4 and newer profiles. Variants with integer samplers are also
only suppported in gp4 and newer profiles.


SEE ALSO

texCUBEbias, texCUBElod, texCUBEproj

		]]></description>
		<tool-tip><![CDATA[
			texCUBE - performs a texture lookup in a given CUBE sampler and, in some cases, a shadow comparison.
May also use pre computed derivatives if those are provided.

		]]></tool-tip>
		<ports>
			<input name="samp">
				<check-type method="list" target="*">
					samplerCUBE,isamplerCUBE,usamplerCUBE
				</check-type>
			</input>
			<input name="s">
				<check-type method="list" target="*">
					float3,float4
				</check-type>
			</input>
			<input name="dx">
				<check-type method="list" target="*">
					float3
				</check-type>
			</input>
			<input name="dy">
				<check-type method="list" target="*">
					float3
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['usamplerCUBE,float3,float3,float3'] = 'uint4',
						['samplerCUBE,float4,float3,float3'] = 'float4',
						['samplerCUBE,float3,float3,float3'] = 'float4',
						['isamplerCUBE,float3,float3,float3'] = 'int4',
					}
					local types = node.samp.get_type() .. ',' .. node.s.get_type() .. ',' .. node.dx.get_type() .. ',' .. node.dy.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = texCUBE( r${node.samp.get_source().uid()}, r${node.s.get_source().uid()}, r${node.dx.get_source().uid()}, r${node.dy.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="texBUFsize( samp, lod )">
		<description><![CDATA[
NAME

texBUFsize - returns the size of a given texture image for a given level of detail.


SYNOPSIS

int3 texBUFsize(samplerBUF samp, int lod)
int3 texBUFsize(isamplerBUF samp, int lod)
int3 texBUFsize(usamplerBUF samp, int lod)


PARAMETERS

samp Sampler to be queried for size.
lod Level of detail to obtain size.


DESCRIPTION

Given a sampler and a level of detail the size (width in x, height in y, and depth in z) of the corresponding
texture buffer is returned as the result of the operation.
Because texture buffers lack mipmaps, the lod parameter is unused.
Texture buffer samplers are created with the EXT_texture_buffer_object extension. See:
http://developer.download.nvidia.com/opengl/specs/GL_EXT_texture_buffer_object.txt
Texture buffer object samplers roughly correspond to the tbuffer functionality of DirectX 10.


REFERENCE IMPLEMENTATION



PROFILE SUPPORT

texBUF is supported in gp4vp, gp4gp, and gp4fp profiles.


SEE ALSO

tex1Dsize, texBUFsize

		]]></description>
		<tool-tip><![CDATA[
			texBUFsize - returns the size of a given texture image for a given level of detail.

		]]></tool-tip>
		<ports>
			<input name="samp">
				<check-type method="list" target="*">
					usamplerBUF,isamplerBUF,samplerBUF
				</check-type>
			</input>
			<input name="lod">
				<check-type method="list" target="*">
					int
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['samplerBUF,int'] = 'int3',
						['usamplerBUF,int'] = 'int3',
						['isamplerBUF,int'] = 'int3',
					}
					local types = node.samp.get_type() .. ',' .. node.lod.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = texBUFsize( r${node.samp.get_source().uid()}, r${node.lod.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="sqrt( a )">
		<description><![CDATA[
NAME

sqrt - returns the square root of a scalar or each vector component.


SYNOPSIS

float sqrt(float a);
float1 sqrt(float1 a);
float2 sqrt(float2 a);
float3 sqrt(float3 a);
float4 sqrt(float4 a);
half sqrt(half a);
half1 sqrt(half1 a);
half2 sqrt(half2 a);
half3 sqrt(half3 a);
half4 sqrt(half4 a);
fixed sqrt(fixed a);
fixed1 sqrt(fixed1 a);
fixed2 sqrt(fixed2 a);
fixed3 sqrt(fixed3 a);
fixed4 sqrt(fixed4 a);


PARAMETERS

a Vector or scalar of which to return the square root.


DESCRIPTION

Returns the square root of a scalar or each vector component.


REFERENCE IMPLEMENTATION

(Missing)


PROFILE SUPPORT

(Missing)


SEE ALSO

(Missing)

		]]></description>
		<tool-tip><![CDATA[
			sqrt - returns the square root of a scalar or each vector component.

		]]></tool-tip>
		<ports>
			<input name="a">
				<check-type method="list" target="*">
					half4,float4,half,half3,half1,fixed1,fixed4,float1,fixed3,fixed2,float3,float,fixed,half2,float2
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['float4'] = 'float4',
						['half2'] = 'half2',
						['half1'] = 'half1',
						['float'] = 'float',
						['float1'] = 'float1',
						['fixed2'] = 'fixed2',
						['fixed4'] = 'fixed4',
						['fixed3'] = 'fixed3',
						['float3'] = 'float3',
						['float2'] = 'float2',
						['fixed1'] = 'fixed1',
						['fixed'] = 'fixed',
						['half3'] = 'half3',
						['half4'] = 'half4',
						['half'] = 'half',
					}
					local types = node.a.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = sqrt( r${node.a.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="tex2DARRAYbias( samp, s )">
		<description><![CDATA[
NAME

tex2DARRAYbias - performs a texture lookup with bias in a given sampler array.


SYNOPSIS

float4 tex2DARRAYbias(sampler2DARRAY samp, float4 s)
float4 tex2DARRAYbias(sampler2DARRAY samp, float4 s, int texelOff)
int4 tex2DARRAYbias(isampler2DARRAY samp, float4 s)
int4 tex2DARRAYbias(isampler2DARRAY samp, float4 s, int texelOff)
uint4 tex2DARRAYbias(usampler2DARRAY samp, float4 s)
uint4 tex2DARRAYbias(usampler2DARRAY samp, float4 s, int texelOff)


PARAMETERS

samp Sampler array to lookup.
s Coordinates to perform the lookup. The value used to select the layer should be passed in the
vector component right after the regular coordinates. The bias value should be passed as the last
component of the coordinate vector.
texelOff Offset to be added to obtain the final texel.


DESCRIPTION

Performs a texture lookup with bias in sampler samp using coordinates s, the texture to be sampled is
selected from the layer specified in the coordinates.


REFERENCE IMPLEMENTATION



PROFILE SUPPORT

tex2DARRAYbias is only supported in gp4 and newer profiles.


SEE ALSO

tex2DARRAY, tex2DARRAYlod

		]]></description>
		<tool-tip><![CDATA[
			tex2DARRAYbias - performs a texture lookup with bias in a given sampler array.

		]]></tool-tip>
		<ports>
			<input name="samp">
				<check-type method="list" target="*">
					usampler2DARRAY,isampler2DARRAY,sampler2DARRAY
				</check-type>
			</input>
			<input name="s">
				<check-type method="list" target="*">
					float4
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['usampler2DARRAY,float4'] = 'uint4',
						['sampler2DARRAY,float4'] = 'float4',
						['isampler2DARRAY,float4'] = 'int4',
					}
					local types = node.samp.get_type() .. ',' .. node.s.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = tex2DARRAYbias( r${node.samp.get_source().uid()}, r${node.s.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="texCUBEsize( samp, lod )">
		<description><![CDATA[
NAME

texCUBEsize - returns the size of a given texture image for a given level of detail.


SYNOPSIS

int3 texCUBEsize(samplerCUBE samp, int lod)
int3 texCUBEsize(isamplerCUBE samp, int lod)
int3 texCUBEsize(usamplerCUBE samp, int lod)


PARAMETERS

samp Sampler to be queried for size.
lod Level of detail to obtain size.


DESCRIPTION

Given a sampler and a level of detail the size of the corresponding texture image is returned as the result of
the operation.


REFERENCE IMPLEMENTATION



PROFILE SUPPORT

texCUBEsize is only supported in gp4 and newer profiles.


SEE ALSO

texCUBE

		]]></description>
		<tool-tip><![CDATA[
			texCUBEsize - returns the size of a given texture image for a given level of detail.

		]]></tool-tip>
		<ports>
			<input name="samp">
				<check-type method="list" target="*">
					samplerCUBE,isamplerCUBE,usamplerCUBE
				</check-type>
			</input>
			<input name="lod">
				<check-type method="list" target="*">
					int
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['samplerCUBE,int'] = 'int3',
						['usamplerCUBE,int'] = 'int3',
						['isamplerCUBE,int'] = 'int3',
					}
					local types = node.samp.get_type() .. ',' .. node.lod.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = texCUBEsize( r${node.samp.get_source().uid()}, r${node.lod.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="tex3Dproj( samp, s, texelOff )">
		<description><![CDATA[
NAME

tex3Dproj - performs a texture lookup with projection in a given sampler. May perform a shadow
comparison if argument for shadow comparison is provided.


SYNOPSIS

float4 tex3Dproj(sampler3D samp, float4 s)
float4 tex3Dproj(sampler3D samp, float4 s, int texelOff)
int4 tex3Dproj(isampler3D samp, float4 s)
int4 tex3Dproj(isampler3D samp, float4 s, int texelOff)
uint4 tex3Dproj(usampler3D samp, float4 s)
uint4 tex3Dproj(usampler3D samp, float4 s, int texelOff)


PARAMETERS

samp Sampler to lookup.
s Coordinates to perform the lookup. The value used in the projection should be passed as the last
component of the coordinate vector. The value used in the shadow comparison, if present, should
be passed as the next-to-last component of the coordinate vector.
texelOff Offset to be added to obtain the final texel.


DESCRIPTION

Performs a texture lookup in sampler samp using coordinates s, the coordinates used in the lookup are first
projected, that is, divided by the last component of the coordinate vector and them used in the lookup. If an
extra coordinate is present it is used to perform a shadow comparison, the value used in the shadow
comparison is always the next-to-last component in the coordinate vector.


REFERENCE IMPLEMENTATION



PROFILE SUPPORT

tex3Dproj is supported in all fragment profiles and all vertex profiles starting with vp40, variants with
shadow comparison are only supported in fp40 and newer profiles, variants with texel offsets are only
supported in gp4 and newer profiles.


SEE ALSO

tex3D

		]]></description>
		<tool-tip><![CDATA[
			tex3Dproj - performs a texture lookup with projection in a given sampler. May perform a shadow
comparison if argument for shadow comparison is provided.

		]]></tool-tip>
		<ports>
			<input name="samp">
				<check-type method="list" target="*">
					sampler3D,usampler3D,isampler3D
				</check-type>
			</input>
			<input name="s">
				<check-type method="list" target="*">
					float4
				</check-type>
			</input>
			<input name="texelOff">
				<check-type method="list" target="*">
					int
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['usampler3D,float4,int'] = 'uint4',
						['sampler3D,float4,int'] = 'float4',
						['isampler3D,float4,int'] = 'int4',
					}
					local types = node.samp.get_type() .. ',' .. node.s.get_type() .. ',' .. node.texelOff.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = tex3Dproj( r${node.samp.get_source().uid()}, r${node.s.get_source().uid()}, r${node.texelOff.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="isfinite( x )">
		<description><![CDATA[
NAME

isfinite - test whether or not a scalar or each vector component is a finite value


SYNOPSIS

bool isfinite(float x);
bool1 isfinite(float1 x);
bool2 isfinite(float2 x);
bool3 isfinite(float3 x);
bool4 isfinite(float4 x);
bool isfinite(half x);
bool1 isfinite(half1 x);
bool2 isfinite(half2 x);
bool3 isfinite(half3 x);
bool4 isfinite(half4 x);
bool isfinite(fixed x);
bool1 isfinite(fixed1 x);
bool2 isfinite(fixed2 x);
bool3 isfinite(fixed3 x);
bool4 isfinite(fixed4 x);


PARAMETERS

x Vector or scalar to test for finiteness.


DESCRIPTION

Returns whether or not a scalar or each vector component is a finite value. Infinity and not-a-number
(NaN) values are not finite.


REFERENCE IMPLEMENTATION

isfinite for float3 vectors could be implemented like this.
bool3 isfinite(float3 x)
{
// By IEEE 754 rule, 2*Inf equals Inf
return (s == s) && ((s == 0) || (s != 2*s));
}


PROFILE SUPPORT

isfinite is supported in all profiles except fp20.


SEE ALSO

isinf, isnan

		]]></description>
		<tool-tip><![CDATA[
			isfinite - test whether or not a scalar or each vector component is a finite value

		]]></tool-tip>
		<ports>
			<input name="x">
				<check-type method="list" target="*">
					half4,float4,half,half3,half1,fixed1,fixed4,float1,fixed3,fixed2,float3,float,fixed,half2,float2
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['float4'] = 'bool4',
						['half2'] = 'bool2',
						['half1'] = 'bool1',
						['float'] = 'bool',
						['float1'] = 'bool1',
						['fixed2'] = 'bool2',
						['fixed4'] = 'bool4',
						['fixed3'] = 'bool3',
						['float3'] = 'bool3',
						['float2'] = 'bool2',
						['fixed1'] = 'bool1',
						['fixed'] = 'bool',
						['half3'] = 'bool3',
						['half4'] = 'bool4',
						['half'] = 'bool',
					}
					local types = node.x.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = isfinite( r${node.x.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="tex3Dlod( samp, s )">
		<description><![CDATA[
NAME

tex3Dlod - performs a texture lookup with a specified level of detail in a given sampler.


SYNOPSIS

float4 tex3Dlod(sampler3D samp, float4 s)
float4 tex3Dlod(sampler3D samp, float4 s, int texelOff)
int4 tex3Dlod(isampler3D samp, float4 s)
int4 tex3Dlod(isampler3D samp, float4 s, int texelOff)
uint4 tex3Dlod(usampler3D samp, float4 s)
uint4 tex3Dlod(usampler3D samp, float4 s, int texelOff)


PARAMETERS

samp Sampler to lookup.
s Coordinates to perform the lookup. The level of detail should be passed as the last component of
the coordinate vector.
texelOff Offset to be added to obtain the final texel.


DESCRIPTION

Performs a texture lookup with a specified level of detail in sampler samp using coordinates s.


REFERENCE IMPLEMENTATION



PROFILE SUPPORT

tex3Dlod is supported in fragment profiles starting with fp40 and in vertex profiles starting with vp40.
Variants with texelOff are only supported in gp4 and newer profiles. Variants with integer samplers are also
only suppported in gp4 and newer profiles.


SEE ALSO

tex3Dbias.de Sh
\$1

		]]></description>
		<tool-tip><![CDATA[
			tex3Dlod - performs a texture lookup with a specified level of detail in a given sampler.

		]]></tool-tip>
		<ports>
			<input name="samp">
				<check-type method="list" target="*">
					sampler3D,usampler3D,isampler3D
				</check-type>
			</input>
			<input name="s">
				<check-type method="list" target="*">
					float4
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['sampler3D,float4'] = 'float4',
						['usampler3D,float4'] = 'uint4',
						['isampler3D,float4'] = 'int4',
					}
					local types = node.samp.get_type() .. ',' .. node.s.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = tex3Dlod( r${node.samp.get_source().uid()}, r${node.s.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="floatToRawIntBits( x )">
		<description><![CDATA[
NAME

floatToRawIntBits - returns the raw 32-bit integer representation of an IEEE 754 floating-point scalar or
vector


SYNOPSIS

int floatToRawIntBits(float x);
int1 floatToRawIntBits(float1 x);
int2 floatToRawIntBits(float2 x);
int3 floatToRawIntBits(float3 x);
int4 floatToRawIntBits(float4 x);


PARAMETERS

x Floating-point vector or scalar to raw cast to a scalar int or vector of ints.


DESCRIPTION

Returns a representation of the specified floating-point scalar value or vector values according to the IEEE
754 floating-point "single format" bit layout, preserving Not-a-Number (NaN) values.
This function is based on Java's jave.lang.Float method of the same name. See:
http://java.sun.com/j2se/1.4.2/docs/api/java/lang/Float.html
The Cg compiler can typically optimize floatToRawIntBits so it has no instruction cost.


REFERENCE IMPLEMENTATION

floatToRawIntBits operates consistent with the following ANSI C code:
int floatToRawIntBits(float x)
{
union {
float f; // assuming 32-bit IEEE 754 single-precision
int i; // assuming 32-bit 2's complement int
} u;
u.f = x;
return u.i;
}


PROFILE SUPPORT

floatToRawIntBits is supported by the gp4vp, gp4gp, and gp4vp profiles.
floatToRawIntBits is not supported by pre-G80 profiles.


SEE ALSO

ceil, floatToIntBits, floor, intBitsToFloat, round, trunc

		]]></description>
		<tool-tip><![CDATA[
			floatToRawIntBits - returns the raw 32-bit integer representation of an IEEE 754 floating-point scalar or
vector

		]]></tool-tip>
		<ports>
			<input name="x">
				<check-type method="list" target="*">
					float3,float4,float,float1,float2
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['float4'] = 'int4',
						['float3'] = 'int3',
						['float2'] = 'int2',
						['float'] = 'int',
						['float1'] = 'int1',
					}
					local types = node.x.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = floatToRawIntBits( r${node.x.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="log10( a )">
		<description><![CDATA[
NAME

log10 - returns the base-10 logarithm of scalars and vectors


SYNOPSIS

float log10(float a);
float1 log10(float1 a);
float2 log10(float2 a);
float3 log10(float3 a);
float4 log10(float4 a);
half log10(half a);
half1 log10(half1 a);
half2 log10(half2 a);
half3 log10(half3 a);
half4 log10(half4 a);
fixed log10(fixed a);
fixed1 log10(fixed1 a);
fixed2 log10(fixed2 a);
fixed3 log10(fixed3 a);
fixed4 log10(fixed4 a);


PARAMETERS

a Vector or scalar of which to determine the base-10 logarithm.


DESCRIPTION

Returns the base-10 logarithm a.
For vectors, the returned vector contains the base-10 logarithm of each element of the input vector.


REFERENCE IMPLEMENTATION

float3 log10(float3 a)
{
float3 rv;
int i;
for (i=0; i<3; i++) {
rv[i] = log10(a[i]); // this is the ANSI C standard library log10()
}
return rv;
}
log10 is typically implemented with a native base-10 logarithm instruction.


PROFILE SUPPORT

log10 is fully supported in all profiles unless otherwise specified.
Support in the fp20 is limited to constant compile-time evaluation.


SEE ALSO

exp, log, log2, pow

		]]></description>
		<tool-tip><![CDATA[
			log10 - returns the base-10 logarithm of scalars and vectors

		]]></tool-tip>
		<ports>
			<input name="a">
				<check-type method="list" target="*">
					half4,float4,half,half3,half1,fixed1,fixed4,float1,fixed3,fixed2,float3,float,fixed,half2,float2
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['float4'] = 'float4',
						['half2'] = 'half2',
						['half1'] = 'half1',
						['float'] = 'float',
						['float1'] = 'float1',
						['fixed2'] = 'fixed2',
						['fixed4'] = 'fixed4',
						['fixed3'] = 'fixed3',
						['float3'] = 'float3',
						['float2'] = 'float2',
						['fixed1'] = 'fixed1',
						['fixed'] = 'fixed',
						['half3'] = 'half3',
						['half4'] = 'half4',
						['half'] = 'half',
					}
					local types = node.a.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = log10( r${node.a.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="tex2DARRAYbias( samp, s, texelOff )">
		<description><![CDATA[
NAME

tex2DARRAYbias - performs a texture lookup with bias in a given sampler array.


SYNOPSIS

float4 tex2DARRAYbias(sampler2DARRAY samp, float4 s)
float4 tex2DARRAYbias(sampler2DARRAY samp, float4 s, int texelOff)
int4 tex2DARRAYbias(isampler2DARRAY samp, float4 s)
int4 tex2DARRAYbias(isampler2DARRAY samp, float4 s, int texelOff)
uint4 tex2DARRAYbias(usampler2DARRAY samp, float4 s)
uint4 tex2DARRAYbias(usampler2DARRAY samp, float4 s, int texelOff)


PARAMETERS

samp Sampler array to lookup.
s Coordinates to perform the lookup. The value used to select the layer should be passed in the
vector component right after the regular coordinates. The bias value should be passed as the last
component of the coordinate vector.
texelOff Offset to be added to obtain the final texel.


DESCRIPTION

Performs a texture lookup with bias in sampler samp using coordinates s, the texture to be sampled is
selected from the layer specified in the coordinates.


REFERENCE IMPLEMENTATION



PROFILE SUPPORT

tex2DARRAYbias is only supported in gp4 and newer profiles.


SEE ALSO

tex2DARRAY, tex2DARRAYlod

		]]></description>
		<tool-tip><![CDATA[
			tex2DARRAYbias - performs a texture lookup with bias in a given sampler array.

		]]></tool-tip>
		<ports>
			<input name="samp">
				<check-type method="list" target="*">
					usampler2DARRAY,isampler2DARRAY,sampler2DARRAY
				</check-type>
			</input>
			<input name="s">
				<check-type method="list" target="*">
					float4
				</check-type>
			</input>
			<input name="texelOff">
				<check-type method="list" target="*">
					int
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['sampler2DARRAY,float4,int'] = 'float4',
						['isampler2DARRAY,float4,int'] = 'int4',
						['usampler2DARRAY,float4,int'] = 'uint4',
					}
					local types = node.samp.get_type() .. ',' .. node.s.get_type() .. ',' .. node.texelOff.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = tex2DARRAYbias( r${node.samp.get_source().uid()}, r${node.s.get_source().uid()}, r${node.texelOff.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="tex1D( samp, s, dx, dy )">
		<description><![CDATA[
NAME

tex1D - performs a texture lookup in a given 1D sampler and, in some cases, a shadow comparison. May
also use pre computed derivatives if those are provided.


SYNOPSIS

float4 tex1D(sampler1D samp, float s)
float4 tex1D(sampler1D samp, float s, int texelOff)
float4 tex1D(sampler1D samp, float2 s)
float4 tex1D(sampler1D samp, float2 s, int texelOff)
float4 tex1D(sampler1D samp, float s, float dx, float dy)
float4 tex1D(sampler1D samp, float s, float dx, float dy, int texelOff)
float4 tex1D(sampler1D samp, float2 s, float dx, float dy)
float4 tex1D(sampler1D samp, float2 s, float dx, float dy, int texelOff)
int4 tex1D(isampler1D samp, float s);
int4 tex1D(isampler1D samp, float s, int texelOff);
int4 tex1D(isampler1D samp, float s, float dx, float dy)
int4 tex1D(isampler1D samp, float s, float dx, float dy, int texelOff)
uint4 tex1D(usampler1D samp, float s);
uint4 tex1D(usampler1D samp, float s, int texelOff);
uint4 tex1D(usampler1D samp, float s, float dx, float dy)
uint4 tex1D(usampler1D samp, float s, float dx, float dy,int texelOff)


PARAMETERS

samp Sampler to lookup.
s Coordinates to perform the lookup. If an extra coordinate compared to the texture dimensionality
is present it is used to perform a shadow comparison. The value used in the shadow comparison is
always the last component of the coordinate vector.
dx Pre computed derivative along the x axis.
dy Pre computed derivative along the y axis.
texelOff Offset to be added to obtain the final texel.


DESCRIPTION

Performs a texture lookup in sampler samp using coordinates s, may use and derivatives dx and dy, also
may perform shadow comparison and use texel offset texelOff to compute final texel.


REFERENCE IMPLEMENTATION



PROFILE SUPPORT

tex1D is supported in all fragment profiles and all vertex profiles starting with vp40, variants with shadow
comparison are only supported in fp40 and newer profiles, variants with texel offsets are only supported in
gp4 and newer profiles, variants with integer textures are also only supported in gp4 and newer profiles.


SEE ALSO

tex1Dbias, tex1Dlod, tex1Dproj

		]]></description>
		<tool-tip><![CDATA[
			tex1D - performs a texture lookup in a given 1D sampler and, in some cases, a shadow comparison. May
also use pre computed derivatives if those are provided.

		]]></tool-tip>
		<ports>
			<input name="samp">
				<check-type method="list" target="*">
					usampler1D,isampler1D,sampler1D
				</check-type>
			</input>
			<input name="s">
				<check-type method="list" target="*">
					float,float2
				</check-type>
			</input>
			<input name="dx">
				<check-type method="list" target="*">
					float
				</check-type>
			</input>
			<input name="dy">
				<check-type method="list" target="*">
					float
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['usampler1D,float,float,float'] = 'uint4',
						['sampler1D,float2,float,float'] = 'float4',
						['sampler1D,float,float,float'] = 'float4',
						['isampler1D,float,float,float'] = 'int4',
					}
					local types = node.samp.get_type() .. ',' .. node.s.get_type() .. ',' .. node.dx.get_type() .. ',' .. node.dy.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = tex1D( r${node.samp.get_source().uid()}, r${node.s.get_source().uid()}, r${node.dx.get_source().uid()}, r${node.dy.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="tex2D( samp, s, texelOff )">
		<description><![CDATA[
NAME

tex2D - performs a texture lookup in a given 2D sampler and, in some cases, a shadow comparison. May
also use pre computed derivatives if those are provided.


SYNOPSIS

float4 tex2D(sampler2D samp, float2 s)
float4 tex2D(sampler2D samp, float2 s, int texelOff)
float4 tex2D(sampler2D samp, float3 s)
float4 tex2D(sampler2D samp, float3 s, int texelOff)
float4 tex2D(sampler2D samp, float2 s, float2 dx, float2 dy)
float4 tex2D(sampler2D samp, float2 s, float2 dx, float2 dy, int texelOff)
float4 tex2D(sampler2D samp, float3 s, float2 dx, float2 dy)
float4 tex2D(sampler2D samp, float3 s, float2 dx, float2 dy, int texelOff)
int4 tex2D(isampler2D samp, float2 s)
int4 tex2D(isampler2D samp, float2 s, int texelOff)
int4 tex2D(isampler2D samp, float2 s, float2 dx, float2 dy)
int4 tex2D(isampler2D samp, float2 s, float2 dx, float2 dy, int texelOff)
uint4 tex2D(usampler2D samp, float2 s)
uint4 tex2D(usampler2D samp, float2 s, int texelOff)
uint4 tex2D(usampler2D samp, float2 s, float2 dx, float2 dy)
uint4 tex2D(usampler2D samp, float2 s, float2 dx, float2 dy,int texelOff)


PARAMETERS

samp Sampler to lookup.
s Coordinates to perform the lookup. If an extra coordinate compared to the texture dimensionality
is present it is used to perform a shadow comparison. The value used in the shadow comparison is
always the last component of the coordinate vector.
dx Pre computed derivative along the x axis.
dy Pre computed derivative along the y axis.
texelOff Offset to be added to obtain the final texel.


DESCRIPTION

Performs a texture lookup in sampler samp using coordinates s, may use and derivatives dx and dy, also
may perform shadow comparison and use texel offset texelOff to compute final texel.


REFERENCE IMPLEMENTATION



PROFILE SUPPORT

tex2D is supported in all fragment profiles and all vertex profiles starting with vp40, variants with shadow
comparison are only supported in fp40 and newer profiles, variants with texel offsets are only supported in
gp4 and newer profiles. Variants with integer textures are also only supported in gp4 and newer profiles.


SEE ALSO

tex2Dbias, tex2Dlod, tex2Dproj

		]]></description>
		<tool-tip><![CDATA[
			tex2D - performs a texture lookup in a given 2D sampler and, in some cases, a shadow comparison. May
also use pre computed derivatives if those are provided.

		]]></tool-tip>
		<ports>
			<input name="samp">
				<check-type method="list" target="*">
					sampler2D,isampler2D,usampler2D
				</check-type>
			</input>
			<input name="s">
				<check-type method="list" target="*">
					float3,float2
				</check-type>
			</input>
			<input name="texelOff">
				<check-type method="list" target="*">
					int
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['sampler2D,float3,int'] = 'float4',
						['usampler2D,float2,int'] = 'uint4',
						['sampler2D,float2,int'] = 'float4',
						['isampler2D,float2,int'] = 'int4',
					}
					local types = node.samp.get_type() .. ',' .. node.s.get_type() .. ',' .. node.texelOff.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = tex2D( r${node.samp.get_source().uid()}, r${node.s.get_source().uid()}, r${node.texelOff.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="tex2Dproj( samp, s, texelOff )">
		<description><![CDATA[
NAME

tex2Dproj - performs a texture lookup with projection in a given sampler. May perform a shadow
comparison if argument for shadow comparison is provided.


SYNOPSIS

float4 tex2Dproj(sampler2D samp, float3 s)
float4 tex2Dproj(sampler2D samp, float3 s, int texelOff)
float4 tex2Dproj(sampler2D samp, float4 s)
float4 tex2Dproj(sampler2D samp, float4 s, int texelOff)
int4 tex2Dproj(isampler2D samp, float3 s)
int4 tex2Dproj(isampler2D samp, float3 s, int texelOff)
uint4 tex2Dproj(usampler2D samp, float3 s)
uint4 tex2Dproj(usampler2D samp, float3 s, int texelOff)


PARAMETERS

samp Sampler to lookup.
s Coordinates to perform the lookup. The value used in the projection should be passed as the last
component of the coordinate vector. The value used in the shadow comparison, if present, should
be passed as the next-to-last component of the coordinate vector.
texelOff Offset to be added to obtain the final texel.


DESCRIPTION

Performs a texture lookup in sampler samp using coordinates s, the coordinates used in the lookup are first
projected, that is, divided by the last component of the coordinate vector and them used in the lookup. If an
extra coordinate is present it is used to perform a shadow comparison, the value used in the shadow
comparison is always the next-to-last component in the coordinate vector.


REFERENCE IMPLEMENTATION



PROFILE SUPPORT

tex2Dproj is supported in all fragment profiles and all vertex profiles starting with vp40, variants with
shadow comparison are only supported in fp40 and newer profiles, variants with texel offsets are only
supported in gp4 and newer profiles.


SEE ALSO

tex2D, tex2DARRAYproj

		]]></description>
		<tool-tip><![CDATA[
			tex2Dproj - performs a texture lookup with projection in a given sampler. May perform a shadow
comparison if argument for shadow comparison is provided.

		]]></tool-tip>
		<ports>
			<input name="samp">
				<check-type method="list" target="*">
					sampler2D,isampler2D,usampler2D
				</check-type>
			</input>
			<input name="s">
				<check-type method="list" target="*">
					float3,float4
				</check-type>
			</input>
			<input name="texelOff">
				<check-type method="list" target="*">
					int
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['sampler2D,float3,int'] = 'float4',
						['isampler2D,float3,int'] = 'int4',
						['sampler2D,float4,int'] = 'float4',
						['usampler2D,float3,int'] = 'uint4',
					}
					local types = node.samp.get_type() .. ',' .. node.s.get_type() .. ',' .. node.texelOff.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = tex2Dproj( r${node.samp.get_source().uid()}, r${node.s.get_source().uid()}, r${node.texelOff.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="refract( i, n, eta )">
		<description><![CDATA[
NAME

refract - computes a refraction vector.


SYNOPSIS

fixed3 refract(fixed3 i, fixed3 n, fixed eta);
half3 refract(half3 i, half3 n, half eta);
float3 refract(float3 i, float3 n, float eta);


PARAMETERS

i Incidence vector.
n Normal vector.
eta Ratio of indices of refraction at the surface interface.


DESCRIPTION

Returns a refraction vector given an incidence vector, a normal vector for a surface, and a ratio of indices of
refraction at the surface's interface.
The incidence vector i and normal vector n should be normalized.


REFERENCE IMPLEMENTATION

reflect for float3 vectors could be implemented this way:
float3 refract( float3 i, float3 n, float eta )
{
float cosi = dot(-i, n);
float cost2 = 1.0f - eta * eta * (1.0f - cosi*cosi);
float3 t = eta*i + ((eta*cosi - sqrt(abs(cost2))) * n);
return t * (float3)(cost2 > 0);
}


PROFILE SUPPORT

refract is supported in all profiles.
Support in the fp20 is limited.


SEE ALSO

abs, cos, dot, reflect, sqrt

		]]></description>
		<tool-tip><![CDATA[
			refract - computes a refraction vector.

		]]></tool-tip>
		<ports>
			<input name="i">
				<check-type method="list" target="*">
					fixed3,float3,half3
				</check-type>
			</input>
			<input name="n">
				<check-type method="list" target="*">
					fixed3,float3,half3
				</check-type>
			</input>
			<input name="eta">
				<check-type method="list" target="*">
					float,fixed,half
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['half3,half3,half'] = 'half3',
						['float3,float3,float'] = 'float3',
						['fixed3,fixed3,fixed'] = 'fixed3',
					}
					local types = node.i.get_type() .. ',' .. node.n.get_type() .. ',' .. node.eta.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = refract( r${node.i.get_source().uid()}, r${node.n.get_source().uid()}, r${node.eta.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="tex1DARRAYcmpbias( samp, s, texelOff )">
		<description><![CDATA[
NAME

tex1DARRAYcmpbias - performs a texture lookup with shadow compare and bias in a given sampler
array.


SYNOPSIS

float4 tex1DARRAYcmpbias(sampler1DARRAY samp, float4 s)
float4 tex1DARRAYcmpbias(sampler1DARRAY samp, float4 s, int texelOff)


PARAMETERS

samp Sampler array to lookup.
s Coordinates to perform the lookup. The value used to select the layer is the second coordinate,
the third is the value used in the shadow comparison, the fourth corresponds to the bias value.
texelOff Offset to be added to obtain the final texel.


DESCRIPTION

Performs a texture lookup with bias in sampler samp using coordinates s, the texture to be sampled is
selected from the layer specified in the coordinates, the lookup involves a shadow comparison and may use
texel offset texelOff to compute the final texel.


REFERENCE IMPLEMENTATION



PROFILE SUPPORT

tex1DARRAYcmpbias is only supported in gp4 and newer profiles.


SEE ALSO

tex1DARRAYbias, tex1DARRAYlod, tex1DARRAYcmplod

		]]></description>
		<tool-tip><![CDATA[
			tex1DARRAYcmpbias - performs a texture lookup with shadow compare and bias in a given sampler
array.

		]]></tool-tip>
		<ports>
			<input name="samp">
				<check-type method="list" target="*">
					sampler1DARRAY
				</check-type>
			</input>
			<input name="s">
				<check-type method="list" target="*">
					float4
				</check-type>
			</input>
			<input name="texelOff">
				<check-type method="list" target="*">
					int
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['sampler1DARRAY,float4,int'] = 'float4',
					}
					local types = node.samp.get_type() .. ',' .. node.s.get_type() .. ',' .. node.texelOff.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = tex1DARRAYcmpbias( r${node.samp.get_source().uid()}, r${node.s.get_source().uid()}, r${node.texelOff.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="exp( a )">
		<description><![CDATA[
NAME

exp - returns the base-e exponential of scalars and vectors


SYNOPSIS

float exp(float a);
float1 exp(float1 a);
float2 exp(float2 a);
float3 exp(float3 a);
float4 exp(float4 a);
half exp(half a);
half1 exp(half1 a);
half2 exp(half2 a);
half3 exp(half3 a);
half4 exp(half4 a);
fixed exp(fixed a);
fixed1 exp(fixed1 a);
fixed2 exp(fixed2 a);
fixed3 exp(fixed3 a);
fixed4 exp(fixed4 a);


PARAMETERS

a Vector or scalar of which to determine the base-e exponential. The value e is approximately
2.71828182845904523536.


DESCRIPTION

Returns the base-e exponential a.
For vectors, the returned vector contains the base-e exponential of each element of the input vector.


REFERENCE IMPLEMENTATION

float3 exp(float3 a)
{
float3 rv;
int i;
for (i=0; i<3; i++) {
rv[i] = exp(a[i]); // this is the ANSI C standard library exp()
}
return rv;
}
exp is typically implemented with either a native base-2 exponentional instruction or pow.


PROFILE SUPPORT

exp is fully supported in all profiles unless otherwise specified.
Support in the fp20 is limited to constant compile-time evaluation.


SEE ALSO

exp2, log, pow

		]]></description>
		<tool-tip><![CDATA[
			exp - returns the base-e exponential of scalars and vectors

		]]></tool-tip>
		<ports>
			<input name="a">
				<check-type method="list" target="*">
					half4,float4,half,half3,half1,fixed1,fixed4,float1,fixed3,fixed2,float3,float,fixed,half2,float2
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['float4'] = 'float4',
						['half2'] = 'half2',
						['half1'] = 'half1',
						['float'] = 'float',
						['float1'] = 'float1',
						['fixed2'] = 'fixed2',
						['fixed4'] = 'fixed4',
						['fixed3'] = 'fixed3',
						['float3'] = 'float3',
						['float2'] = 'float2',
						['fixed1'] = 'fixed1',
						['fixed'] = 'fixed',
						['half3'] = 'half3',
						['half4'] = 'half4',
						['half'] = 'half',
					}
					local types = node.a.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = exp( r${node.a.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="tex3D( samp, s, dx, dy )">
		<description><![CDATA[
NAME

tex3D - performs a texture lookup in a given 3D sampler. May also use pre computed derivatives if those
are provided.


SYNOPSIS

float4 tex3D(sampler3D samp, float3 s)
float4 tex3D(sampler3D samp, float3 s, int texelOff)
float4 tex3D(sampler3D samp, float3 s, float3 dx, float3 dy)
float4 tex3D(sampler3D samp, float3 s, float3 dx, float3 dy, int texelOff)
int4 tex3D(isampler3D samp, float3 s)
int4 tex3D(isampler3D samp, float3 s, int texelOff)
int4 tex3D(isampler3D samp, float3 s, float3 dx, float3 dy)
int4 tex3D(isampler3D samp, float3 s, float3 dx, float3 dy, int texelOff)
uint4 tex3D(usampler3D samp, float3 s)
uint4 tex3D(usampler3D samp, float3 s, int texelOff)
uint4 tex3D(usampler3D samp, float3 s, float3 dx, float3 dy)
uint4 tex3D(usampler3D samp, float3 s, float3 dx, float3 dy,int texelOff)


PARAMETERS

samp Sampler to lookup.
s Coordinates to perform the lookup.
dx Pre computed derivative along the x axis.
dy Pre computed derivative along the y axis.
texelOff Offset to be added to obtain the final texel.


DESCRIPTION

Performs a texture lookup in sampler samp using coordinates s, may use and derivatives dx and dy, also
may use texel offset texelOff to compute final texel.


REFERENCE IMPLEMENTATION



PROFILE SUPPORT

tex3D is supported in all fragment profiles and all vertex profiles starting with vp40, variants with texel
offsets are only supported in gp4 and newer profiles. Variants with integer samplers are also only
suppported in gp4 and newer profiles.


SEE ALSO

tex3Dbias, tex3Dlod, tex3Dproj

		]]></description>
		<tool-tip><![CDATA[
			tex3D - performs a texture lookup in a given 3D sampler. May also use pre computed derivatives if those
are provided.

		]]></tool-tip>
		<ports>
			<input name="samp">
				<check-type method="list" target="*">
					sampler3D,usampler3D,isampler3D
				</check-type>
			</input>
			<input name="s">
				<check-type method="list" target="*">
					float3
				</check-type>
			</input>
			<input name="dx">
				<check-type method="list" target="*">
					float3
				</check-type>
			</input>
			<input name="dy">
				<check-type method="list" target="*">
					float3
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['sampler3D,float3,float3,float3'] = 'float4',
						['isampler3D,float3,float3,float3'] = 'int4',
						['usampler3D,float3,float3,float3'] = 'uint4',
					}
					local types = node.samp.get_type() .. ',' .. node.s.get_type() .. ',' .. node.dx.get_type() .. ',' .. node.dy.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = tex3D( r${node.samp.get_source().uid()}, r${node.s.get_source().uid()}, r${node.dx.get_source().uid()}, r${node.dy.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="mul( A, B )">
		<description><![CDATA[
NAME

mul - multiply a matrix by a column vector, row vector by a matrix, or matrix by a matrix


SYNOPSIS

float4 mul(float4x4 M, float4 v);
float4 mul(float4x3 M, float3 v);
float4 mul(float4x2 M, float2 v);
float4 mul(float4x1 M, float1 v);
float3 mul(float3x4 M, float4 v);
float3 mul(float3x3 M, float3 v);
float3 mul(float3x2 M, float2 v);
float3 mul(float3x1 M, float1 v);
float2 mul(float2x4 M, float4 v);
float2 mul(float2x3 M, float3 v);
float2 mul(float2x2 M, float2 v);
float2 mul(float2x1 M, float1 v);
float1 mul(float1x4 M, float4 v);
float1 mul(float1x3 M, float3 v);
float1 mul(float1x2 M, float2 v);
float1 mul(float1x1 M, float1 v);
float4 mul(float4 v, float4x4 M);
float4 mul(float3 v, float3x4 M);
float4 mul(float2 v, float2x4 M);
float4 mul(float1 v, float1x4 M);
float3 mul(float4 v, float4x3 M);
float3 mul(float3 v, float3x3 M);
float3 mul(float2 v, float2x3 M);
float3 mul(float1 v, float1x3 M);
float2 mul(float4 v, float4x2 M);
float2 mul(float3 v, float3x2 M);
float2 mul(float2 v, float2x2 M);
float2 mul(float1 v, float1x2 M);
float1 mul(float4 v, float4x1 M);
float1 mul(float3 v, float3x1 M);
float1 mul(float2 v, float2x1 M);
float1 mul(float1 v, float1x1 M);
half4 mul(half4x4 M, half4 v);
half4 mul(half4x3 M, half3 v);
half4 mul(half4x2 M, half2 v);
half4 mul(half4x1 M, half1 v);
half3 mul(half3x4 M, half4 v);
half3 mul(half3x3 M, half3 v);
half3 mul(half3x2 M, half2 v);
half3 mul(half3x1 M, half1 v);
half2 mul(half2x4 M, half4 v);
half2 mul(half2x3 M, half3 v);
half2 mul(half2x2 M, half2 v);
half2 mul(half2x1 M, half1 v);
half1 mul(half1x4 M, half4 v);
half1 mul(half1x3 M, half3 v);
half1 mul(half1x2 M, half2 v);
half1 mul(half1x1 M, half1 v);
half4 mul(half4 v, half4x4 M);
half4 mul(half3 v, half3x4 M);
half4 mul(half2 v, half2x4 M);
half4 mul(half1 v, half1x4 M);
half3 mul(half4 v, half4x3 M);
half3 mul(half3 v, half3x3 M);
half3 mul(half2 v, half2x3 M);
half3 mul(half1 v, half1x3 M);
half2 mul(half4 v, half4x2 M);
half2 mul(half3 v, half3x2 M);
half2 mul(half2 v, half2x2 M);
half2 mul(half1 v, half1x2 M);
half1 mul(half4 v, half4x1 M);
half1 mul(half3 v, half3x1 M);
half1 mul(half2 v, half2x1 M);
half1 mul(half1 v, half1x1 M);
fixed4 mul(fixed4x4 M, fixed4 v);
fixed4 mul(fixed4x3 M, fixed3 v);
fixed4 mul(fixed4x2 M, fixed2 v);
fixed4 mul(fixed4x1 M, fixed1 v);
fixed3 mul(fixed3x4 M, fixed4 v);
fixed3 mul(fixed3x3 M, fixed3 v);
fixed3 mul(fixed3x2 M, fixed2 v);
fixed3 mul(fixed3x1 M, fixed1 v);
fixed2 mul(fixed2x4 M, fixed4 v);
fixed2 mul(fixed2x3 M, fixed3 v);
fixed2 mul(fixed2x2 M, fixed2 v);
fixed2 mul(fixed2x1 M, fixed1 v);
fixed1 mul(fixed1x4 M, fixed4 v);
fixed1 mul(fixed1x3 M, fixed3 v);
fixed1 mul(fixed1x2 M, fixed2 v);
fixed1 mul(fixed1x1 M, fixed1 v);
fixed4 mul(fixed4 v, fixed4x4 M);
fixed4 mul(fixed3 v, fixed3x4 M);
fixed4 mul(fixed2 v, fixed2x4 M);
fixed4 mul(fixed1 v, fixed1x4 M);
fixed3 mul(fixed4 v, fixed4x3 M);
fixed3 mul(fixed3 v, fixed3x3 M);
fixed3 mul(fixed2 v, fixed2x3 M);
fixed3 mul(fixed1 v, fixed1x3 M);
fixed2 mul(fixed4 v, fixed4x2 M);
fixed2 mul(fixed3 v, fixed3x2 M);
fixed2 mul(fixed2 v, fixed2x2 M);
fixed2 mul(fixed1 v, fixed1x2 M);
fixed1 mul(fixed4 v, fixed4x1 M);
fixed1 mul(fixed3 v, fixed3x1 M);
fixed1 mul(fixed2 v, fixed2x1 M);
fixed1 mul(fixed1 v, fixed1x1 M);
float1x1 mul(float1x1 A, float1x1 B);
float1x2 mul(float1x1 A, float1x2 B);
float1x3 mul(float1x1 A, float1x3 B);
float1x4 mul(float1x1 A, float1x4 B);
float1x1 mul(float1x2 A, float2x1 B);
float1x2 mul(float1x2 A, float2x2 B);
float1x3 mul(float1x2 A, float2x3 B);
float1x4 mul(float1x2 A, float2x4 B);
float1x1 mul(float1x3 A, float3x1 B);
float1x2 mul(float1x3 A, float3x2 B);
float1x3 mul(float1x3 A, float3x3 B);
float1x4 mul(float1x3 A, float3x4 B);
float1x1 mul(float1x4 A, float4x1 B);
float1x2 mul(float1x4 A, float4x2 B);
float1x3 mul(float1x4 A, float4x3 B);
float1x4 mul(float1x4 A, float4x4 B);
float2x1 mul(float2x1 A, float1x1 B);
float2x2 mul(float2x1 A, float1x2 B);
float2x3 mul(float2x1 A, float1x3 B);
float2x4 mul(float2x1 A, float1x4 B);
float2x1 mul(float2x2 A, float2x1 B);
float2x2 mul(float2x2 A, float2x2 B);
float2x3 mul(float2x2 A, float2x3 B);
float2x4 mul(float2x2 A, float2x4 B);
float2x1 mul(float2x3 A, float3x1 B);
float2x2 mul(float2x3 A, float3x2 B);
float2x3 mul(float2x3 A, float3x3 B);
float2x4 mul(float2x3 A, float3x4 B);
float2x1 mul(float2x4 A, float4x1 B);
float2x2 mul(float2x4 A, float4x2 B);
float2x3 mul(float2x4 A, float4x3 B);
float2x4 mul(float2x4 A, float4x4 B);
float3x1 mul(float3x1 A, float1x1 B);
float3x2 mul(float3x1 A, float1x2 B);
float3x3 mul(float3x1 A, float1x3 B);
float3x4 mul(float3x1 A, float1x4 B);
float3x1 mul(float3x2 A, float2x1 B);
float3x2 mul(float3x2 A, float2x2 B);
float3x3 mul(float3x2 A, float2x3 B);
float3x4 mul(float3x2 A, float2x4 B);
float3x1 mul(float3x3 A, float3x1 B);
float3x2 mul(float3x3 A, float3x2 B);
float3x3 mul(float3x3 A, float3x3 B);
float3x4 mul(float3x3 A, float3x4 B);
float3x1 mul(float3x4 A, float4x1 B);
float3x2 mul(float3x4 A, float4x2 B);
float3x3 mul(float3x4 A, float4x3 B);
float3x4 mul(float3x4 A, float4x4 B);
float4x1 mul(float4x1 A, float1x1 B);
float4x2 mul(float4x1 A, float1x2 B);
float4x3 mul(float4x1 A, float1x3 B);
float4x4 mul(float4x1 A, float1x4 B);
float4x1 mul(float4x2 A, float2x1 B);
float4x2 mul(float4x2 A, float2x2 B);
float4x3 mul(float4x2 A, float2x3 B);
float4x4 mul(float4x2 A, float2x4 B);
float4x1 mul(float4x3 A, float3x1 B);
float4x2 mul(float4x3 A, float3x2 B);
float4x3 mul(float4x3 A, float3x3 B);
float4x4 mul(float4x3 A, float3x4 B);
float4x1 mul(float4x4 A, float4x1 B);
float4x2 mul(float4x4 A, float4x2 B);
float4x3 mul(float4x4 A, float4x3 B);
float4x4 mul(float4x4 A, float4x4 B);


PARAMETERS

M Matrix
v Vector
A Matrix
B Matrix


DESCRIPTION

Returns the vector result of multiplying a matrix M by a column vector v; a row vector v by a matrix M; or a
matrix A by a second matrix B.
The following are algebrically equal (if not necessarily numerically equal):
mul(M,v) == mul(v, tranpose(M))
mul(v,M) == mul(tranpose(M), v)


REFERENCE IMPLEMENTATION

mul for a float4x3 matrix by a float3 column vector could be implemented this way:
float4 mul(float4x3 M, float3 v)
{
float4 r;
r.x = dot( M._m00_m01_m02, v );
r.y = dot( M._m10_m11_m12, v );
r.z = dot( M._m20_m21_m22, v );
r.w = dot( M._m30_m31_m32, v );
return r;
}


PROFILE SUPPORT

mul is supported in all profiles.
The fifixed3 matrix-by-vector and vector-by-matrix multiplies are very efficient in the fp20 and fp30 profiles.


SEE ALSO

cross, dot, transpose

		]]></description>
		<tool-tip><![CDATA[
			mul - multiply a matrix by a column vector, row vector by a matrix, or matrix by a matrix

		]]></tool-tip>
		<ports>
			<input name="A">
				<check-type method="list" target="*">
					float4x4,float1x2,float2x2,float1x4,float4x3,float2x3,float2x4,float4x1,float3x4,float3x3,float3x1,float1x1,float2x1,float3x2,float1x3,float4x2
				</check-type>
			</input>
			<input name="B">
				<check-type method="list" target="*">
					float4x4,float1x2,float2x2,float1x4,float4x3,float2x3,float2x4,float4x1,float3x4,float3x3,float3x1,float1x1,float2x1,float3x2,float1x3,float4x2
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['float4x4,float4x4'] = 'float4x4',
						['float2x2,float2x3'] = 'float2x3',
						['float3x3,float3x3'] = 'float3x3',
						['float4x4,float4x3'] = 'float4x3',
						['float4x4,float4x2'] = 'float4x2',
						['float3x1,float1x2'] = 'float3x2',
						['float2x2,float2x2'] = 'float2x2',
						['float4x4,float4x1'] = 'float4x1',
						['float1x2,float2x4'] = 'float1x4',
						['float3x1,float1x4'] = 'float3x4',
						['float3x4,float4x3'] = 'float3x3',
						['float4x3,float3x4'] = 'float4x4',
						['float4x1,float1x2'] = 'float4x2',
						['float1x3,float3x3'] = 'float1x3',
						['float2x1,float1x3'] = 'float2x3',
						['float1x4,float4x3'] = 'float1x3',
						['float1x4,float4x4'] = 'float1x4',
						['float4x3,float3x2'] = 'float4x2',
						['float2x1,float1x2'] = 'float2x2',
						['float3x1,float1x3'] = 'float3x3',
						['float4x2,float2x4'] = 'float4x4',
						['float4x2,float2x3'] = 'float4x3',
						['float3x1,float1x1'] = 'float3x1',
						['float4x2,float2x2'] = 'float4x2',
						['float1x3,float3x4'] = 'float1x4',
						['float2x4,float4x2'] = 'float2x2',
						['float3x2,float2x2'] = 'float3x2',
						['float3x4,float4x2'] = 'float3x2',
						['float4x1,float1x4'] = 'float4x4',
						['float1x1,float1x3'] = 'float1x3',
						['float3x3,float3x4'] = 'float3x4',
						['float3x4,float4x1'] = 'float3x1',
						['float4x3,float3x3'] = 'float4x3',
						['float4x1,float1x1'] = 'float4x1',
						['float2x4,float4x1'] = 'float2x1',
						['float4x1,float1x3'] = 'float4x3',
						['float1x4,float4x1'] = 'float1x1',
						['float1x3,float3x2'] = 'float1x2',
						['float3x3,float3x2'] = 'float3x2',
						['float2x3,float3x2'] = 'float2x2',
						['float2x3,float3x1'] = 'float2x1',
						['float3x3,float3x1'] = 'float3x1',
						['float1x2,float2x2'] = 'float1x2',
						['float3x2,float2x3'] = 'float3x3',
						['float2x3,float3x3'] = 'float2x3',
						['float1x2,float2x3'] = 'float1x3',
						['float3x2,float2x4'] = 'float3x4',
						['float4x2,float2x1'] = 'float4x1',
						['float3x2,float2x1'] = 'float3x1',
						['float2x4,float4x3'] = 'float2x3',
						['float4x3,float3x1'] = 'float4x1',
						['float1x1,float1x1'] = 'float1x1',
						['float1x2,float2x1'] = 'float1x1',
						['float2x4,float4x4'] = 'float2x4',
						['float1x4,float4x2'] = 'float1x2',
						['float3x4,float4x4'] = 'float3x4',
						['float2x1,float1x1'] = 'float2x1',
						['float1x1,float1x4'] = 'float1x4',
						['float1x3,float3x1'] = 'float1x1',
						['float2x3,float3x4'] = 'float2x4',
						['float2x2,float2x4'] = 'float2x4',
						['float2x2,float2x1'] = 'float2x1',
						['float2x1,float1x4'] = 'float2x4',
						['float1x1,float1x2'] = 'float1x2',
					}
					local types = node.A.get_type() .. ',' .. node.B.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = mul( r${node.A.get_source().uid()}, r${node.B.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="asin( a )">
		<description><![CDATA[
NAME

asin - returns arcsine of scalars and vectors.


SYNOPSIS

float asin(float a);
float1 asin(float1 a);
float2 asin(float2 a);
float3 asin(float3 a);
float4 asin(float4 a);
half asin(half a);
half1 asin(half1 a);
half2 asin(half2 a);
half3 asin(half3 a);
half4 asin(half4 a);
fixed asin(fixed a);
fixed1 asin(fixed1 a);
fixed2 asin(fixed2 a);
fixed3 asin(fixed3 a);
fixed4 asin(fixed4 a);


PARAMETERS

a Vector or scalar of which to determine the arcsine.


DESCRIPTION

Returns the arcsine of a in the range [-pi/2,+pi/2], expecting a to be in the range [-1,+1].
For vectors, the returned vector contains the arcsine of each element of the input vector.


REFERENCE IMPLEMENTATION

asin for a float scalar could be implemented like this.
// Handbook of Mathematical Functions
// M. Abramowitz and I.A. Stegun, Ed.
float asin(float x) {
float negate = float(x < 0);
x = abs(x);
float ret = -0.0187293;
ret *= x;
ret += 0.0742610;
ret *= x;
ret -= 0.2121144;
ret *= x;
ret += 1.5707288;
ret = 3.14159265358979*0.5 - sqrt(1.0 - x)*ret;
return ret - 2 * negate * ret;
}


PROFILE SUPPORT

asin is supported in all profiles.
Support in the fp20 is limited.


SEE ALSO

abs, acos, sin, sqrt

		]]></description>
		<tool-tip><![CDATA[
			asin - returns arcsine of scalars and vectors.

		]]></tool-tip>
		<ports>
			<input name="a">
				<check-type method="list" target="*">
					half4,float4,half,half3,half1,fixed1,fixed4,float1,fixed3,fixed2,float3,float,fixed,half2,float2
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['float4'] = 'float4',
						['half2'] = 'half2',
						['half1'] = 'half1',
						['float'] = 'float',
						['float1'] = 'float1',
						['fixed2'] = 'fixed2',
						['fixed4'] = 'fixed4',
						['fixed3'] = 'fixed3',
						['float3'] = 'float3',
						['float2'] = 'float2',
						['fixed1'] = 'fixed1',
						['fixed'] = 'fixed',
						['half3'] = 'half3',
						['half4'] = 'half4',
						['half'] = 'half',
					}
					local types = node.a.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = asin( r${node.a.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="tex2Dfetch( samp, s )">
		<description><![CDATA[
NAME

tex2Dfetch - performs an unfiltered texture lookup in a given sampler.


SYNOPSIS

float4 tex2Dfetch(sampler2D samp, int4 s)
float4 tex2Dfetch(sampler2D samp, int4 s, int texelOff)
int4 tex2Dfetch(isampler2D samp, int4 s)
int4 tex2Dfetch(isampler2D samp, int4 s, int texelOff)
uint4 tex2Dfetch(usampler2D samp, int4 s)
uint4 tex2Dfetch(usampler2D samp, int4 s, int texelOff)


PARAMETERS

samp Sampler to lookup.
s Coordinates to perform the lookup. The level of detail is stored in the last component of the
coordinate vector.
texelOff Offset to be added to obtain the final texel.


DESCRIPTION

Performs an unfiltered texture lookup in sampler samp using coordinates s. The level of detail is provided
by the last component of the coordinate vector. May use texel offset texelOff to compute final texel.


REFERENCE IMPLEMENTATION



PROFILE SUPPORT

tex2Dfetch is only supported in gp4 and newer profiles.


SEE ALSO

tex2D, tex2DARRAYfetch.de Sh
\$1

		]]></description>
		<tool-tip><![CDATA[
			tex2Dfetch - performs an unfiltered texture lookup in a given sampler.

		]]></tool-tip>
		<ports>
			<input name="samp">
				<check-type method="list" target="*">
					sampler2D,isampler2D,usampler2D
				</check-type>
			</input>
			<input name="s">
				<check-type method="list" target="*">
					int4
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['usampler2D,int4'] = 'uint4',
						['sampler2D,int4'] = 'float4',
						['isampler2D,int4'] = 'int4',
					}
					local types = node.samp.get_type() .. ',' .. node.s.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = tex2Dfetch( r${node.samp.get_source().uid()}, r${node.s.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="exp2( a )">
		<description><![CDATA[
NAME

exp2 - returns the base-2 exponential of scalars and vectors


SYNOPSIS

float exp2(float a);
float1 exp2(float1 a);
float2 exp2(float2 a);
float3 exp2(float3 a);
float4 exp2(float4 a);
half exp2(half a);
half1 exp2(half1 a);
half2 exp2(half2 a);
half3 exp2(half3 a);
half4 exp2(half4 a);
fixed exp2(fixed a);
fixed1 exp2(fixed1 a);
fixed2 exp2(fixed2 a);
fixed3 exp2(fixed3 a);
fixed4 exp2(fixed4 a);


PARAMETERS

a Vector or scalar of which to determine the base-2 exponential.


DESCRIPTION

Returns the base-2 exponential a.
For vectors, the returned vector contains the base-2 exponential of each element of the input vector.


REFERENCE IMPLEMENTATION

float3 exp2(float3 a)
{
float3 rv;
int i;
for (i=0; i<3; i++) {
rv[i] = exp2(a[i]); // this is the ANSI C standard library exp2()
}
return rv;
}
exp2 is typically implemented with a native base-2 exponentional instruction.


PROFILE SUPPORT

exp2 is fully supported in all profiles unless otherwise specified.
Support in the fp20 is limited to constant compile-time evaluation.


SEE ALSO

exp, log, pow

		]]></description>
		<tool-tip><![CDATA[
			exp2 - returns the base-2 exponential of scalars and vectors

		]]></tool-tip>
		<ports>
			<input name="a">
				<check-type method="list" target="*">
					half4,float4,half,half3,half1,fixed1,fixed4,float1,fixed3,fixed2,float3,float,fixed,half2,float2
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['float4'] = 'float4',
						['half2'] = 'half2',
						['half1'] = 'half1',
						['float'] = 'float',
						['float1'] = 'float1',
						['fixed2'] = 'fixed2',
						['fixed4'] = 'fixed4',
						['fixed3'] = 'fixed3',
						['float3'] = 'float3',
						['float2'] = 'float2',
						['fixed1'] = 'fixed1',
						['fixed'] = 'fixed',
						['half3'] = 'half3',
						['half4'] = 'half4',
						['half'] = 'half',
					}
					local types = node.a.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = exp2( r${node.a.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="tex2DARRAYfetch( samp, s )">
		<description><![CDATA[
NAME

tex2DARRAYfetch - performs an unfiltered texture lookup in a given sampler array.


SYNOPSIS

float4 tex2DARRAYfetch(sampler2DARRAY samp, int4 s)
float4 tex2DARRAYfetch(sampler2DARRAY samp, int4 s, int texelOff)
int4 tex2DARRAYfetch(isampler2DARRAY samp, int4 s)
int4 tex2DARRAYfetch(isampler2DARRAY samp, int4 s, int texelOff)
uint4 tex2DARRAYfetch(usampler2DARRAY samp, int4 s)
uint4 tex2DARRAYfetch(usampler2DARRAY samp, int4 s, int texelOff)


PARAMETERS

samp Sampler array to lookup.
s Coordinates to perform the lookup, the layer is selected by the component right after the regular
coordinates, the level of detail is provided by the last component of the coordinate vector.
texelOff Offset to be added to obtain the final texel.


DESCRIPTION

Performs an unfiltered texture lookup in sampler array samp using coordinates s. The layer to be accessed is
selected by the component right after the regular coordinates, the level of detail is provided by the last
component of the coordinate vector. May use texel offset texelOff to compute final texel.


REFERENCE IMPLEMENTATION



PROFILE SUPPORT

tex2DARRAYfetch is only supported in gp4 and newer profiles.


SEE ALSO

tex2Dfetch.de Sh
\$1

		]]></description>
		<tool-tip><![CDATA[
			tex2DARRAYfetch - performs an unfiltered texture lookup in a given sampler array.

		]]></tool-tip>
		<ports>
			<input name="samp">
				<check-type method="list" target="*">
					usampler2DARRAY,isampler2DARRAY,sampler2DARRAY
				</check-type>
			</input>
			<input name="s">
				<check-type method="list" target="*">
					int4
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['sampler2DARRAY,int4'] = 'float4',
						['usampler2DARRAY,int4'] = 'uint4',
						['isampler2DARRAY,int4'] = 'int4',
					}
					local types = node.samp.get_type() .. ',' .. node.s.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = tex2DARRAYfetch( r${node.samp.get_source().uid()}, r${node.s.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="isnan( x )">
		<description><![CDATA[
NAME

isnan - test whether or not a scalar or each vector component is not-a-number


SYNOPSIS

bool isnan(float x);
bool1 isnan(float1 x);
bool2 isnan(float2 x);
bool3 isnan(float3 x);
bool4 isnan(float4 x);
bool isnan(half x);
bool1 isnan(half1 x);
bool2 isnan(half2 x);
bool3 isnan(half3 x);
bool4 isnan(half4 x);
bool isnan(fixed x);
bool1 isnan(fixed1 x);
bool2 isnan(fixed2 x);
bool3 isnan(fixed3 x);
bool4 isnan(fixed4 x);


PARAMETERS

x Vector or scalar to test for being NaN.


DESCRIPTION

Returns whether or not a scalar or each vector component is not-a-number (NaN) Finite and infinite values
are not NaN.


REFERENCE IMPLEMENTATION

isnan for float3 vectors could be implemented like this.
bool3 isnan(float3 x)
{
// By IEEE 754 rule, NaN is not equal to NaN
return s != s;
}


PROFILE SUPPORT

isnan is supported in all profiles except fp20.


SEE ALSO

isfinite, isinf

		]]></description>
		<tool-tip><![CDATA[
			isnan - test whether or not a scalar or each vector component is not-a-number

		]]></tool-tip>
		<ports>
			<input name="x">
				<check-type method="list" target="*">
					half4,float4,half,half3,half1,fixed1,fixed4,float1,fixed3,fixed2,float3,float,fixed,half2,float2
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['float4'] = 'bool4',
						['half2'] = 'bool2',
						['half1'] = 'bool1',
						['float'] = 'bool',
						['float1'] = 'bool1',
						['fixed2'] = 'bool2',
						['fixed4'] = 'bool4',
						['fixed3'] = 'bool3',
						['float3'] = 'bool3',
						['float2'] = 'bool2',
						['fixed1'] = 'bool1',
						['fixed'] = 'bool',
						['half3'] = 'bool3',
						['half4'] = 'bool4',
						['half'] = 'bool',
					}
					local types = node.x.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = isnan( r${node.x.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="sinh( a )">
		<description><![CDATA[
NAME

sinh - returns hyperbolic sine of scalars and vectors.


SYNOPSIS

float sinh(float a);
float1 sinh(float1 a);
float2 sinh(float2 a);
float3 sinh(float3 a);
float4 sinh(float4 a);
half sinh(half a);
half1 sinh(half1 a);
half2 sinh(half2 a);
half3 sinh(half3 a);
half4 sinh(half4 a);
fixed sinh(fixed a);
fixed1 sinh(fixed1 a);
fixed2 sinh(fixed2 a);
fixed3 sinh(fixed3 a);
fixed4 sinh(fixed4 a);


PARAMETERS

a Vector or scalar of which to determine the hyperbolic sine.


DESCRIPTION

Returns the hyperbolic sine of a.
For vectors, the returned vector contains the hyperbolic sine of each element of the input vector.


REFERENCE IMPLEMENTATION

sinh for a scalar float could be implemented like this.
float sinh(float x)
{
return 0.5 * (exp(x)-exp(-x));
}


PROFILE SUPPORT

sinh is supported in all profiles except fp20.


SEE ALSO

acos, cos, cosh, exp, tanh

		]]></description>
		<tool-tip><![CDATA[
			sinh - returns hyperbolic sine of scalars and vectors.

		]]></tool-tip>
		<ports>
			<input name="a">
				<check-type method="list" target="*">
					half4,float4,half,half3,half1,fixed1,fixed4,float1,fixed3,fixed2,float3,float,fixed,half2,float2
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['float4'] = 'float4',
						['half2'] = 'half2',
						['half1'] = 'half1',
						['float'] = 'float',
						['float1'] = 'float1',
						['fixed2'] = 'fixed2',
						['fixed4'] = 'fixed4',
						['fixed3'] = 'fixed3',
						['float3'] = 'float3',
						['float2'] = 'float2',
						['fixed1'] = 'fixed1',
						['fixed'] = 'fixed',
						['half3'] = 'half3',
						['half4'] = 'half4',
						['half'] = 'half',
					}
					local types = node.a.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = sinh( r${node.a.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="tex2Dbias( samp, s )">
		<description><![CDATA[
NAME

tex2Dbias - performs a texture lookup with bias in a given sampler.


SYNOPSIS

float4 tex2Dbias(sampler2D samp, float4 s)
float4 tex2Dbias(sampler2D samp, float4 s, int texelOff)
int4 tex2Dbias(isampler2D samp, float4 s)
int4 tex2Dbias(isampler2D samp, float4 s, int texelOff)
uint4 tex2Dbias(usampler2D samp, float4 s)
uint4 tex2Dbias(usampler2D samp, float4 s, int texelOff)


PARAMETERS

samp Sampler to lookup.
s Coordinates to perform the lookup. The bias value should be passed as the last component of the
coordinate vector.
texelOff Offset to be added to obtain the final texel.


DESCRIPTION

Performs a texture lookup with bias in sampler samp using coordinates s.


REFERENCE IMPLEMENTATION



PROFILE SUPPORT

tex2Dbias is supported in fragment profiles starting with fp30 and in vertex profiles starting with vp40.
Variants with texelOff are only supported in gp4 and newer profiles. Variants with integer samplers are also
only suppported in gp4 and newer profiles.


SEE ALSO

tex2Dlod, tex2Dcmpbias.de Sh
\$1

		]]></description>
		<tool-tip><![CDATA[
			tex2Dbias - performs a texture lookup with bias in a given sampler.

		]]></tool-tip>
		<ports>
			<input name="samp">
				<check-type method="list" target="*">
					sampler2D,isampler2D,usampler2D
				</check-type>
			</input>
			<input name="s">
				<check-type method="list" target="*">
					float4
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['isampler2D,float4'] = 'int4',
						['sampler2D,float4'] = 'float4',
						['usampler2D,float4'] = 'uint4',
					}
					local types = node.samp.get_type() .. ',' .. node.s.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = tex2Dbias( r${node.samp.get_source().uid()}, r${node.s.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="ldexp( x, n )">
		<description><![CDATA[
NAME

ldexp - returns x times 2 rained to n


SYNOPSIS

float ldexp(float x, float n);
float1 ldexp(float1 x, float1 n);
float2 ldexp(float2 x, float2 n);
float3 ldexp(float3 x, float3 n);
float4 ldexp(float4 x, float4 n);
half ldexp(half x, half n);
half1 ldexp(half1 x, half1 n);
half2 ldexp(half2 x, half2 n);
half3 ldexp(half3 x, half3 n);
half4 ldexp(half4 x, half4 n);
fixed ldexp(fixed x, fixed n);
fixed1 ldexp(fixed1 x, fixed1 n);
fixed2 ldexp(fixed2 x, fixed2 n);
fixed3 ldexp(fixed3 x, fixed3 n);
fixed4 ldexp(fixed4 x, fixed4 n);


PARAMETERS

x Vector or scalar.
n Vector or scalar for power with which to raise 2.


DESCRIPTION

ldexp returns x times 2 raised to the power n.


REFERENCE IMPLEMENTATION

ldexp for float2 vectors x and n could be implemented as:
float2 ldexp(float2 x, float2 n)
{
return x * exp2(n);
}


PROFILE SUPPORT

ldexp is supported in all profiles but fp20.


SEE ALSO

exp2, modf, pow

		]]></description>
		<tool-tip><![CDATA[
			ldexp - returns x times 2 rained to n

		]]></tool-tip>
		<ports>
			<input name="x">
				<check-type method="list" target="*">
					half4,float4,half,half3,half1,fixed1,fixed4,float1,fixed3,fixed2,float3,float,fixed,half2,float2
				</check-type>
			</input>
			<input name="n">
				<check-type method="list" target="*">
					half4,float4,half,half3,half1,fixed1,fixed4,float1,fixed3,fixed2,float3,float,fixed,half2,float2
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['fixed1,fixed1'] = 'fixed1',
						['float4,float4'] = 'float4',
						['float3,float3'] = 'float3',
						['float,float'] = 'float',
						['fixed4,fixed4'] = 'fixed4',
						['fixed3,fixed3'] = 'fixed3',
						['fixed,fixed'] = 'fixed',
						['fixed2,fixed2'] = 'fixed2',
						['half4,half4'] = 'half4',
						['half3,half3'] = 'half3',
						['float1,float1'] = 'float1',
						['half,half'] = 'half',
						['half1,half1'] = 'half1',
						['float2,float2'] = 'float2',
						['half2,half2'] = 'half2',
					}
					local types = node.x.get_type() .. ',' .. node.n.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = ldexp( r${node.x.get_source().uid()}, r${node.n.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="tex1DARRAYproj( samp, s, texelOff )">
		<description><![CDATA[
NAME

tex1DARRAYproj - performs a texture lookup with projection in a given sampler array. May perform a
shadow comparison if argument for shadow comparison is provided.


SYNOPSIS

float4 tex1DARRAYproj(sampler1DARRAY samp, float3 s)
float4 tex1DARRAYproj(sampler1DARRAY samp, float3 s, int texelOff)
float4 tex1DARRAYproj(sampler1DARRAY samp, float4 s)
float4 tex1DARRAYproj(sampler1DARRAY samp, float4 s, int texelOff)
int4 tex1DARRAYproj(isampler1DARRAY samp, float3 s)
int4 tex1DARRAYproj(isampler1DARRAY samp, float3 s, int texelOff)
uint4 tex1DARRAYproj(usampler1DARRAY samp, float3 s)
uint4 tex1DARRAYproj(usampler1DARRAY samp, float3 s, int texelOff)


PARAMETERS

samp Sampler array to lookup.
s Coordinates to perform the lookup. The value used to select the layer should be passed as the
component right after the lookup coordinates. The value used in the projection should be passed
as the last component of the coordinate vector. The value used in the shadow comparison, if
present, should be passed as the next-to-last component of the coordinate vector.
texelOff Offset to be added to obtain the final texel.


DESCRIPTION

Performs a texture lookup in sampler array samp using coordinates s, the layer used in the lookup is first
selected using the coordinate component right after the regular coordinates. The coordinates used in the
lookup are then projected, that is, divided by the last component of the coordinate vector and them used in
the lookup. If an extra coordinate is present it is used to perform a shadow comparison, the value used in
the shadow comparison is always the next-to-last component in the coordinate vector.


REFERENCE IMPLEMENTATION



PROFILE SUPPORT

tex1DARRAYproj is only supported in gp4 and newer profiles.


SEE ALSO

tex1D, tex1Dproj

		]]></description>
		<tool-tip><![CDATA[
			tex1DARRAYproj - performs a texture lookup with projection in a given sampler array. May perform a
shadow comparison if argument for shadow comparison is provided.

		]]></tool-tip>
		<ports>
			<input name="samp">
				<check-type method="list" target="*">
					usampler1DARRAY,sampler1DARRAY,isampler1DARRAY
				</check-type>
			</input>
			<input name="s">
				<check-type method="list" target="*">
					float3,float4
				</check-type>
			</input>
			<input name="texelOff">
				<check-type method="list" target="*">
					int
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['usampler1DARRAY,float3,int'] = 'uint4',
						['sampler1DARRAY,float3,int'] = 'float4',
						['sampler1DARRAY,float4,int'] = 'float4',
						['isampler1DARRAY,float3,int'] = 'int4',
					}
					local types = node.samp.get_type() .. ',' .. node.s.get_type() .. ',' .. node.texelOff.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = tex1DARRAYproj( r${node.samp.get_source().uid()}, r${node.s.get_source().uid()}, r${node.texelOff.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="floatToIntBits( x )">
		<description><![CDATA[
NAME

floatToIntBits - returns the 32-bit integer representation of an IEEE 754 floating-point scalar or vector


SYNOPSIS

int floatToIntBits(float x);
int1 floatToIntBits(float1 x);
int2 floatToIntBits(float2 x);
int3 floatToIntBits(float3 x);
int4 floatToIntBits(float4 x);


PARAMETERS

x Floating-point vector or scalar to cast to a scalar int or vector of ints.


DESCRIPTION

Returns a representation of the specified floating-point scalar value or vector values according to the IEEE
754 floating-point "single format" bit layout.
Not-A-Number (NaN) floating-point values are cannonicalized to the integer value 0x7fc00000 regardless
of the specific NaN encoding. The sign bit of the NaN is discarded.
This function is based on Java's jave.lang.Float method of the same name. See:
http://java.sun.com/j2se/1.4.2/docs/api/java/lang/Float.html
floatToIntBits requires instructions to be generated to cannonicalize NaN values so floatToIntBits is
typically more expensive than floatToRawIntBits.


REFERENCE IMPLEMENTATION

floatToIntBits operates consistent with the following ANSI C code:
int floatToIntBits(float x)
{
union {
float f; // assuming 32-bit IEEE 754 single-precision
int i; // assuming 32-bit 2's complement int
} u;
if (isnan(x)) {
return 0x7fc00000;
} else {
u.f = x;
return u.i;
}
}


PROFILE SUPPORT

floatToIntBits is supported by the gp4vp, gp4gp, and gp4vp profiles.
floatToIntBits is not supported by pre-G80 profiles.


SEE ALSO

ceil, floatToRawIntBits, floor, intBitsToFloat, round, trunc

		]]></description>
		<tool-tip><![CDATA[
			floatToIntBits - returns the 32-bit integer representation of an IEEE 754 floating-point scalar or vector

		]]></tool-tip>
		<ports>
			<input name="x">
				<check-type method="list" target="*">
					float3,float4,float,float1,float2
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['float4'] = 'int4',
						['float3'] = 'int3',
						['float2'] = 'int2',
						['float'] = 'int',
						['float1'] = 'int1',
					}
					local types = node.x.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = floatToIntBits( r${node.x.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="tex2DARRAYsize( samp, lod )">
		<description><![CDATA[
NAME

tex2DARRAYsize - returns the size of a given texture array image for a given level of detail.


SYNOPSIS

int3 tex2DARRAYsize(sampler2DARRAY samp, int lod)
int3 tex2DARRAYsize(isampler2DARRAY samp, int lod)
int3 tex2DARRAYsize(usampler2DARRAY samp, int lod)


PARAMETERS

samp Sampler to be queried for size.
lod Level of detail to obtain size.


DESCRIPTION

Given a sampler array and a level of detail the size of one element of the corresponding texture array for a
given level of detail is returned as a result of the operation.


REFERENCE IMPLEMENTATION



PROFILE SUPPORT

tex2DARRAYsize is only supported in gp4 and newer profiles.


SEE ALSO

tex2Dsize.de Sh
\$1

		]]></description>
		<tool-tip><![CDATA[
			tex2DARRAYsize - returns the size of a given texture array image for a given level of detail.

		]]></tool-tip>
		<ports>
			<input name="samp">
				<check-type method="list" target="*">
					usampler2DARRAY,isampler2DARRAY,sampler2DARRAY
				</check-type>
			</input>
			<input name="lod">
				<check-type method="list" target="*">
					int
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['sampler2DARRAY,int'] = 'int3',
						['isampler2DARRAY,int'] = 'int3',
						['usampler2DARRAY,int'] = 'int3',
					}
					local types = node.samp.get_type() .. ',' .. node.lod.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = tex2DARRAYsize( r${node.samp.get_source().uid()}, r${node.lod.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="tex2DARRAYlod( samp, s )">
		<description><![CDATA[
NAME

tex2DARRAYlod - performs a texture lookup with a specified level of detail in a given sampler array.


SYNOPSIS

float4 tex2DARRAYlod(sampler2DARRAY samp, float4 s)
float4 tex2DARRAYlod(sampler2DARRAY samp, float4 s, int texelOff)
int4 tex2DARRAYlod(isampler2DARRAY samp, float4 s)
int4 tex2DARRAYlod(isampler2DARRAY samp, float4 s, int texelOff)
uint4 tex2DARRAYlod(usampler2DARRAY samp, float4 s)
uint4 tex2DARRAYlod(usampler2DARRAY samp, float4 s, int texelOff)


PARAMETERS

samp Sampler array to lookup.
s Coordinates to perform the lookup.The value used to select the layer should be passed in the
vector component right after the regular coordinates. The level of detail value should be passed as
the last component of the coordinate vector.
texelOff Offset to be added to obtain the final texel.


DESCRIPTION

Performs a texture lookup with a specified level of detail in sampler samp using coordinates s, the texture to
be sampled is selected from the layer specified in the coordinates.


REFERENCE IMPLEMENTATION



PROFILE SUPPORT

tex2DARRAYlod is only supported in gp4 and newer profiles.


SEE ALSO

tex2DARRAY, tex2DARRAYbias.de Sh
\$1

		]]></description>
		<tool-tip><![CDATA[
			tex2DARRAYlod - performs a texture lookup with a specified level of detail in a given sampler array.

		]]></tool-tip>
		<ports>
			<input name="samp">
				<check-type method="list" target="*">
					usampler2DARRAY,isampler2DARRAY,sampler2DARRAY
				</check-type>
			</input>
			<input name="s">
				<check-type method="list" target="*">
					float4
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['usampler2DARRAY,float4'] = 'uint4',
						['sampler2DARRAY,float4'] = 'float4',
						['isampler2DARRAY,float4'] = 'int4',
					}
					local types = node.samp.get_type() .. ',' .. node.s.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = tex2DARRAYlod( r${node.samp.get_source().uid()}, r${node.s.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="all( a )">
		<description><![CDATA[
NAME

all - returns true if a boolean scalar or all components of a boolean vector are true.


SYNOPSIS

bool all(bool a);
bool all(bool1 a);
bool all(bool2 a);
bool all(bool3 a);
bool all(bool4 a);


PARAMETERS

a Boolean vector or scalar of which to determine if any component is true.


DESCRIPTION

Returns true if a boolean scalar or all components of a boolean vector are true.


REFERENCE IMPLEMENTATION

all for a bool4 vector could be implemented like this.
bool all(bool4 a)
{
return a.x && a.y && a.z && a.w;
}


PROFILE SUPPORT

all is supported in all profiles.
Support in the fp20 is limited.


SEE ALSO

any

		]]></description>
		<tool-tip><![CDATA[
			all - returns true if a boolean scalar or all components of a boolean vector are true.

		]]></tool-tip>
		<ports>
			<input name="a">
				<check-type method="list" target="*">
					bool3,bool4,bool2,bool,bool1
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['bool3'] = 'bool',
						['bool2'] = 'bool',
						['bool'] = 'bool',
						['bool1'] = 'bool',
						['bool4'] = 'bool',
					}
					local types = node.a.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = all( r${node.a.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="tanh( a )">
		<description><![CDATA[
NAME

tanh - returns hyperbolic tangent of scalars and vectors.


SYNOPSIS

float tanh(float a);
float1 tanh(float1 a);
float2 tanh(float2 a);
float3 tanh(float3 a);
float4 tanh(float4 a);
half tanh(half a);
half1 tanh(half1 a);
half2 tanh(half2 a);
half3 tanh(half3 a);
half4 tanh(half4 a);
fixed tanh(fixed a);
fixed1 tanh(fixed1 a);
fixed2 tanh(fixed2 a);
fixed3 tanh(fixed3 a);
fixed4 tanh(fixed4 a);


PARAMETERS

a Vector or scalar of which to determine the hyperbolic tangent.


DESCRIPTION

Returns the hyperbolic tangent of a.
For vectors, the returned vector contains the hyperbolic tangent of each element of the input vector.


REFERENCE IMPLEMENTATION

tanh for a scalar float could be implemented like this.
float tanh(float x)
{
float exp2x = exp(2*x);
return (exp2x - 1) / (exp2x + 1);
}


PROFILE SUPPORT

tanh is supported in all profiles except fp20.


SEE ALSO

atan, atan2, cosh, exp, sinh, tan

		]]></description>
		<tool-tip><![CDATA[
			tanh - returns hyperbolic tangent of scalars and vectors.

		]]></tool-tip>
		<ports>
			<input name="a">
				<check-type method="list" target="*">
					half4,float4,half,half3,half1,fixed1,fixed4,float1,fixed3,fixed2,float3,float,fixed,half2,float2
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['float4'] = 'float4',
						['half2'] = 'half2',
						['half1'] = 'half1',
						['float'] = 'float',
						['float1'] = 'float1',
						['fixed2'] = 'fixed2',
						['fixed4'] = 'fixed4',
						['fixed3'] = 'fixed3',
						['float3'] = 'float3',
						['float2'] = 'float2',
						['fixed1'] = 'fixed1',
						['fixed'] = 'fixed',
						['half3'] = 'half3',
						['half4'] = 'half4',
						['half'] = 'half',
					}
					local types = node.a.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = tanh( r${node.a.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="ddy( a )">
		<description><![CDATA[
NAME

ddy - returns approximate partial derivative with respect to window-space Y


SYNOPSIS

float ddy(float a);
float1 ddy(float1 a);
float2 ddy(float2 a);
float3 ddy(float3 a);
float4 ddy(float4 a);
half ddy(half a);
half1 ddy(half1 a);
half2 ddy(half2 a);
half3 ddy(half3 a);
half4 ddy(half4 a);
fixed ddy(fixed a);
fixed1 ddy(fixed1 a);
fixed2 ddy(fixed2 a);
fixed3 ddy(fixed3 a);
fixed4 ddy(fixed4 a);


PARAMETERS

a Vector or scalar of which to approximate the partial derivative with respect to window-space Y.


DESCRIPTION

Returns approximate partial derivative of a with respect to the window-space (vertical) y coordinate.
For vectors, the returned vector contains the approximate partial derivative of each element of the input
vector.
This function is only available in fragment program profiles (but not all of them).
The specific way the partial derivative is computed is implementation-dependent. Typically fragments are
rasterized in 2x2 arrangements of fragments (called quad-fragments) and the partial derivatives of a
variable is computed by differencing with the adjacent horizontal fragment in the quad-fragment.
The partial derivative computation may incorrect when ddy is used in control flow paths where not all the
fragments within a quad-fragment have branched the same way.
The partial derivative computation may be less exact (wobbly) when the variable is computed based on
varying parameters interpolated with centroid interpolation.


REFERENCE IMPLEMENTATION

ddy is not expressible in Cg code.


PROFILE SUPPORT

ddy is supported only in fragment profiles. Vertex and geometry profiles lack the concept of window
space.
ddy is unsupported in the fp20, ps_1_1, ps_1_2, ps_1_3, and arbfp1 profiles.


SEE ALSO

ddx, fp30, fp40, fwidth, gp4fp

		]]></description>
		<tool-tip><![CDATA[
			ddy - returns approximate partial derivative with respect to window-space Y

		]]></tool-tip>
		<ports>
			<input name="a">
				<check-type method="list" target="*">
					half4,float4,half,half3,half1,fixed1,fixed4,float1,fixed3,fixed2,float3,float,fixed,half2,float2
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['float4'] = 'float4',
						['half2'] = 'half2',
						['half1'] = 'half1',
						['float'] = 'float',
						['float1'] = 'float1',
						['fixed2'] = 'fixed2',
						['fixed4'] = 'fixed4',
						['fixed3'] = 'fixed3',
						['float3'] = 'float3',
						['float2'] = 'float2',
						['fixed1'] = 'fixed1',
						['fixed'] = 'fixed',
						['half3'] = 'half3',
						['half4'] = 'half4',
						['half'] = 'half',
					}
					local types = node.a.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = ddy( r${node.a.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="texRECTlod( samp, s, texelOff )">
		<description><![CDATA[
NAME

texRECTlod - performs a texture lookup with a specified level of detail in a given sampler.


SYNOPSIS

float4 texRECTlod(samplerRECT samp, float4 s)
float4 texRECTlod(samplerRECT samp, float4 s, int texelOff)
int4 texRECTlod(isamplerRECT samp, float4 s)
int4 texRECTlod(isamplerRECT samp, float4 s, int texelOff)
uint4 texRECTlod(usamplerRECT samp, float4 s)
uint4 texRECTlod(usamplerRECT samp, float4 s, int texelOff)


PARAMETERS

samp Sampler to lookup.
s Coordinates to perform the lookup. The level of detail should be passed as the last component of
the coordinate vector.
texelOff Offset to be added to obtain the final texel.


DESCRIPTION

Performs a texture lookup with a specified level of detail in sampler samp using coordinates s.


REFERENCE IMPLEMENTATION



PROFILE SUPPORT

texRECTlod is supported in fragment profiles starting with fp40 and in vertex profiles starting with vp40.
Variants with texelOff are only supported in gp4 and newer profiles. Variants with integer samplers are also
only suppported in gp4 and newer profiles.


SEE ALSO

texRECTbias.de Sh
\$1

		]]></description>
		<tool-tip><![CDATA[
			texRECTlod - performs a texture lookup with a specified level of detail in a given sampler.

		]]></tool-tip>
		<ports>
			<input name="samp">
				<check-type method="list" target="*">
					isamplerRECT,usamplerRECT,samplerRECT
				</check-type>
			</input>
			<input name="s">
				<check-type method="list" target="*">
					float4
				</check-type>
			</input>
			<input name="texelOff">
				<check-type method="list" target="*">
					int
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['usamplerRECT,float4,int'] = 'uint4',
						['isamplerRECT,float4,int'] = 'int4',
						['samplerRECT,float4,int'] = 'float4',
					}
					local types = node.samp.get_type() .. ',' .. node.s.get_type() .. ',' .. node.texelOff.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = texRECTlod( r${node.samp.get_source().uid()}, r${node.s.get_source().uid()}, r${node.texelOff.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="tex3Dproj( samp, s )">
		<description><![CDATA[
NAME

tex3Dproj - performs a texture lookup with projection in a given sampler. May perform a shadow
comparison if argument for shadow comparison is provided.


SYNOPSIS

float4 tex3Dproj(sampler3D samp, float4 s)
float4 tex3Dproj(sampler3D samp, float4 s, int texelOff)
int4 tex3Dproj(isampler3D samp, float4 s)
int4 tex3Dproj(isampler3D samp, float4 s, int texelOff)
uint4 tex3Dproj(usampler3D samp, float4 s)
uint4 tex3Dproj(usampler3D samp, float4 s, int texelOff)


PARAMETERS

samp Sampler to lookup.
s Coordinates to perform the lookup. The value used in the projection should be passed as the last
component of the coordinate vector. The value used in the shadow comparison, if present, should
be passed as the next-to-last component of the coordinate vector.
texelOff Offset to be added to obtain the final texel.


DESCRIPTION

Performs a texture lookup in sampler samp using coordinates s, the coordinates used in the lookup are first
projected, that is, divided by the last component of the coordinate vector and them used in the lookup. If an
extra coordinate is present it is used to perform a shadow comparison, the value used in the shadow
comparison is always the next-to-last component in the coordinate vector.


REFERENCE IMPLEMENTATION



PROFILE SUPPORT

tex3Dproj is supported in all fragment profiles and all vertex profiles starting with vp40, variants with
shadow comparison are only supported in fp40 and newer profiles, variants with texel offsets are only
supported in gp4 and newer profiles.


SEE ALSO

tex3D

		]]></description>
		<tool-tip><![CDATA[
			tex3Dproj - performs a texture lookup with projection in a given sampler. May perform a shadow
comparison if argument for shadow comparison is provided.

		]]></tool-tip>
		<ports>
			<input name="samp">
				<check-type method="list" target="*">
					sampler3D,usampler3D,isampler3D
				</check-type>
			</input>
			<input name="s">
				<check-type method="list" target="*">
					float4
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['sampler3D,float4'] = 'float4',
						['usampler3D,float4'] = 'uint4',
						['isampler3D,float4'] = 'int4',
					}
					local types = node.samp.get_type() .. ',' .. node.s.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = tex3Dproj( r${node.samp.get_source().uid()}, r${node.s.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="tex1Dproj( samp, s, texelOff )">
		<description><![CDATA[
NAME

tex1Dproj - performs a texture lookup with projection in a given sampler. May perform a shadow
comparison if argument for shadow comparison is provided.


SYNOPSIS

float4 tex1Dproj(sampler1D samp, float2 s)
float4 tex1Dproj(sampler1D samp, float2 s, int texelOff)
float4 tex1Dproj(sampler1D samp, float3 s)
float4 tex1Dproj(sampler1D samp, float3 s, int texelOff)
int4 tex1Dproj(isampler1D samp, float2 s)
int4 tex1Dproj(isampler1D samp, float2 s, int texelOff)
uint4 tex1Dproj(usampler1D samp, float2 s)
uint4 tex1Dproj(usampler1D samp, float2 s, int texelOff)


PARAMETERS

samp Sampler to lookup.
s Coordinates to perform the lookup. The value used in the projection should be passed as the last
component of the coordinate vector. The value used in the shadow comparison, if present, should
be passed as the next-to-last component of the coordinate vector.
texelOff Offset to be added to obtain the final texel.


DESCRIPTION

Performs a texture lookup in sampler samp using coordinates s, the coordinates used in the lookup are first
projected, that is, divided by the last component of the coordinate vector and them used in the lookup. If an
extra coordinate is present it is used to perform a shadow comparison, the value used in the shadow
comparison is always the next-to-last component in the coordinate vector.


REFERENCE IMPLEMENTATION



PROFILE SUPPORT

tex1Dproj is supported in all fragment profiles and all vertex profiles starting with vp40, variants with
shadow comparison are only supported in fp40 and newer profiles, variants with texel offsets are only
supported in gp4 and newer profiles.


SEE ALSO

tex1D, tex1DARRAYproj

		]]></description>
		<tool-tip><![CDATA[
			tex1Dproj - performs a texture lookup with projection in a given sampler. May perform a shadow
comparison if argument for shadow comparison is provided.

		]]></tool-tip>
		<ports>
			<input name="samp">
				<check-type method="list" target="*">
					usampler1D,isampler1D,sampler1D
				</check-type>
			</input>
			<input name="s">
				<check-type method="list" target="*">
					float3,float2
				</check-type>
			</input>
			<input name="texelOff">
				<check-type method="list" target="*">
					int
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['usampler1D,float2,int'] = 'uint4',
						['sampler1D,float2,int'] = 'float4',
						['sampler1D,float3,int'] = 'float4',
						['isampler1D,float2,int'] = 'int4',
					}
					local types = node.samp.get_type() .. ',' .. node.s.get_type() .. ',' .. node.texelOff.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = tex1Dproj( r${node.samp.get_source().uid()}, r${node.s.get_source().uid()}, r${node.texelOff.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="sin( a )">
		<description><![CDATA[
NAME

sin - returns sine of scalars and vectors.


SYNOPSIS

float sin(float a);
float1 sin(float1 a);
float2 sin(float2 a);
float3 sin(float3 a);
float4 sin(float4 a);
half sin(half a);
half1 sin(half1 a);
half2 sin(half2 a);
half3 sin(half3 a);
half4 sin(half4 a);
fixed sin(fixed a);
fixed1 sin(fixed1 a);
fixed2 sin(fixed2 a);
fixed3 sin(fixed3 a);
fixed4 sin(fixed4 a);


PARAMETERS

a Vector or scalar of which to determine the sine.


DESCRIPTION

Returns the sine of a in radians. The return value is in the range [-1,+1].
For vectors, the returned vector contains the sine of each element of the input vector.


REFERENCE IMPLEMENTATION

sin is best implemented as a native sine instruction, however sin for a float scalar could be implemented by
an approximation like this.
float sin(float a)
{
/* C simulation gives a max absolute error of less than 1.8e-7 */
float4 c0 = float4( 0.0, 0.5,
1.0, 0.0 );
float4 c1 = float4( 0.25, -9.0,
0.75, 0.159154943091 );
float4 c2 = float4( 24.9808039603, -24.9808039603,
-60.1458091736, 60.1458091736 );
float4 c3 = float4( 85.4537887573, -85.4537887573,
-64.9393539429, 64.9393539429 );
float4 c4 = float4( 19.7392082214, -19.7392082214,
-1.0, 1.0 );
/* r0.x = sin(a) */
float3 r0, r1, r2;
r1.x = c1.w * a - c1.x; // only difference from cos!
r1.y = frac( r1.x ); // and extract fraction
r2.x = (float) ( r1.y < c1.x ); // range check: 0.0 to 0.25
r2.yz = (float2) ( r1.yy >= c1.yz ); // range check: 0.75 to 1.0
r2.y = dot( r2, c4.zwz ); // range check: 0.25 to 0.75
r0 = c0.xyz - r1.yyy; // range centering
r0 = r0 * r0;
r1 = c2.xyx * r0 + c2.zwz; // start power series
r1 = r1 * r0 + c3.xyx;
r1 = r1 * r0 + c3.zwz;
r1 = r1 * r0 + c4.xyx;
r1 = r1 * r0 + c4.zwz;
r0.x = dot( r1, -r2 ); // range extract
return r0.x;
}


PROFILE SUPPORT

sin is fully supported in all profiles unless otherwise specified.
sin is supported via an approximation (shown above) in the vs_1, vp20, and arbvp1 profiles.
sin is unsupported in the fp20, ps_1_1, ps_1_2, and ps_1_3 profiles.


SEE ALSO

asin, cos, dot, frac, tan

		]]></description>
		<tool-tip><![CDATA[
			sin - returns sine of scalars and vectors.

		]]></tool-tip>
		<ports>
			<input name="a">
				<check-type method="list" target="*">
					half4,float4,half,half3,half1,fixed1,fixed4,float1,fixed3,fixed2,float3,float,fixed,half2,float2
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['float4'] = 'float4',
						['half2'] = 'half2',
						['half1'] = 'half1',
						['float'] = 'float',
						['float1'] = 'float1',
						['fixed2'] = 'fixed2',
						['fixed4'] = 'fixed4',
						['fixed3'] = 'fixed3',
						['float3'] = 'float3',
						['float2'] = 'float2',
						['fixed1'] = 'fixed1',
						['fixed'] = 'fixed',
						['half3'] = 'half3',
						['half4'] = 'half4',
						['half'] = 'half',
					}
					local types = node.a.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = sin( r${node.a.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="cosh( a )">
		<description><![CDATA[
NAME

cosh - returns hyperbolic cosine of scalars and vectors.


SYNOPSIS

float cosh(float a);
float1 cosh(float1 a);
float2 cosh(float2 a);
float3 cosh(float3 a);
float4 cosh(float4 a);
half cosh(half a);
half1 cosh(half1 a);
half2 cosh(half2 a);
half3 cosh(half3 a);
half4 cosh(half4 a);
fixed cosh(fixed a);
fixed1 cosh(fixed1 a);
fixed2 cosh(fixed2 a);
fixed3 cosh(fixed3 a);
fixed4 cosh(fixed4 a);


PARAMETERS

a Vector or scalar of which to determine the hyperbolic cosine.


DESCRIPTION

Returns the hyperbolic cosine of a.
For vectors, the returned vector contains the hyperbolic cosine of each element of the input vector.


REFERENCE IMPLEMENTATION

cosh for a scalar float could be implemented like this.
float cosh(float x)
{
return 0.5 * (exp(x)+exp(-x));
}


PROFILE SUPPORT

cosh is supported in all profiles except fp20.


SEE ALSO

acos, cos, exp, sinh, tanh

		]]></description>
		<tool-tip><![CDATA[
			cosh - returns hyperbolic cosine of scalars and vectors.

		]]></tool-tip>
		<ports>
			<input name="a">
				<check-type method="list" target="*">
					half4,float4,half,half3,half1,fixed1,fixed4,float1,fixed3,fixed2,float3,float,fixed,half2,float2
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['float4'] = 'float4',
						['half2'] = 'half2',
						['half1'] = 'half1',
						['float'] = 'float',
						['float1'] = 'float1',
						['fixed2'] = 'fixed2',
						['fixed4'] = 'fixed4',
						['fixed3'] = 'fixed3',
						['float3'] = 'float3',
						['float2'] = 'float2',
						['fixed1'] = 'fixed1',
						['fixed'] = 'fixed',
						['half3'] = 'half3',
						['half4'] = 'half4',
						['half'] = 'half',
					}
					local types = node.a.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = cosh( r${node.a.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="tex1Dcmplod( samp, s, texelOff )">
		<description><![CDATA[
NAME

tex1Dcmplod - performs a texture lookup with a specified level of detail and a shadow compare in a given
sampler.


SYNOPSIS

float4 tex1Dcmplod(sampler1D samp, float4 s)
float4 tex1Dcmplod(sampler1D samp, float4 s, int texelOff)
int4 tex1Dcmplod(isampler1D samp, float4 s)
int4 tex1Dcmplod(isampler1D samp, float4 s, int texelOff)
uint4 tex1Dcmplod(usampler1D samp, float4 s)
uint4 tex1Dcmplod(usampler1D samp, float4 s, int texelOff)


PARAMETERS

samp Sampler to lookup.
s Coordinates to perform the lookup. The value used in the shadow comparison should be passed
right after the normal coordinates. The level of detail corresponds to the last component of the
coordinate vector.
texelOff Offset to be added to obtain the final texel.


DESCRIPTION

Performs a texture lookup with shadow compare and a specified level of detail in sampler samp using
coordinates s.


REFERENCE IMPLEMENTATION



PROFILE SUPPORT

tex1Dcmplod is supported in fragment profiles starting with fp40 and in vertex profiles starting with vp40.
Variants with texelOff are only supported in gp4 and newer profiles. Variants with integer samplers are also
only suppported in gp4 and newer profiles.


SEE ALSO

tex1Dlod, tex1Dcmpbias

		]]></description>
		<tool-tip><![CDATA[
			tex1Dcmplod - performs a texture lookup with a specified level of detail and a shadow compare in a given
sampler.

		]]></tool-tip>
		<ports>
			<input name="samp">
				<check-type method="list" target="*">
					usampler1D,isampler1D,sampler1D
				</check-type>
			</input>
			<input name="s">
				<check-type method="list" target="*">
					float4
				</check-type>
			</input>
			<input name="texelOff">
				<check-type method="list" target="*">
					int
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['sampler1D,float4,int'] = 'float4',
						['isampler1D,float4,int'] = 'int4',
						['usampler1D,float4,int'] = 'uint4',
					}
					local types = node.samp.get_type() .. ',' .. node.s.get_type() .. ',' .. node.texelOff.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = tex1Dcmplod( r${node.samp.get_source().uid()}, r${node.s.get_source().uid()}, r${node.texelOff.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="reflect( i, n )">
		<description><![CDATA[
NAME

reflect - returns the reflectiton vector given an incidence vector and a normal vector.


SYNOPSIS

float reflect(float i, float n);
float2 reflect(float2 i, float2 n);
float3 reflect(float3 i, float3 n);
float4 reflect(float4 i, float4 n);


PARAMETERS

i Incidence vector.
n Normal vector.


DESCRIPTION

Returns the reflectiton vector given an incidence vector i and a normal vector n. The resulting vector is the
identical number of components as the two input vectors.
The normal vector n should be normalized. If n is normalized, the output vector will have the same length
as the input incidence vector i.


REFERENCE IMPLEMENTATION

reflect for float3 vectors could be implemented this way:
float3 reflect( float3 i, float3 n )
{
return i - 2.0 * n * dot(n,i);
}


PROFILE SUPPORT

reflect is supported in all profiles.
Support in the fp20 is limited.


SEE ALSO

dot, length, refract

		]]></description>
		<tool-tip><![CDATA[
			reflect - returns the reflectiton vector given an incidence vector and a normal vector.

		]]></tool-tip>
		<ports>
			<input name="i">
				<check-type method="list" target="*">
					float,float4,float3,float2
				</check-type>
			</input>
			<input name="n">
				<check-type method="list" target="*">
					float,float4,float3,float2
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['float,float'] = 'float',
						['float4,float4'] = 'float4',
						['float2,float2'] = 'float2',
						['float3,float3'] = 'float3',
					}
					local types = node.i.get_type() .. ',' .. node.n.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = reflect( r${node.i.get_source().uid()}, r${node.n.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="tex1Dcmpbias( samp, s, texelOff )">
		<description><![CDATA[
NAME

tex1Dcmpbias - performs a texture lookup with bias and shadow compare in a given sampler.


SYNOPSIS

float4 tex1Dcmpbias(sampler1D samp, float4 s)
float4 tex1Dcmpbias(sampler1D samp, float4 s, int texelOff)


PARAMETERS

samp Sampler to lookup.
s Coordinates to perform the lookup. The value used in the shadow comparison should be passed
right after the normal coordinates. The bias value should be passed as the last component of the
coordinate vector.
texelOff Offset to be added to obtain the final texel.


DESCRIPTION

Performs a texture lookup with shadow compare and bias in sampler samp using coordinates s.


REFERENCE IMPLEMENTATION



PROFILE SUPPORT

tex1Dcmpbias is supported in fragment profiles starting with fp40 and in vertex profiles starting with vp40.
Variants with texelOff are only supported in gp4 and newer profiles.


SEE ALSO

tex1Dcmplod, tex1Dbias.de Sh
\$1

		]]></description>
		<tool-tip><![CDATA[
			tex1Dcmpbias - performs a texture lookup with bias and shadow compare in a given sampler.

		]]></tool-tip>
		<ports>
			<input name="samp">
				<check-type method="list" target="*">
					sampler1D
				</check-type>
			</input>
			<input name="s">
				<check-type method="list" target="*">
					float4
				</check-type>
			</input>
			<input name="texelOff">
				<check-type method="list" target="*">
					int
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['sampler1D,float4,int'] = 'float4',
					}
					local types = node.samp.get_type() .. ',' .. node.s.get_type() .. ',' .. node.texelOff.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = tex1Dcmpbias( r${node.samp.get_source().uid()}, r${node.s.get_source().uid()}, r${node.texelOff.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="frexp( x, e )">
		<description><![CDATA[
NAME

frexp - splits scalars and vectors into normalized fraction and a power of 2


SYNOPSIS

float frexp(float x, float e);
float1 frexp(float1 x, float1 e);
float2 frexp(float2 x, float2 e);
float3 frexp(float3 x, float3 e);
float4 frexp(float4 x, float4 e);
half frexp(half x, half e);
half1 frexp(half1 x, half1 e);
half2 frexp(half2 x, half2 e);
half3 frexp(half3 x, half3 e);
half4 frexp(half4 x, half4 e);
fixed frexp(fixed x, fixed e);
fixed1 frexp(fixed1 x, fixed1 e);
fixed2 frexp(fixed2 x, fixed2 e);
fixed3 frexp(fixed3 x, fixed3 e);
fixed4 frexp(fixed4 x, fixed4 e);


PARAMETERS

x Vector or scalar of which to split.
e Vector or scalar where the exponent of x is output.


DESCRIPTION

This function decomposes x into two parts: a mantissa between 0.5 and 1 (returned by the function) and an
exponent output as e.
If the value x is zero, both parts of the result are zero.
For vectors, the returned vector contains the mantissa of each element of the input vector and the output
vector contains the exponent of each element of the input vector.


REFERENCE IMPLEMENTATION

The example below is not legal Cg because it uses the & address-of operator not supported by Cg in order
to call the ANSI C frexp routine.
float3 frexp(float3 x, out float3 e)
{
float3 rv;
int i;
for (i=0; i<3; i++) {
float eout;
rv[i] = frexp(a[i], &eout); // this is the ANSI C standard library frexp()
e[i] = eout;
}
return rv;
}


PROFILE SUPPORT

frexp is fully supported in all profiles unless otherwise specified.
Support in the fp20 is limited to constant compile-time evaluation.


SEE ALSO

exp2, log, pow

		]]></description>
		<tool-tip><![CDATA[
			frexp - splits scalars and vectors into normalized fraction and a power of 2

		]]></tool-tip>
		<ports>
			<input name="x">
				<check-type method="list" target="*">
					half4,float4,half,half3,half1,fixed1,fixed4,float1,fixed3,fixed2,float3,float,fixed,half2,float2
				</check-type>
			</input>
			<input name="e">
				<check-type method="list" target="*">
					half4,float4,half,half3,half1,fixed1,fixed4,float1,fixed3,fixed2,float3,float,fixed,half2,float2
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['fixed1,fixed1'] = 'fixed1',
						['float4,float4'] = 'float4',
						['float3,float3'] = 'float3',
						['float,float'] = 'float',
						['fixed4,fixed4'] = 'fixed4',
						['fixed3,fixed3'] = 'fixed3',
						['fixed,fixed'] = 'fixed',
						['fixed2,fixed2'] = 'fixed2',
						['half4,half4'] = 'half4',
						['half3,half3'] = 'half3',
						['float1,float1'] = 'float1',
						['half,half'] = 'half',
						['half1,half1'] = 'half1',
						['float2,float2'] = 'float2',
						['half2,half2'] = 'half2',
					}
					local types = node.x.get_type() .. ',' .. node.e.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = frexp( r${node.x.get_source().uid()}, r${node.e.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
	<node type="texCUBEARRAY( samp, s, dx, dy )">
		<description><![CDATA[
NAME

texCUBEARRAY - performs a texture lookup in a given sampler array may use pre computed derivatives.


SYNOPSIS

float4 texCUBEARRAY(samplerCUBEARRAY samp, float4 s)
float4 texCUBEARRAY(samplerCUBEARRAY samp, float4 s, float3 dx, float3 dy)
int4 texCUBEARRAY(isamplerCUBEARRAY samp, float4 s)
int4 texCUBEARRAY(isamplerCUBEARRAY samp, float4 s, float3 dx, float3 dy)
uint4 texCUBEARRAY(usamplerCUBEARRAY samp, float4 s)
uint4 texCUBEARRAY(usamplerCUBEARRAY samp, float4 s, float3 dx, float3 dy)


PARAMETERS

samp Sampler array to look up.
s Coordinates to perform the lookup. The value used to select the layer is passed immediatelly after
the regular coordinates.
dx Pre computed derivative along the x axis.
dy Pre computed derivative along the y axis.
texelOff Offset to be added to obtain the final texel.


DESCRIPTION

Performs a texture lookup in sampler samp using coordinates s, the texture to be sampled is selected from
the layer specified in the coordinates. Also may use the derivatives dx and dy, the lookup may use texel
offset texelOff to compute the final texel.


REFERENCE IMPLEMENTATION



PROFILE SUPPORT

texCUBEARRAY is only supported in gp4 and newer profiles.


SEE ALSO

texCUBEARRAYbias, texCUBEARRAYlod

		]]></description>
		<tool-tip><![CDATA[
			texCUBEARRAY - performs a texture lookup in a given sampler array may use pre computed derivatives.

		]]></tool-tip>
		<ports>
			<input name="samp">
				<check-type method="list" target="*">
					samplerCUBEARRAY,isamplerCUBEARRAY,usamplerCUBEARRAY
				</check-type>
			</input>
			<input name="s">
				<check-type method="list" target="*">
					float4
				</check-type>
			</input>
			<input name="dx">
				<check-type method="list" target="*">
					float3
				</check-type>
			</input>
			<input name="dy">
				<check-type method="list" target="*">
					float3
				</check-type>
			</input>
			<output name="out">
				<get-type method="lua" target="*"><![CDATA[
					local valid = {
						['isamplerCUBEARRAY,float4,float3,float3'] = 'int4',
						['usamplerCUBEARRAY,float4,float3,float3'] = 'uint4',
						['samplerCUBEARRAY,float4,float3,float3'] = 'float4',
					}
					local types = node.samp.get_type() .. ',' .. node.s.get_type() .. ',' .. node.dx.get_type() .. ',' .. node.dy.get_type()
					return valid[types] or '?'
				]]></get-type>
			</output>
			<input-constraints method="lua" target="*"><![CDATA[
				return node.out.get_type() ~= '?'
			]]></input-constraints>
		</ports>
		<properties>
			<default-properties/>
		</properties>
		<code-generation>
			<code method="var-parse" target="*"><![CDATA[
				${node.out.get_type()} r${node.out.uid()} = texCUBEARRAY( r${node.samp.get_source().uid()}, r${node.s.get_source().uid()}, r${node.dx.get_source().uid()}, r${node.dy.get_source().uid()} );\n
			]]></code>
		</code-generation>
	</node>
</library>
