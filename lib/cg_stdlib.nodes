-- #################################################### --
-- abs( a )
-- #################################################### --
local cg_abs_1 = class(Node)
function cg_abs_1:get_help(out)
	out.write( '\n\nNAME\nabs - returns absolute value of scalars and vectors.\n\n\nSYNOPSIS\nfloat abs(float a);\nfloat1 abs(float1 a);\nfloat2 abs(float2 a);\nfloat3 abs(float3 a);\nfloat4 abs(float4 a);\nhalf abs(half a);\nhalf1 abs(half1 a);\nhalf2 abs(half2 a);\nhalf3 abs(half3 a);\nhalf4 abs(half4 a);\nfixed abs(fixed a);\nfixed1 abs(fixed1 a);\nfixed2 abs(fixed2 a);\nfixed3 abs(fixed3 a);\nfixed4 abs(fixed4 a);\n\n\nPARAMETERS\na Vector or scalar of which to determine the absolute value.\n\n\nDESCRIPTION\nReturns the absolute value of a scalar or vector.\nFor vectors, the returned vector contains the absolute value of each element of the input vector.\n\n\nREFERENCE IMPLEMENTATION\nabs for a float scalar could be implemented like this.\nfloat abs(float a)\n{\nreturn max(-a, a);\n}\n\n\nPROFILE SUPPORT\nabs is supported in all profiles.\nSupport in the fp20 is limited.\nConsider abs to be free or extremely inexpensive.\n\n\nSEE ALSO\nmax\n' )
end

function cg_abs_1:new()
	Node.new(self)
	self.name = 'abs'
	self.in_a = self.add_port(Input('a'))
	self.out = self.add_port(Output('out'))
end

function cg_abs_1:get_type(port)

	local type_a = self.in_a.get_output().get_type()
	if ((type_a == 'float')) then
		return 'float'
	end
	if ((type_a == 'float1')) then
		return 'float1'
	end
	if ((type_a == 'float2')) then
		return 'float2'
	end
	if ((type_a == 'float3')) then
		return 'float3'
	end
	if ((type_a == 'float4')) then
		return 'float4'
	end
	if ((type_a == 'half')) then
		return 'half'
	end
	if ((type_a == 'half1')) then
		return 'half1'
	end
	if ((type_a == 'half2')) then
		return 'half2'
	end
	if ((type_a == 'half3')) then
		return 'half3'
	end
	if ((type_a == 'half4')) then
		return 'half4'
	end
	if ((type_a == 'fixed')) then
		return 'fixed'
	end
	if ((type_a == 'fixed1')) then
		return 'fixed1'
	end
	if ((type_a == 'fixed2')) then
		return 'fixed2'
	end
	if ((type_a == 'fixed3')) then
		return 'fixed3'
	end
	if ((type_a == 'fixed4')) then
		return 'fixed4'
	end
	return nil
end

function cg_abs_1:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_abs_1:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_a = 'r' .. self.in_a.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = abs( ' .. in_a.. ' );\n')
end

function cg_abs_1:get_tip(out)
	out.write( 'abs - returns absolute value of scalars and vectors. ' )
end

-- #################################################### --
-- acos( a )
-- #################################################### --
local cg_acos_1 = class(Node)
function cg_acos_1:get_help(out)
	out.write( '\n\nNAME\nacos - returns arccosine of scalars and vectors.\n\n\nSYNOPSIS\nfloat acos(float a);\nfloat1 acos(float1 a);\nfloat2 acos(float2 a);\nfloat3 acos(float3 a);\nfloat4 acos(float4 a);\nhalf acos(half a);\nhalf1 acos(half1 a);\nhalf2 acos(half2 a);\nhalf3 acos(half3 a);\nhalf4 acos(half4 a);\nfixed acos(fixed a);\nfixed1 acos(fixed1 a);\nfixed2 acos(fixed2 a);\nfixed3 acos(fixed3 a);\nfixed4 acos(fixed4 a);\n\n\nPARAMETERS\na Vector or scalar of which to determine the arccosine.\n\n\nDESCRIPTION\nReturns the arccosine of a in the range [0,pi], expecting a to be in the range [-1,+1].\nFor vectors, the returned vector contains the arccosine of each element of the input vector.\n\n\nREFERENCE IMPLEMENTATION\nacos for a float scalar could be implemented like this.\n// Handbook of Mathematical Functions\n// M. Abramowitz and I.A. Stegun, Ed.\n// Absolute error <= 6.7e-5\nfloat acos(float x) {\nfloat negate = float(x < 0);\nx = abs(x);\nfloat ret = -0.0187293;\nret = ret * x;\nret = ret + 0.0742610;\nret = ret * x;\nret = ret - 0.2121144;\nret = ret * x;\nret = ret + 1.5707288;\nret = ret * sqrt(1.0-x);\nret = ret - 2 * negate * ret;\nreturn negate * 3.14159265358979 + ret;\n}\n\n\nPROFILE SUPPORT\nacos is supported in all profiles.\nSupport in the fp20 is limited.\n\n\nSEE ALSO\nabs, asin, cos, sqrt\n' )
end

function cg_acos_1:new()
	Node.new(self)
	self.name = 'acos'
	self.in_a = self.add_port(Input('a'))
	self.out = self.add_port(Output('out'))
end

function cg_acos_1:get_type(port)

	local type_a = self.in_a.get_output().get_type()
	if ((type_a == 'float')) then
		return 'float'
	end
	if ((type_a == 'float1')) then
		return 'float1'
	end
	if ((type_a == 'float2')) then
		return 'float2'
	end
	if ((type_a == 'float3')) then
		return 'float3'
	end
	if ((type_a == 'float4')) then
		return 'float4'
	end
	if ((type_a == 'half')) then
		return 'half'
	end
	if ((type_a == 'half1')) then
		return 'half1'
	end
	if ((type_a == 'half2')) then
		return 'half2'
	end
	if ((type_a == 'half3')) then
		return 'half3'
	end
	if ((type_a == 'half4')) then
		return 'half4'
	end
	if ((type_a == 'fixed')) then
		return 'fixed'
	end
	if ((type_a == 'fixed1')) then
		return 'fixed1'
	end
	if ((type_a == 'fixed2')) then
		return 'fixed2'
	end
	if ((type_a == 'fixed3')) then
		return 'fixed3'
	end
	if ((type_a == 'fixed4')) then
		return 'fixed4'
	end
	return nil
end

function cg_acos_1:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_acos_1:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_a = 'r' .. self.in_a.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = acos( ' .. in_a.. ' );\n')
end

function cg_acos_1:get_tip(out)
	out.write( 'acos - returns arccosine of scalars and vectors. ' )
end

-- #################################################### --
-- all( a )
-- #################################################### --
local cg_all_1 = class(Node)
function cg_all_1:get_help(out)
	out.write( '\n\nNAME\nall - returns true if a boolean scalar or all components of a boolean vector are true.\n\n\nSYNOPSIS\nbool all(bool a);\nbool all(bool1 a);\nbool all(bool2 a);\nbool all(bool3 a);\nbool all(bool4 a);\n\n\nPARAMETERS\na Boolean vector or scalar of which to determine if any component is true.\n\n\nDESCRIPTION\nReturns true if a boolean scalar or all components of a boolean vector are true.\n\n\nREFERENCE IMPLEMENTATION\nall for a bool4 vector could be implemented like this.\nbool all(bool4 a)\n{\nreturn a.x && a.y && a.z && a.w;\n}\n\n\nPROFILE SUPPORT\nall is supported in all profiles.\nSupport in the fp20 is limited.\n\n\nSEE ALSO\nany\n' )
end

function cg_all_1:new()
	Node.new(self)
	self.name = 'all'
	self.in_a = self.add_port(Input('a'))
	self.out = self.add_port(Output('out'))
end

function cg_all_1:get_type(port)

	local type_a = self.in_a.get_output().get_type()
	if ((type_a == 'bool')) then
		return 'bool'
	end
	if ((type_a == 'bool1')) then
		return 'bool'
	end
	if ((type_a == 'bool2')) then
		return 'bool'
	end
	if ((type_a == 'bool3')) then
		return 'bool'
	end
	if ((type_a == 'bool4')) then
		return 'bool'
	end
	return nil
end

function cg_all_1:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_all_1:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_a = 'r' .. self.in_a.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = all( ' .. in_a.. ' );\n')
end

function cg_all_1:get_tip(out)
	out.write( 'all - returns true if a boolean scalar or all components of a boolean vector are true. ' )
end

-- #################################################### --
-- any( a )
-- #################################################### --
local cg_any_1 = class(Node)
function cg_any_1:get_help(out)
	out.write( '\n\nNAME\nany - returns true if a boolean scalar or any component of a boolean vector is true.\n\n\nSYNOPSIS\nbool any(bool a);\nbool any(bool1 a);\nbool any(bool2 a);\nbool any(bool3 a);\nbool any(bool4 a);\n\n\nPARAMETERS\na Boolean vector or scalar of which to determine if any component is true.\n\n\nDESCRIPTION\nReturns true if a boolean scalar or any component of a boolean vector is true.\n\n\nREFERENCE IMPLEMENTATION\nany for a bool4 vector could be implemented like this.\nbool any(bool4 a)\n{\nreturn a.x ïï a.y ïï a.z ïï a.w;\n}\n\n\nPROFILE SUPPORT\nany is supported in all profiles.\nSupport in the fp20 is limited.\n\n\nSEE ALSO\nall\n' )
end

function cg_any_1:new()
	Node.new(self)
	self.name = 'any'
	self.in_a = self.add_port(Input('a'))
	self.out = self.add_port(Output('out'))
end

function cg_any_1:get_type(port)

	local type_a = self.in_a.get_output().get_type()
	if ((type_a == 'bool')) then
		return 'bool'
	end
	if ((type_a == 'bool1')) then
		return 'bool'
	end
	if ((type_a == 'bool2')) then
		return 'bool'
	end
	if ((type_a == 'bool3')) then
		return 'bool'
	end
	if ((type_a == 'bool4')) then
		return 'bool'
	end
	return nil
end

function cg_any_1:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_any_1:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_a = 'r' .. self.in_a.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = any( ' .. in_a.. ' );\n')
end

function cg_any_1:get_tip(out)
	out.write( 'any - returns true if a boolean scalar or any component of a boolean vector is true. ' )
end

-- #################################################### --
-- asin( a )
-- #################################################### --
local cg_asin_1 = class(Node)
function cg_asin_1:get_help(out)
	out.write( '\n\nNAME\nasin - returns arcsine of scalars and vectors.\n\n\nSYNOPSIS\nfloat asin(float a);\nfloat1 asin(float1 a);\nfloat2 asin(float2 a);\nfloat3 asin(float3 a);\nfloat4 asin(float4 a);\nhalf asin(half a);\nhalf1 asin(half1 a);\nhalf2 asin(half2 a);\nhalf3 asin(half3 a);\nhalf4 asin(half4 a);\nfixed asin(fixed a);\nfixed1 asin(fixed1 a);\nfixed2 asin(fixed2 a);\nfixed3 asin(fixed3 a);\nfixed4 asin(fixed4 a);\n\n\nPARAMETERS\na Vector or scalar of which to determine the arcsine.\n\n\nDESCRIPTION\nReturns the arcsine of a in the range [-pi/2,+pi/2], expecting a to be in the range [-1,+1].\nFor vectors, the returned vector contains the arcsine of each element of the input vector.\n\n\nREFERENCE IMPLEMENTATION\nasin for a float scalar could be implemented like this.\n// Handbook of Mathematical Functions\n// M. Abramowitz and I.A. Stegun, Ed.\nfloat asin(float x) {\nfloat negate = float(x < 0);\nx = abs(x);\nfloat ret = -0.0187293;\nret *= x;\nret += 0.0742610;\nret *= x;\nret -= 0.2121144;\nret *= x;\nret += 1.5707288;\nret = 3.14159265358979*0.5 - sqrt(1.0 - x)*ret;\nreturn ret - 2 * negate * ret;\n}\n\n\nPROFILE SUPPORT\nasin is supported in all profiles.\nSupport in the fp20 is limited.\n\n\nSEE ALSO\nabs, acos, sin, sqrt\n' )
end

function cg_asin_1:new()
	Node.new(self)
	self.name = 'asin'
	self.in_a = self.add_port(Input('a'))
	self.out = self.add_port(Output('out'))
end

function cg_asin_1:get_type(port)

	local type_a = self.in_a.get_output().get_type()
	if ((type_a == 'float')) then
		return 'float'
	end
	if ((type_a == 'float1')) then
		return 'float1'
	end
	if ((type_a == 'float2')) then
		return 'float2'
	end
	if ((type_a == 'float3')) then
		return 'float3'
	end
	if ((type_a == 'float4')) then
		return 'float4'
	end
	if ((type_a == 'half')) then
		return 'half'
	end
	if ((type_a == 'half1')) then
		return 'half1'
	end
	if ((type_a == 'half2')) then
		return 'half2'
	end
	if ((type_a == 'half3')) then
		return 'half3'
	end
	if ((type_a == 'half4')) then
		return 'half4'
	end
	if ((type_a == 'fixed')) then
		return 'fixed'
	end
	if ((type_a == 'fixed1')) then
		return 'fixed1'
	end
	if ((type_a == 'fixed2')) then
		return 'fixed2'
	end
	if ((type_a == 'fixed3')) then
		return 'fixed3'
	end
	if ((type_a == 'fixed4')) then
		return 'fixed4'
	end
	return nil
end

function cg_asin_1:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_asin_1:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_a = 'r' .. self.in_a.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = asin( ' .. in_a.. ' );\n')
end

function cg_asin_1:get_tip(out)
	out.write( 'asin - returns arcsine of scalars and vectors. ' )
end

-- #################################################### --
-- atan( a )
-- #################################################### --
local cg_atan_1 = class(Node)
function cg_atan_1:get_help(out)
	out.write( '\n\nNAME\natan - returns arctangent of scalars and vectors.\n\n\nSYNOPSIS\nfloat atan(float a);\nfloat1 atan(float1 a);\nfloat2 atan(float2 a);\nfloat3 atan(float3 a);\nfloat4 atan(float4 a);\nhalf atan(half a);\nhalf1 atan(half1 a);\nhalf2 atan(half2 a);\nhalf3 atan(half3 a);\nhalf4 atan(half4 a);\nfixed atan(fixed a);\nfixed1 atan(fixed1 a);\nfixed2 atan(fixed2 a);\nfixed3 atan(fixed3 a);\nfixed4 atan(fixed4 a);\n\n\nPARAMETERS\na Vector or scalar of which to determine the arctangent.\n\n\nDESCRIPTION\nReturns the arctangent of x in the range of -pi/2 to pi/2 radians.\nFor vectors, the returned vector contains the arctangent of each element of the input vector.\n\n\nREFERENCE IMPLEMENTATION\natan for a float scalar could be implemented like this.\nfloat atan(float x) {\nreturn atan2(x, float(1));\n}\natan2 is typically implemented as an approximation.\n\n\nPROFILE SUPPORT\natan is supported in all profiles but fp20.\n\n\nSEE ALSO\nabs, acos, asin, atan2. sqrt, tan\n' )
end

function cg_atan_1:new()
	Node.new(self)
	self.name = 'atan'
	self.in_a = self.add_port(Input('a'))
	self.out = self.add_port(Output('out'))
end

function cg_atan_1:get_type(port)

	local type_a = self.in_a.get_output().get_type()
	if ((type_a == 'float')) then
		return 'float'
	end
	if ((type_a == 'float1')) then
		return 'float1'
	end
	if ((type_a == 'float2')) then
		return 'float2'
	end
	if ((type_a == 'float3')) then
		return 'float3'
	end
	if ((type_a == 'float4')) then
		return 'float4'
	end
	if ((type_a == 'half')) then
		return 'half'
	end
	if ((type_a == 'half1')) then
		return 'half1'
	end
	if ((type_a == 'half2')) then
		return 'half2'
	end
	if ((type_a == 'half3')) then
		return 'half3'
	end
	if ((type_a == 'half4')) then
		return 'half4'
	end
	if ((type_a == 'fixed')) then
		return 'fixed'
	end
	if ((type_a == 'fixed1')) then
		return 'fixed1'
	end
	if ((type_a == 'fixed2')) then
		return 'fixed2'
	end
	if ((type_a == 'fixed3')) then
		return 'fixed3'
	end
	if ((type_a == 'fixed4')) then
		return 'fixed4'
	end
	return nil
end

function cg_atan_1:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_atan_1:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_a = 'r' .. self.in_a.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = atan( ' .. in_a.. ' );\n')
end

function cg_atan_1:get_tip(out)
	out.write( 'atan - returns arctangent of scalars and vectors. ' )
end

-- #################################################### --
-- atan2( y, x )
-- #################################################### --
local cg_atan2_2 = class(Node)
function cg_atan2_2:get_help(out)
	out.write( '\n\nNAME\natan2 - returns arctangent of scalars and vectors.\n\n\nSYNOPSIS\nfloat atan2(float y, float x);\nfloat1 atan2(float1 y, float1 x);\nfloat2 atan2(float2 y, float2 x);\nfloat3 atan2(float3 y, float3 x);\nfloat4 atan2(float4 y, float4 x);\nhalf atan2(half y, half x);\nhalf1 atan2(half1 y, half1 x);\nhalf2 atan2(half2 y, half2 x);\nhalf3 atan2(half3 y, half3 x);\nhalf4 atan2(half4 y, half4 x);\nfixed atan2(fixed y, fixed x);\nfixed1 atan2(fixed1 y, fixed1 x);\nfixed2 atan2(fixed2 y, fixed2 x);\nfixed3 atan2(fixed3 y, fixed3 x);\nfixed4 atan2(fixed4 y, fixed4 x);\n\n\nPARAMETERS\ny Vector or scalar for numerator of ratio of which to determine the arctangent.\nx Vector or scalar of denominator of ratio of which to determine the arctangent.\n\n\nDESCRIPTION\natan2 calculates the arctangent of y/x. atan2 is well defined for every point other than the origin, even if x\nequals 0 and y does not equal 0.\nFor vectors, the returned vector contains the arctangent of each element of the input vector.\n\n\nREFERENCE IMPLEMENTATION\natan2 for a float2 scalar could be implemented as an approximation like this.\nfloat2 atan2(float2 y, float2 x)\n{\nfloat2 t0, t1, t2, t3, t4;\nt3 = abs(x);\nt1 = abs(y);\nt0 = max(t3, t1);\nt1 = min(t3, t1);\nt3 = float(1) / t0;\nt3 = t1 * t3;\nt4 = t3 * t3;\nt0 = - float(0.013480470);\nt0 = t0 * t4 + float(0.057477314);\nt0 = t0 * t4 - float(0.121239071);\nt0 = t0 * t4 + float(0.195635925);\nt0 = t0 * t4 - float(0.332994597);\nt0 = t0 * t4 + float(0.999995630);\nt3 = t0 * t3;\nt3 = (abs(y) > abs(x)) ? float(1.570796327) - t3 : t3;\nt3 = (x < 0) ? float(3.141592654) - t3 : t3;\nt3 = (y < 0) ? -t3 : t3;\nreturn t3;\n}\n\n\nPROFILE SUPPORT\natan2 is supported in all profiles but fp20.\n\n\nSEE ALSO\nabs, acos, asin, atan. sqrt, tan\n' )
end

function cg_atan2_2:new()
	Node.new(self)
	self.name = 'atan2'
	self.in_y = self.add_port(Input('y'))
	self.in_x = self.add_port(Input('x'))
	self.out = self.add_port(Output('out'))
end

function cg_atan2_2:get_type(port)

	local type_y = self.in_y.get_output().get_type()
	local type_x = self.in_x.get_output().get_type()
	if ((type_y == 'float')
	and (type_x == 'float')) then
		return 'float'
	end
	if ((type_y == 'float1')
	and (type_x == 'float1')) then
		return 'float1'
	end
	if ((type_y == 'float2')
	and (type_x == 'float2')) then
		return 'float2'
	end
	if ((type_y == 'float3')
	and (type_x == 'float3')) then
		return 'float3'
	end
	if ((type_y == 'float4')
	and (type_x == 'float4')) then
		return 'float4'
	end
	if ((type_y == 'half')
	and (type_x == 'half')) then
		return 'half'
	end
	if ((type_y == 'half1')
	and (type_x == 'half1')) then
		return 'half1'
	end
	if ((type_y == 'half2')
	and (type_x == 'half2')) then
		return 'half2'
	end
	if ((type_y == 'half3')
	and (type_x == 'half3')) then
		return 'half3'
	end
	if ((type_y == 'half4')
	and (type_x == 'half4')) then
		return 'half4'
	end
	if ((type_y == 'fixed')
	and (type_x == 'fixed')) then
		return 'fixed'
	end
	if ((type_y == 'fixed1')
	and (type_x == 'fixed1')) then
		return 'fixed1'
	end
	if ((type_y == 'fixed2')
	and (type_x == 'fixed2')) then
		return 'fixed2'
	end
	if ((type_y == 'fixed3')
	and (type_x == 'fixed3')) then
		return 'fixed3'
	end
	if ((type_y == 'fixed4')
	and (type_x == 'fixed4')) then
		return 'fixed4'
	end
	return nil
end

function cg_atan2_2:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_atan2_2:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_y = 'r' .. self.in_y.get_output().hex()
	local in_x = 'r' .. self.in_x.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = atan2( ' .. in_y.. ', ' .. in_x.. ' );\n')
end

function cg_atan2_2:get_tip(out)
	out.write( 'atan2 - returns arctangent of scalars and vectors. ' )
end

-- #################################################### --
-- ceil( a )
-- #################################################### --
local cg_ceil_1 = class(Node)
function cg_ceil_1:get_help(out)
	out.write( '\n\nNAME\nceil - returns smallest integer not less than a scalar or each vector component.\n\n\nSYNOPSIS\nfloat ceil(float a);\nfloat1 ceil(float1 a);\nfloat2 ceil(float2 a);\nfloat3 ceil(float3 a);\nfloat4 ceil(float4 a);\nhalf ceil(half a);\nhalf1 ceil(half1 a);\nhalf2 ceil(half2 a);\nhalf3 ceil(half3 a);\nhalf4 ceil(half4 a);\nfixed ceil(fixed a);\nfixed1 ceil(fixed1 a);\nfixed2 ceil(fixed2 a);\nfixed3 ceil(fixed3 a);\nfixed4 ceil(fixed4 a);\n\n\nPARAMETERS\na Vector or scalar of which to determine the ceiling.\n\n\nDESCRIPTION\nReturns the ceiling or smallest integer not less than a scalar or each vector component.\n\n\nREFERENCE IMPLEMENTATION\nceil for a float scalar could be implemented like this.\nfloat ceil(float v)\n{\nreturn -floor(-v);\n}\n\n\nPROFILE SUPPORT\nceil is supported in all profiles except fp20.\n\n\nSEE ALSO\nfloor\n' )
end

function cg_ceil_1:new()
	Node.new(self)
	self.name = 'ceil'
	self.in_a = self.add_port(Input('a'))
	self.out = self.add_port(Output('out'))
end

function cg_ceil_1:get_type(port)

	local type_a = self.in_a.get_output().get_type()
	if ((type_a == 'float')) then
		return 'float'
	end
	if ((type_a == 'float1')) then
		return 'float1'
	end
	if ((type_a == 'float2')) then
		return 'float2'
	end
	if ((type_a == 'float3')) then
		return 'float3'
	end
	if ((type_a == 'float4')) then
		return 'float4'
	end
	if ((type_a == 'half')) then
		return 'half'
	end
	if ((type_a == 'half1')) then
		return 'half1'
	end
	if ((type_a == 'half2')) then
		return 'half2'
	end
	if ((type_a == 'half3')) then
		return 'half3'
	end
	if ((type_a == 'half4')) then
		return 'half4'
	end
	if ((type_a == 'fixed')) then
		return 'fixed'
	end
	if ((type_a == 'fixed1')) then
		return 'fixed1'
	end
	if ((type_a == 'fixed2')) then
		return 'fixed2'
	end
	if ((type_a == 'fixed3')) then
		return 'fixed3'
	end
	if ((type_a == 'fixed4')) then
		return 'fixed4'
	end
	return nil
end

function cg_ceil_1:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_ceil_1:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_a = 'r' .. self.in_a.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = ceil( ' .. in_a.. ' );\n')
end

function cg_ceil_1:get_tip(out)
	out.write( 'ceil - returns smallest integer not less than a scalar or each vector component. ' )
end

-- #################################################### --
-- clamp( x, a, b )
-- #################################################### --
local cg_clamp_3 = class(Node)
function cg_clamp_3:get_help(out)
	out.write( '\n\nNAME\nclamp - returns smallest integer not less than a scalar or each vector component.\n\n\nSYNOPSIS\nfloat clamp(float x, float a, float b);\nfloat1 clamp(float1 x, float1 a, float1 b);\nfloat2 clamp(float2 x, float2 a, float2 b);\nfloat3 clamp(float3 x, float3 a, float3 b);\nfloat4 clamp(float4 x, float4 a, float4 b);\nhalf clamp(half x, half a, half b);\nhalf1 clamp(half1 x, half1 a, half1 b);\nhalf2 clamp(half2 x, half2 a, half2 b);\nhalf3 clamp(half3 x, half3 a, half3 b);\nhalf4 clamp(half4 x, half4 a, half4 b);\nfixed clamp(fixed x, fixed a, fixed b);\nfixed1 clamp(fixed1 x, fixed1 a, fixed1 b);\nfixed2 clamp(fixed2 x, fixed2 a, fixed2 b);\nfixed3 clamp(fixed3 x, fixed3 a, fixed3 b);\nfixed4 clamp(fixed4 x, fixed4 a, fixed4 b);\n\n\nPARAMETERS\nx Vector or scalar to clamp.\na Vector or scalar for bottom of clamp range.\nb Vector or scalar for top of clamp range.\n\n\nDESCRIPTION\nReturns x clamped to the range [a,b] as follows:\n1) Returns a if x is less than a; else\n2) Returns b if x is greater than b; else\n3) Returns x otherwise.\nFor vectors, the returned vector contains the clamped result of each element of the vector x clamped using\nthe respective element of vectors a and b.\n\n\nREFERENCE IMPLEMENTATION\nclamp for float scalars could be implemented like this.\nfloat clamp(float x, float a, float b)\n{\nreturn max(a, min(b, x));\n}\n\n\nPROFILE SUPPORT\nclamp is supported in all profiles except fp20.\n\n\nSEE ALSO\nmax, min, saturate\n' )
end

function cg_clamp_3:new()
	Node.new(self)
	self.name = 'clamp'
	self.in_x = self.add_port(Input('x'))
	self.in_a = self.add_port(Input('a'))
	self.in_b = self.add_port(Input('b'))
	self.out = self.add_port(Output('out'))
end

function cg_clamp_3:get_type(port)

	local type_x = self.in_x.get_output().get_type()
	local type_a = self.in_a.get_output().get_type()
	local type_b = self.in_b.get_output().get_type()
	if ((type_x == 'float')
	and (type_a == 'float')
	and (type_b == 'float')) then
		return 'float'
	end
	if ((type_x == 'float1')
	and (type_a == 'float1')
	and (type_b == 'float1')) then
		return 'float1'
	end
	if ((type_x == 'float2')
	and (type_a == 'float2')
	and (type_b == 'float2')) then
		return 'float2'
	end
	if ((type_x == 'float3')
	and (type_a == 'float3')
	and (type_b == 'float3')) then
		return 'float3'
	end
	if ((type_x == 'float4')
	and (type_a == 'float4')
	and (type_b == 'float4')) then
		return 'float4'
	end
	if ((type_x == 'half')
	and (type_a == 'half')
	and (type_b == 'half')) then
		return 'half'
	end
	if ((type_x == 'half1')
	and (type_a == 'half1')
	and (type_b == 'half1')) then
		return 'half1'
	end
	if ((type_x == 'half2')
	and (type_a == 'half2')
	and (type_b == 'half2')) then
		return 'half2'
	end
	if ((type_x == 'half3')
	and (type_a == 'half3')
	and (type_b == 'half3')) then
		return 'half3'
	end
	if ((type_x == 'half4')
	and (type_a == 'half4')
	and (type_b == 'half4')) then
		return 'half4'
	end
	if ((type_x == 'fixed')
	and (type_a == 'fixed')
	and (type_b == 'fixed')) then
		return 'fixed'
	end
	if ((type_x == 'fixed1')
	and (type_a == 'fixed1')
	and (type_b == 'fixed1')) then
		return 'fixed1'
	end
	if ((type_x == 'fixed2')
	and (type_a == 'fixed2')
	and (type_b == 'fixed2')) then
		return 'fixed2'
	end
	if ((type_x == 'fixed3')
	and (type_a == 'fixed3')
	and (type_b == 'fixed3')) then
		return 'fixed3'
	end
	if ((type_x == 'fixed4')
	and (type_a == 'fixed4')
	and (type_b == 'fixed4')) then
		return 'fixed4'
	end
	return nil
end

function cg_clamp_3:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_clamp_3:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_x = 'r' .. self.in_x.get_output().hex()
	local in_a = 'r' .. self.in_a.get_output().hex()
	local in_b = 'r' .. self.in_b.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = clamp( ' .. in_x.. ', ' .. in_a.. ', ' .. in_b.. ' );\n')
end

function cg_clamp_3:get_tip(out)
	out.write( 'clamp - returns smallest integer not less than a scalar or each vector component. ' )
end

-- #################################################### --
-- cos( a )
-- #################################################### --
local cg_cos_1 = class(Node)
function cg_cos_1:get_help(out)
	out.write( '\n\nNAME\ncos - returns cosine of scalars and vectors.\n\n\nSYNOPSIS\nfloat cos(float a);\nfloat1 cos(float1 a);\nfloat2 cos(float2 a);\nfloat3 cos(float3 a);\nfloat4 cos(float4 a);\nhalf cos(half a);\nhalf1 cos(half1 a);\nhalf2 cos(half2 a);\nhalf3 cos(half3 a);\nhalf4 cos(half4 a);\nfixed cos(fixed a);\nfixed1 cos(fixed1 a);\nfixed2 cos(fixed2 a);\nfixed3 cos(fixed3 a);\nfixed4 cos(fixed4 a);\n\n\nPARAMETERS\na Vector or scalar of which to determine the cosine.\n\n\nDESCRIPTION\nReturns the cosine of a in radians. The return value is in the range [-1,+1].\nFor vectors, the returned vector contains the cosine of each element of the input vector.\n\n\nREFERENCE IMPLEMENTATION\ncos is best implemented as a native cosine instruction, however cos for a float scalar could be implemented\nby an approximation like this.\ncos(float a)\n{\n/* C simulation gives a max absolute error of less than 1.8e-7 */\nconst float4 c0 = float4( 0.0, 0.5,\n1.0, 0.0 );\nconst float4 c1 = float4( 0.25, -9.0,\n0.75, 0.159154943091 );\nconst float4 c2 = float4( 24.9808039603, -24.9808039603,\n-60.1458091736, 60.1458091736 );\nconst float4 c3 = float4( 85.4537887573, -85.4537887573,\n-64.9393539429, 64.9393539429 );\nconst float4 c4 = float4( 19.7392082214, -19.7392082214,\n-1.0, 1.0 );\n/* r0.x = cos(a) */\nfloat3 r0, r1, r2;\nr1.x = c1.w * a; // normalize input\nr1.y = frac( r1.x ); // and extract fraction\nr2.x = (float) ( r1.y < c1.x ); // range check: 0.0 to 0.25\nr2.yz = (float2) ( r1.yy >= c1.yz ); // range check: 0.75 to 1.0\nr2.y = dot( r2, c4.zwz ); // range check: 0.25 to 0.75\nr0 = c0.xyz - r1.yyy; // range centering\nr0 = r0 * r0;\nr1 = c2.xyx * r0 + c2.zwz; // start power series\nr1 = r1 * r0 + c3.xyx;\nr1 = r1 * r0 + c3.zwz;\nr1 = r1 * r0 + c4.xyx;\nr1 = r1 * r0 + c4.zwz;\nr0.x = dot( r1, -r2 ); // range extract\nreturn r0.x;\n\n\nPROFILE SUPPORT\ncos is fully supported in all profiles unless otherwise specified.\ncos is supported via an approximation (shown above) in the vs_1, vp20, and arbvp1 profiles.\ncos is unsupported in the fp20, ps_1_1, ps_1_2, and ps_1_3 profiles.\n\n\nSEE ALSO\nacos, dot, frac, sin, tan\n' )
end

function cg_cos_1:new()
	Node.new(self)
	self.name = 'cos'
	self.in_a = self.add_port(Input('a'))
	self.out = self.add_port(Output('out'))
end

function cg_cos_1:get_type(port)

	local type_a = self.in_a.get_output().get_type()
	if ((type_a == 'float')) then
		return 'float'
	end
	if ((type_a == 'float1')) then
		return 'float1'
	end
	if ((type_a == 'float2')) then
		return 'float2'
	end
	if ((type_a == 'float3')) then
		return 'float3'
	end
	if ((type_a == 'float4')) then
		return 'float4'
	end
	if ((type_a == 'half')) then
		return 'half'
	end
	if ((type_a == 'half1')) then
		return 'half1'
	end
	if ((type_a == 'half2')) then
		return 'half2'
	end
	if ((type_a == 'half3')) then
		return 'half3'
	end
	if ((type_a == 'half4')) then
		return 'half4'
	end
	if ((type_a == 'fixed')) then
		return 'fixed'
	end
	if ((type_a == 'fixed1')) then
		return 'fixed1'
	end
	if ((type_a == 'fixed2')) then
		return 'fixed2'
	end
	if ((type_a == 'fixed3')) then
		return 'fixed3'
	end
	if ((type_a == 'fixed4')) then
		return 'fixed4'
	end
	return nil
end

function cg_cos_1:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_cos_1:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_a = 'r' .. self.in_a.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = cos( ' .. in_a.. ' );\n')
end

function cg_cos_1:get_tip(out)
	out.write( 'cos - returns cosine of scalars and vectors. ' )
end

-- #################################################### --
-- cosh( a )
-- #################################################### --
local cg_cosh_1 = class(Node)
function cg_cosh_1:get_help(out)
	out.write( '\n\nNAME\ncosh - returns hyperbolic cosine of scalars and vectors.\n\n\nSYNOPSIS\nfloat cosh(float a);\nfloat1 cosh(float1 a);\nfloat2 cosh(float2 a);\nfloat3 cosh(float3 a);\nfloat4 cosh(float4 a);\nhalf cosh(half a);\nhalf1 cosh(half1 a);\nhalf2 cosh(half2 a);\nhalf3 cosh(half3 a);\nhalf4 cosh(half4 a);\nfixed cosh(fixed a);\nfixed1 cosh(fixed1 a);\nfixed2 cosh(fixed2 a);\nfixed3 cosh(fixed3 a);\nfixed4 cosh(fixed4 a);\n\n\nPARAMETERS\na Vector or scalar of which to determine the hyperbolic cosine.\n\n\nDESCRIPTION\nReturns the hyperbolic cosine of a.\nFor vectors, the returned vector contains the hyperbolic cosine of each element of the input vector.\n\n\nREFERENCE IMPLEMENTATION\ncosh for a scalar float could be implemented like this.\nfloat cosh(float x)\n{\nreturn 0.5 * (exp(x)+exp(-x));\n}\n\n\nPROFILE SUPPORT\ncosh is supported in all profiles except fp20.\n\n\nSEE ALSO\nacos, cos, exp, sinh, tanh\n' )
end

function cg_cosh_1:new()
	Node.new(self)
	self.name = 'cosh'
	self.in_a = self.add_port(Input('a'))
	self.out = self.add_port(Output('out'))
end

function cg_cosh_1:get_type(port)

	local type_a = self.in_a.get_output().get_type()
	if ((type_a == 'float')) then
		return 'float'
	end
	if ((type_a == 'float1')) then
		return 'float1'
	end
	if ((type_a == 'float2')) then
		return 'float2'
	end
	if ((type_a == 'float3')) then
		return 'float3'
	end
	if ((type_a == 'float4')) then
		return 'float4'
	end
	if ((type_a == 'half')) then
		return 'half'
	end
	if ((type_a == 'half1')) then
		return 'half1'
	end
	if ((type_a == 'half2')) then
		return 'half2'
	end
	if ((type_a == 'half3')) then
		return 'half3'
	end
	if ((type_a == 'half4')) then
		return 'half4'
	end
	if ((type_a == 'fixed')) then
		return 'fixed'
	end
	if ((type_a == 'fixed1')) then
		return 'fixed1'
	end
	if ((type_a == 'fixed2')) then
		return 'fixed2'
	end
	if ((type_a == 'fixed3')) then
		return 'fixed3'
	end
	if ((type_a == 'fixed4')) then
		return 'fixed4'
	end
	return nil
end

function cg_cosh_1:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_cosh_1:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_a = 'r' .. self.in_a.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = cosh( ' .. in_a.. ' );\n')
end

function cg_cosh_1:get_tip(out)
	out.write( 'cosh - returns hyperbolic cosine of scalars and vectors. ' )
end

-- #################################################### --
-- cross( a, b )
-- #################################################### --
local cg_cross_2 = class(Node)
function cg_cross_2:get_help(out)
	out.write( '\n\nNAME\ncross - returns the cross product of two three-component vectors\n\n\nSYNOPSIS\nfloat3 cross(float3 a, float3 b);\nhalf3 cross(half3 a, half3 b);\nfixed3 cross(fixed3 a, fixed3 b);\n\n\nPARAMETERS\na Three-component vector.\nb Three-component vector.\n\n\nDESCRIPTION\nReturns the cross product of three-component vectors a and b. The result is a three-component vector.\n\n\nREFERENCE IMPLEMENTATION\ncross for float3 vectors could be implemented this way:\nfloat3 cross(float3 a, float3 b)\n{\nreturn a.yzx * b.zxy - a.zxy * b.yzx;\n}\n\n\nPROFILE SUPPORT\ncross is supported in all profiles.\nSupport in the fp20 is limited.\n\n\nSEE ALSO\ndot\n' )
end

function cg_cross_2:new()
	Node.new(self)
	self.name = 'cross'
	self.in_a = self.add_port(Input('a'))
	self.in_b = self.add_port(Input('b'))
	self.out = self.add_port(Output('out'))
end

function cg_cross_2:get_type(port)

	local type_a = self.in_a.get_output().get_type()
	local type_b = self.in_b.get_output().get_type()
	if ((type_a == 'float3')
	and (type_b == 'float3')) then
		return 'float3'
	end
	if ((type_a == 'half3')
	and (type_b == 'half3')) then
		return 'half3'
	end
	if ((type_a == 'fixed3')
	and (type_b == 'fixed3')) then
		return 'fixed3'
	end
	return nil
end

function cg_cross_2:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_cross_2:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_a = 'r' .. self.in_a.get_output().hex()
	local in_b = 'r' .. self.in_b.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = cross( ' .. in_a.. ', ' .. in_b.. ' );\n')
end

function cg_cross_2:get_tip(out)
	out.write( 'cross - returns the cross product of two three-component vectors ' )
end

-- #################################################### --
-- ddx( a )
-- #################################################### --
local cg_ddx_1 = class(Node)
function cg_ddx_1:get_help(out)
	out.write( '\n\nNAME\nddx - returns approximate partial derivative with respect to window-space X\n\n\nSYNOPSIS\nfloat ddx(float a);\nfloat1 ddx(float1 a);\nfloat2 ddx(float2 a);\nfloat3 ddx(float3 a);\nfloat4 ddx(float4 a);\nhalf ddx(half a);\nhalf1 ddx(half1 a);\nhalf2 ddx(half2 a);\nhalf3 ddx(half3 a);\nhalf4 ddx(half4 a);\nfixed ddx(fixed a);\nfixed1 ddx(fixed1 a);\nfixed2 ddx(fixed2 a);\nfixed3 ddx(fixed3 a);\nfixed4 ddx(fixed4 a);\n\n\nPARAMETERS\na Vector or scalar of which to approximate the partial derivative with respect to window-space X.\n\n\nDESCRIPTION\nReturns approximate partial derivative of a with respect to the window-space (horizontal) x coordinate.\nFor vectors, the returned vector contains the approximate partial derivative of each element of the input\nvector.\nThis function is only available in fragment program profiles (but not all of them).\nThe specific way the partial derivative is computed is implementation-dependent. Typically fragments are\nrasterized in 2x2 arrangements of fragments (called quad-fragments) and the partial derivatives of a\nvariable is computed by differencing with the adjacent horizontal fragment in the quad-fragment.\nThe partial derivative computation may incorrect when ddx is used in control flow paths where not all the\nfragments within a quad-fragment have branched the same way.\nThe partial derivative computation may be less exact (wobbly) when the variable is computed based on\nvarying parameters interpolated with centroid interpolation.\n\n\nREFERENCE IMPLEMENTATION\nddx is not expressible in Cg code.\n\n\nPROFILE SUPPORT\nddx is supported only in fragment profiles. Vertex and geometry profiles lack the concept of window\nspace.\nddx is unsupported in the fp20, ps_1_1, ps_1_2, ps_1_3, and arbfp1 profiles.\n\n\nSEE ALSO\nddy, fp30, fp40, fwidth, gp4fp\n' )
end

function cg_ddx_1:new()
	Node.new(self)
	self.name = 'ddx'
	self.in_a = self.add_port(Input('a'))
	self.out = self.add_port(Output('out'))
end

function cg_ddx_1:get_type(port)

	local type_a = self.in_a.get_output().get_type()
	if ((type_a == 'float')) then
		return 'float'
	end
	if ((type_a == 'float1')) then
		return 'float1'
	end
	if ((type_a == 'float2')) then
		return 'float2'
	end
	if ((type_a == 'float3')) then
		return 'float3'
	end
	if ((type_a == 'float4')) then
		return 'float4'
	end
	if ((type_a == 'half')) then
		return 'half'
	end
	if ((type_a == 'half1')) then
		return 'half1'
	end
	if ((type_a == 'half2')) then
		return 'half2'
	end
	if ((type_a == 'half3')) then
		return 'half3'
	end
	if ((type_a == 'half4')) then
		return 'half4'
	end
	if ((type_a == 'fixed')) then
		return 'fixed'
	end
	if ((type_a == 'fixed1')) then
		return 'fixed1'
	end
	if ((type_a == 'fixed2')) then
		return 'fixed2'
	end
	if ((type_a == 'fixed3')) then
		return 'fixed3'
	end
	if ((type_a == 'fixed4')) then
		return 'fixed4'
	end
	return nil
end

function cg_ddx_1:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_ddx_1:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_a = 'r' .. self.in_a.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = ddx( ' .. in_a.. ' );\n')
end

function cg_ddx_1:get_tip(out)
	out.write( 'ddx - returns approximate partial derivative with respect to window-space X ' )
end

-- #################################################### --
-- ddy( a )
-- #################################################### --
local cg_ddy_1 = class(Node)
function cg_ddy_1:get_help(out)
	out.write( '\n\nNAME\nddy - returns approximate partial derivative with respect to window-space Y\n\n\nSYNOPSIS\nfloat ddy(float a);\nfloat1 ddy(float1 a);\nfloat2 ddy(float2 a);\nfloat3 ddy(float3 a);\nfloat4 ddy(float4 a);\nhalf ddy(half a);\nhalf1 ddy(half1 a);\nhalf2 ddy(half2 a);\nhalf3 ddy(half3 a);\nhalf4 ddy(half4 a);\nfixed ddy(fixed a);\nfixed1 ddy(fixed1 a);\nfixed2 ddy(fixed2 a);\nfixed3 ddy(fixed3 a);\nfixed4 ddy(fixed4 a);\n\n\nPARAMETERS\na Vector or scalar of which to approximate the partial derivative with respect to window-space Y.\n\n\nDESCRIPTION\nReturns approximate partial derivative of a with respect to the window-space (vertical) y coordinate.\nFor vectors, the returned vector contains the approximate partial derivative of each element of the input\nvector.\nThis function is only available in fragment program profiles (but not all of them).\nThe specific way the partial derivative is computed is implementation-dependent. Typically fragments are\nrasterized in 2x2 arrangements of fragments (called quad-fragments) and the partial derivatives of a\nvariable is computed by differencing with the adjacent horizontal fragment in the quad-fragment.\nThe partial derivative computation may incorrect when ddy is used in control flow paths where not all the\nfragments within a quad-fragment have branched the same way.\nThe partial derivative computation may be less exact (wobbly) when the variable is computed based on\nvarying parameters interpolated with centroid interpolation.\n\n\nREFERENCE IMPLEMENTATION\nddy is not expressible in Cg code.\n\n\nPROFILE SUPPORT\nddy is supported only in fragment profiles. Vertex and geometry profiles lack the concept of window\nspace.\nddy is unsupported in the fp20, ps_1_1, ps_1_2, ps_1_3, and arbfp1 profiles.\n\n\nSEE ALSO\nddx, fp30, fp40, fwidth, gp4fp\n' )
end

function cg_ddy_1:new()
	Node.new(self)
	self.name = 'ddy'
	self.in_a = self.add_port(Input('a'))
	self.out = self.add_port(Output('out'))
end

function cg_ddy_1:get_type(port)

	local type_a = self.in_a.get_output().get_type()
	if ((type_a == 'float')) then
		return 'float'
	end
	if ((type_a == 'float1')) then
		return 'float1'
	end
	if ((type_a == 'float2')) then
		return 'float2'
	end
	if ((type_a == 'float3')) then
		return 'float3'
	end
	if ((type_a == 'float4')) then
		return 'float4'
	end
	if ((type_a == 'half')) then
		return 'half'
	end
	if ((type_a == 'half1')) then
		return 'half1'
	end
	if ((type_a == 'half2')) then
		return 'half2'
	end
	if ((type_a == 'half3')) then
		return 'half3'
	end
	if ((type_a == 'half4')) then
		return 'half4'
	end
	if ((type_a == 'fixed')) then
		return 'fixed'
	end
	if ((type_a == 'fixed1')) then
		return 'fixed1'
	end
	if ((type_a == 'fixed2')) then
		return 'fixed2'
	end
	if ((type_a == 'fixed3')) then
		return 'fixed3'
	end
	if ((type_a == 'fixed4')) then
		return 'fixed4'
	end
	return nil
end

function cg_ddy_1:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_ddy_1:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_a = 'r' .. self.in_a.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = ddy( ' .. in_a.. ' );\n')
end

function cg_ddy_1:get_tip(out)
	out.write( 'ddy - returns approximate partial derivative with respect to window-space Y ' )
end

-- #################################################### --
-- degrees( a )
-- #################################################### --
local cg_degrees_1 = class(Node)
function cg_degrees_1:get_help(out)
	out.write( '\n\nNAME\ndegrees - converts values of scalars and vectors from radians to degrees\n\n\nSYNOPSIS\nfloat degrees(float a);\nfloat1 degrees(float1 a);\nfloat2 degrees(float2 a);\nfloat3 degrees(float3 a);\nfloat4 degrees(float4 a);\nhalf degrees(half a);\nhalf1 degrees(half1 a);\nhalf2 degrees(half2 a);\nhalf3 degrees(half3 a);\nhalf4 degrees(half4 a);\nfixed degrees(fixed a);\nfixed1 degrees(fixed1 a);\nfixed2 degrees(fixed2 a);\nfixed3 degrees(fixed3 a);\nfixed4 degrees(fixed4 a);\n\n\nPARAMETERS\na Vector or scalar of which to convert from radians to degrees.\n\n\nDESCRIPTION\nReturns the scalar or vector converted from radians to degrees.\nFor vectors, the returned vector contains each element of the input vector converted from radians to\ndegrees.\n\n\nREFERENCE IMPLEMENTATION\ndegrees for a float scalar could be implemented like this.\nfloat degrees(float a)\n{\nreturn 57.29577951 * a;\n}\n\n\nPROFILE SUPPORT\ndegrees is supported in all profiles except fp20.\n\n\nSEE ALSO\ncos, radians, sin, tan\n' )
end

function cg_degrees_1:new()
	Node.new(self)
	self.name = 'degrees'
	self.in_a = self.add_port(Input('a'))
	self.out = self.add_port(Output('out'))
end

function cg_degrees_1:get_type(port)

	local type_a = self.in_a.get_output().get_type()
	if ((type_a == 'float')) then
		return 'float'
	end
	if ((type_a == 'float1')) then
		return 'float1'
	end
	if ((type_a == 'float2')) then
		return 'float2'
	end
	if ((type_a == 'float3')) then
		return 'float3'
	end
	if ((type_a == 'float4')) then
		return 'float4'
	end
	if ((type_a == 'half')) then
		return 'half'
	end
	if ((type_a == 'half1')) then
		return 'half1'
	end
	if ((type_a == 'half2')) then
		return 'half2'
	end
	if ((type_a == 'half3')) then
		return 'half3'
	end
	if ((type_a == 'half4')) then
		return 'half4'
	end
	if ((type_a == 'fixed')) then
		return 'fixed'
	end
	if ((type_a == 'fixed1')) then
		return 'fixed1'
	end
	if ((type_a == 'fixed2')) then
		return 'fixed2'
	end
	if ((type_a == 'fixed3')) then
		return 'fixed3'
	end
	if ((type_a == 'fixed4')) then
		return 'fixed4'
	end
	return nil
end

function cg_degrees_1:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_degrees_1:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_a = 'r' .. self.in_a.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = degrees( ' .. in_a.. ' );\n')
end

function cg_degrees_1:get_tip(out)
	out.write( 'degrees - converts values of scalars and vectors from radians to degrees ' )
end

-- #################################################### --
-- determinant( A )
-- #################################################### --
local cg_determinant_1 = class(Node)
function cg_determinant_1:get_help(out)
	out.write( '\n\nNAME\ndeterminant - returns the scalar determinant of a square matrix\n\n\nSYNOPSIS\nfloat determinant(float1x1 A);\nfloat determinant(float2x2 A);\nfloat determinant(float3x3 A);\nfloat determinant(float4x4 A);\n\n\nPARAMETERS\nA Square matrix of which to compute the determinant.\n\n\nDESCRIPTION\nReturns the determinant of the square matrix A.\n\n\nREFERENCE IMPLEMENTATION\nThe various determinant functions can be implemented like this:\nfloat determinant(float1x1 A)\n{\nreturn A._m00;\n}\nfloat determinant(float2x2 A)\n{\nreturn A._m00*A._m11 - A._m01*A._m10;\n}\nfloat determinant(float3x3 A)\n{\nreturn dot(A._m00_m01_m02,\nA._m11_m12_m10 * A._m22_m20_m21\n- A._m12_m10_m11 * A._m21_m22_m20);\n}\nfloat determinant(float4x4 A) {\nreturn dot(float4(1,-1,1,-1) * A._m00_m01_m02_m03,\nA._m11_m12_m13_m10*( A._m22_m23_m20_m21*A._m33_m30_m31_m32\n- A._m23_m20_m21_m22*A._m32_m33_m30_m31)\n+ A._m12_m13_m10_m11*( A._m23_m20_m21_m22*A._m31_m32_m33_m30\n- A._m21_m22_m23_m20*A._m33_m30_m31_m32)\n+ A._m13_m10_m11_m12*( A._m21_m22_m23_m20*A._m32_m33_m30_m31\n- A._m22_m23_m20_m21*A._m31_m32_m33_m30));\n}\n\n\nPROFILE SUPPORT\ndeterminant is supported in all profiles. However profiles such as fp20 and ps_2 without native floatingpoint\nwill have problems computing the larger determinants and may have ranges issues computing even\nsmall determinants.\n\n\nSEE ALSO\nmul, transpose\n' )
end

function cg_determinant_1:new()
	Node.new(self)
	self.name = 'determinant'
	self.in_A = self.add_port(Input('A'))
	self.out = self.add_port(Output('out'))
end

function cg_determinant_1:get_type(port)

	local type_A = self.in_A.get_output().get_type()
	if ((type_A == 'float1x1')) then
		return 'float'
	end
	if ((type_A == 'float2x2')) then
		return 'float'
	end
	if ((type_A == 'float3x3')) then
		return 'float'
	end
	if ((type_A == 'float4x4')) then
		return 'float'
	end
	return nil
end

function cg_determinant_1:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_determinant_1:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_A = 'r' .. self.in_A.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = determinant( ' .. in_A.. ' );\n')
end

function cg_determinant_1:get_tip(out)
	out.write( 'determinant - returns the scalar determinant of a square matrix ' )
end

-- #################################################### --
-- dot( a, b )
-- #################################################### --
local cg_dot_2 = class(Node)
function cg_dot_2:get_help(out)
	out.write( '\n\nNAME\ndot - returns the scalar dot product of two vectors\n\n\nSYNOPSIS\nfloat dot(float a, float b);\nfloat dot(float1 a, float1 b);\nfloat dot(float2 a, float2 b);\nfloat dot(float3 a, float3 b);\nfloat dot(float4 a, float4 b);\nhalf dot(half a, half b);\nhalf dot(half1 a, half1 b);\nhalf dot(half2 a, half2 b);\nhalf dot(half3 a, half3 b);\nhalf dot(half4 a, half4 b);\nfixed dot(fixed a, fixed b);\nfixed dot(fixed1 a, fixed1 b);\nfixed dot(fixed2 a, fixed2 b);\nfixed dot(fixed3 a, fixed3 b);\nfixed dot(fixed4 a, fixed4 b);\n\n\nPARAMETERS\na First vector.\nb Second vector.\n\n\nDESCRIPTION\nReturns the scalar dot product of two same-typed vectors a and b.\n\n\nREFERENCE IMPLEMENTATION\ndot for float4 vectors could be implemented this way:\nfloat dot(float4 a, float4 b)\n{\nreturn a.x*b.x + a.y*b.y + a.z*b.z + a.w*b.w;\n}\n\n\nPROFILE SUPPORT\ndot is supported in all profiles.\nThe fifixed3 dot product is very efficient in the fp20 and fp30 profiles.\nThe float3 and float4 dot products are very efficient in the vp20, vp30, vp40, arbvp1, fp30, fp40, and\narbfp1 profiles.\nThe float2 dot product is very efficient in the fp40 profile. In optimal circumstances, two two-component\ndot products can sometimes be performed at the four-component and three-component dot product rate.\n\n\nSEE ALSO\ncross, mul\n' )
end

function cg_dot_2:new()
	Node.new(self)
	self.name = 'dot'
	self.in_a = self.add_port(Input('a'))
	self.in_b = self.add_port(Input('b'))
	self.out = self.add_port(Output('out'))
end

function cg_dot_2:get_type(port)

	local type_a = self.in_a.get_output().get_type()
	local type_b = self.in_b.get_output().get_type()
	if ((type_a == 'float')
	and (type_b == 'float')) then
		return 'float'
	end
	if ((type_a == 'float1')
	and (type_b == 'float1')) then
		return 'float'
	end
	if ((type_a == 'float2')
	and (type_b == 'float2')) then
		return 'float'
	end
	if ((type_a == 'float3')
	and (type_b == 'float3')) then
		return 'float'
	end
	if ((type_a == 'float4')
	and (type_b == 'float4')) then
		return 'float'
	end
	if ((type_a == 'half')
	and (type_b == 'half')) then
		return 'half'
	end
	if ((type_a == 'half1')
	and (type_b == 'half1')) then
		return 'half'
	end
	if ((type_a == 'half2')
	and (type_b == 'half2')) then
		return 'half'
	end
	if ((type_a == 'half3')
	and (type_b == 'half3')) then
		return 'half'
	end
	if ((type_a == 'half4')
	and (type_b == 'half4')) then
		return 'half'
	end
	if ((type_a == 'fixed')
	and (type_b == 'fixed')) then
		return 'fixed'
	end
	if ((type_a == 'fixed1')
	and (type_b == 'fixed1')) then
		return 'fixed'
	end
	if ((type_a == 'fixed2')
	and (type_b == 'fixed2')) then
		return 'fixed'
	end
	if ((type_a == 'fixed3')
	and (type_b == 'fixed3')) then
		return 'fixed'
	end
	if ((type_a == 'fixed4')
	and (type_b == 'fixed4')) then
		return 'fixed'
	end
	return nil
end

function cg_dot_2:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_dot_2:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_a = 'r' .. self.in_a.get_output().hex()
	local in_b = 'r' .. self.in_b.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = dot( ' .. in_a.. ', ' .. in_b.. ' );\n')
end

function cg_dot_2:get_tip(out)
	out.write( 'dot - returns the scalar dot product of two vectors ' )
end

-- #################################################### --
-- exp( a )
-- #################################################### --
local cg_exp_1 = class(Node)
function cg_exp_1:get_help(out)
	out.write( '\n\nNAME\nexp - returns the base-e exponential of scalars and vectors\n\n\nSYNOPSIS\nfloat exp(float a);\nfloat1 exp(float1 a);\nfloat2 exp(float2 a);\nfloat3 exp(float3 a);\nfloat4 exp(float4 a);\nhalf exp(half a);\nhalf1 exp(half1 a);\nhalf2 exp(half2 a);\nhalf3 exp(half3 a);\nhalf4 exp(half4 a);\nfixed exp(fixed a);\nfixed1 exp(fixed1 a);\nfixed2 exp(fixed2 a);\nfixed3 exp(fixed3 a);\nfixed4 exp(fixed4 a);\n\n\nPARAMETERS\na Vector or scalar of which to determine the base-e exponential. The value e is approximately\n2.71828182845904523536.\n\n\nDESCRIPTION\nReturns the base-e exponential a.\nFor vectors, the returned vector contains the base-e exponential of each element of the input vector.\n\n\nREFERENCE IMPLEMENTATION\nfloat3 exp(float3 a)\n{\nfloat3 rv;\nint i;\nfor (i=0; i<3; i++) {\nrv[i] = exp(a[i]); // this is the ANSI C standard library exp()\n}\nreturn rv;\n}\nexp is typically implemented with either a native base-2 exponentional instruction or pow.\n\n\nPROFILE SUPPORT\nexp is fully supported in all profiles unless otherwise specified.\nSupport in the fp20 is limited to constant compile-time evaluation.\n\n\nSEE ALSO\nexp2, log, pow\n' )
end

function cg_exp_1:new()
	Node.new(self)
	self.name = 'exp'
	self.in_a = self.add_port(Input('a'))
	self.out = self.add_port(Output('out'))
end

function cg_exp_1:get_type(port)

	local type_a = self.in_a.get_output().get_type()
	if ((type_a == 'float')) then
		return 'float'
	end
	if ((type_a == 'float1')) then
		return 'float1'
	end
	if ((type_a == 'float2')) then
		return 'float2'
	end
	if ((type_a == 'float3')) then
		return 'float3'
	end
	if ((type_a == 'float4')) then
		return 'float4'
	end
	if ((type_a == 'half')) then
		return 'half'
	end
	if ((type_a == 'half1')) then
		return 'half1'
	end
	if ((type_a == 'half2')) then
		return 'half2'
	end
	if ((type_a == 'half3')) then
		return 'half3'
	end
	if ((type_a == 'half4')) then
		return 'half4'
	end
	if ((type_a == 'fixed')) then
		return 'fixed'
	end
	if ((type_a == 'fixed1')) then
		return 'fixed1'
	end
	if ((type_a == 'fixed2')) then
		return 'fixed2'
	end
	if ((type_a == 'fixed3')) then
		return 'fixed3'
	end
	if ((type_a == 'fixed4')) then
		return 'fixed4'
	end
	return nil
end

function cg_exp_1:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_exp_1:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_a = 'r' .. self.in_a.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = exp( ' .. in_a.. ' );\n')
end

function cg_exp_1:get_tip(out)
	out.write( 'exp - returns the base-e exponential of scalars and vectors ' )
end

-- #################################################### --
-- exp2( a )
-- #################################################### --
local cg_exp2_1 = class(Node)
function cg_exp2_1:get_help(out)
	out.write( '\n\nNAME\nexp2 - returns the base-2 exponential of scalars and vectors\n\n\nSYNOPSIS\nfloat exp2(float a);\nfloat1 exp2(float1 a);\nfloat2 exp2(float2 a);\nfloat3 exp2(float3 a);\nfloat4 exp2(float4 a);\nhalf exp2(half a);\nhalf1 exp2(half1 a);\nhalf2 exp2(half2 a);\nhalf3 exp2(half3 a);\nhalf4 exp2(half4 a);\nfixed exp2(fixed a);\nfixed1 exp2(fixed1 a);\nfixed2 exp2(fixed2 a);\nfixed3 exp2(fixed3 a);\nfixed4 exp2(fixed4 a);\n\n\nPARAMETERS\na Vector or scalar of which to determine the base-2 exponential.\n\n\nDESCRIPTION\nReturns the base-2 exponential a.\nFor vectors, the returned vector contains the base-2 exponential of each element of the input vector.\n\n\nREFERENCE IMPLEMENTATION\nfloat3 exp2(float3 a)\n{\nfloat3 rv;\nint i;\nfor (i=0; i<3; i++) {\nrv[i] = exp2(a[i]); // this is the ANSI C standard library exp2()\n}\nreturn rv;\n}\nexp2 is typically implemented with a native base-2 exponentional instruction.\n\n\nPROFILE SUPPORT\nexp2 is fully supported in all profiles unless otherwise specified.\nSupport in the fp20 is limited to constant compile-time evaluation.\n\n\nSEE ALSO\nexp, log, pow\n' )
end

function cg_exp2_1:new()
	Node.new(self)
	self.name = 'exp2'
	self.in_a = self.add_port(Input('a'))
	self.out = self.add_port(Output('out'))
end

function cg_exp2_1:get_type(port)

	local type_a = self.in_a.get_output().get_type()
	if ((type_a == 'float')) then
		return 'float'
	end
	if ((type_a == 'float1')) then
		return 'float1'
	end
	if ((type_a == 'float2')) then
		return 'float2'
	end
	if ((type_a == 'float3')) then
		return 'float3'
	end
	if ((type_a == 'float4')) then
		return 'float4'
	end
	if ((type_a == 'half')) then
		return 'half'
	end
	if ((type_a == 'half1')) then
		return 'half1'
	end
	if ((type_a == 'half2')) then
		return 'half2'
	end
	if ((type_a == 'half3')) then
		return 'half3'
	end
	if ((type_a == 'half4')) then
		return 'half4'
	end
	if ((type_a == 'fixed')) then
		return 'fixed'
	end
	if ((type_a == 'fixed1')) then
		return 'fixed1'
	end
	if ((type_a == 'fixed2')) then
		return 'fixed2'
	end
	if ((type_a == 'fixed3')) then
		return 'fixed3'
	end
	if ((type_a == 'fixed4')) then
		return 'fixed4'
	end
	return nil
end

function cg_exp2_1:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_exp2_1:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_a = 'r' .. self.in_a.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = exp2( ' .. in_a.. ' );\n')
end

function cg_exp2_1:get_tip(out)
	out.write( 'exp2 - returns the base-2 exponential of scalars and vectors ' )
end

-- #################################################### --
-- faceforward( N, I, Ng )
-- #################################################### --
local cg_faceforward_3 = class(Node)
function cg_faceforward_3:get_help(out)
	out.write( '\n\nNAME\nfaceforward - returns a normal as-is if a vertexs eye-space position vector points in the opposite direction\nof a geometric normal, otherwise return the negated version of the normal\n\n\nSYNOPSIS\nfloat faceforward(float N, float I, float Ng);\nfloat1 faceforward(float1 N, float1 I, float1 Ng);\nfloat2 faceforward(float2 N, float2 I, float2 Ng);\nfloat3 faceforward(float3 N, float3 I, float3 Ng);\nfloat4 faceforward(float4 N, float4 I, float4 Ng);\nhalf faceforward(half N, half I, half Ng);\nhalf1 faceforward(half1 N, half1 I, half1 Ng);\nhalf2 faceforward(half2 N, half2 I, half2 Ng);\nhalf3 faceforward(half3 N, half3 I, half3 Ng);\nhalf4 faceforward(half4 N, half4 I, half4 Ng);\nfixed faceforward(fixed N, fixed I, fixed Ng);\nfixed1 faceforward(fixed1 N, fixed1 I, fixed1 Ng);\nfixed2 faceforward(fixed2 N, fixed2 I, fixed2 Ng);\nfixed3 faceforward(fixed3 N, fixed3 I, fixed3 Ng);\nfixed4 faceforward(fixed4 N, fixed4 I, fixed4 Ng);\n\n\nPARAMETERS\nN Peturbed normal vector.\nI Incidence vector (typically a direction vector from the eye to a vertex).\nNg Geometric normal vector (for some facet the peturbed normal belongs).\n\n\nDESCRIPTION\nReturns a (peturbed) normal as-is if a vertexs eye-space position vector points in the opposite direction of a\ngeometric normal, otherwise return the negated version of the (peturbed) normal\nMathematically, if the dot product of I and Ng is negative, N is returned unchanged; otherwise -N is\nreturned.\nThis function is inspired by a RenderMan funciton of the same name though the RenderMan version has\nonly two parameters.\n\n\nREFERENCE IMPLEMENTATION\nfaceforward for float3 vectors could be implemented this way:\nfloat3 faceforward( float3 N, float3 I, float Ng )\n{\nreturn dot(I, Ng) < 0 ? N : -N;\n}\n\n\nPROFILE SUPPORT\nrefract is supported in all profiles.\n\n\nSEE ALSO\ndot, reflect, refract, normalize\n' )
end

function cg_faceforward_3:new()
	Node.new(self)
	self.name = 'faceforward'
	self.in_N = self.add_port(Input('N'))
	self.in_I = self.add_port(Input('I'))
	self.in_Ng = self.add_port(Input('Ng'))
	self.out = self.add_port(Output('out'))
end

function cg_faceforward_3:get_type(port)

	local type_N = self.in_N.get_output().get_type()
	local type_I = self.in_I.get_output().get_type()
	local type_Ng = self.in_Ng.get_output().get_type()
	if ((type_N == 'float')
	and (type_I == 'float')
	and (type_Ng == 'float')) then
		return 'float'
	end
	if ((type_N == 'float1')
	and (type_I == 'float1')
	and (type_Ng == 'float1')) then
		return 'float1'
	end
	if ((type_N == 'float2')
	and (type_I == 'float2')
	and (type_Ng == 'float2')) then
		return 'float2'
	end
	if ((type_N == 'float3')
	and (type_I == 'float3')
	and (type_Ng == 'float3')) then
		return 'float3'
	end
	if ((type_N == 'float4')
	and (type_I == 'float4')
	and (type_Ng == 'float4')) then
		return 'float4'
	end
	if ((type_N == 'half')
	and (type_I == 'half')
	and (type_Ng == 'half')) then
		return 'half'
	end
	if ((type_N == 'half1')
	and (type_I == 'half1')
	and (type_Ng == 'half1')) then
		return 'half1'
	end
	if ((type_N == 'half2')
	and (type_I == 'half2')
	and (type_Ng == 'half2')) then
		return 'half2'
	end
	if ((type_N == 'half3')
	and (type_I == 'half3')
	and (type_Ng == 'half3')) then
		return 'half3'
	end
	if ((type_N == 'half4')
	and (type_I == 'half4')
	and (type_Ng == 'half4')) then
		return 'half4'
	end
	if ((type_N == 'fixed')
	and (type_I == 'fixed')
	and (type_Ng == 'fixed')) then
		return 'fixed'
	end
	if ((type_N == 'fixed1')
	and (type_I == 'fixed1')
	and (type_Ng == 'fixed1')) then
		return 'fixed1'
	end
	if ((type_N == 'fixed2')
	and (type_I == 'fixed2')
	and (type_Ng == 'fixed2')) then
		return 'fixed2'
	end
	if ((type_N == 'fixed3')
	and (type_I == 'fixed3')
	and (type_Ng == 'fixed3')) then
		return 'fixed3'
	end
	if ((type_N == 'fixed4')
	and (type_I == 'fixed4')
	and (type_Ng == 'fixed4')) then
		return 'fixed4'
	end
	return nil
end

function cg_faceforward_3:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_faceforward_3:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_N = 'r' .. self.in_N.get_output().hex()
	local in_I = 'r' .. self.in_I.get_output().hex()
	local in_Ng = 'r' .. self.in_Ng.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = faceforward( ' .. in_N.. ', ' .. in_I.. ', ' .. in_Ng.. ' );\n')
end

function cg_faceforward_3:get_tip(out)
	out.write( 'faceforward - returns a normal as-is if a vertexs eye-space position vector points in the opposite direction of a geometric normal, otherwise return the negated version of the normal ' )
end

-- #################################################### --
-- floatToIntBits( x )
-- #################################################### --
local cg_floatToIntBits_1 = class(Node)
function cg_floatToIntBits_1:get_help(out)
	out.write( '\n\nNAME\nfloatToIntBits - returns the 32-bit integer representation of an IEEE 754 floating-point scalar or vector\n\n\nSYNOPSIS\nint floatToIntBits(float x);\nint1 floatToIntBits(float1 x);\nint2 floatToIntBits(float2 x);\nint3 floatToIntBits(float3 x);\nint4 floatToIntBits(float4 x);\n\n\nPARAMETERS\nx Floating-point vector or scalar to cast to a scalar int or vector of ints.\n\n\nDESCRIPTION\nReturns a representation of the specified floating-point scalar value or vector values according to the IEEE\n754 floating-point single format bit layout.\nNot-A-Number (NaN) floating-point values are cannonicalized to the integer value 0x7fc00000 regardless\nof the specific NaN encoding. The sign bit of the NaN is discarded.\nThis function is based on Javas jave.lang.Float method of the same name. See:\nhttp://java.sun.com/j2se/1.4.2/docs/api/java/lang/Float.html\nfloatToIntBits requires instructions to be generated to cannonicalize NaN values so floatToIntBits is\ntypically more expensive than floatToRawIntBits.\n\n\nREFERENCE IMPLEMENTATION\nfloatToIntBits operates consistent with the following ANSI C code:\nint floatToIntBits(float x)\n{\nunion {\nfloat f; // assuming 32-bit IEEE 754 single-precision\nint i; // assuming 32-bit 2s complement int\n} u;\nif (isnan(x)) {\nreturn 0x7fc00000;\n} else {\nu.f = x;\nreturn u.i;\n}\n}\n\n\nPROFILE SUPPORT\nfloatToIntBits is supported by the gp4vp, gp4gp, and gp4vp profiles.\nfloatToIntBits is not supported by pre-G80 profiles.\n\n\nSEE ALSO\nceil, floatToRawIntBits, floor, intBitsToFloat, round, trunc\n' )
end

function cg_floatToIntBits_1:new()
	Node.new(self)
	self.name = 'floatToIntBits'
	self.in_x = self.add_port(Input('x'))
	self.out = self.add_port(Output('out'))
end

function cg_floatToIntBits_1:get_type(port)

	local type_x = self.in_x.get_output().get_type()
	if ((type_x == 'float')) then
		return 'int'
	end
	if ((type_x == 'float1')) then
		return 'int1'
	end
	if ((type_x == 'float2')) then
		return 'int2'
	end
	if ((type_x == 'float3')) then
		return 'int3'
	end
	if ((type_x == 'float4')) then
		return 'int4'
	end
	return nil
end

function cg_floatToIntBits_1:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_floatToIntBits_1:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_x = 'r' .. self.in_x.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = floatToIntBits( ' .. in_x.. ' );\n')
end

function cg_floatToIntBits_1:get_tip(out)
	out.write( 'floatToIntBits - returns the 32-bit integer representation of an IEEE 754 floating-point scalar or vector ' )
end

-- #################################################### --
-- floatToRawIntBits( x )
-- #################################################### --
local cg_floatToRawIntBits_1 = class(Node)
function cg_floatToRawIntBits_1:get_help(out)
	out.write( '\n\nNAME\nfloatToRawIntBits - returns the raw 32-bit integer representation of an IEEE 754 floating-point scalar or\nvector\n\n\nSYNOPSIS\nint floatToRawIntBits(float x);\nint1 floatToRawIntBits(float1 x);\nint2 floatToRawIntBits(float2 x);\nint3 floatToRawIntBits(float3 x);\nint4 floatToRawIntBits(float4 x);\n\n\nPARAMETERS\nx Floating-point vector or scalar to raw cast to a scalar int or vector of ints.\n\n\nDESCRIPTION\nReturns a representation of the specified floating-point scalar value or vector values according to the IEEE\n754 floating-point single format bit layout, preserving Not-a-Number (NaN) values.\nThis function is based on Javas jave.lang.Float method of the same name. See:\nhttp://java.sun.com/j2se/1.4.2/docs/api/java/lang/Float.html\nThe Cg compiler can typically optimize floatToRawIntBits so it has no instruction cost.\n\n\nREFERENCE IMPLEMENTATION\nfloatToRawIntBits operates consistent with the following ANSI C code:\nint floatToRawIntBits(float x)\n{\nunion {\nfloat f; // assuming 32-bit IEEE 754 single-precision\nint i; // assuming 32-bit 2s complement int\n} u;\nu.f = x;\nreturn u.i;\n}\n\n\nPROFILE SUPPORT\nfloatToRawIntBits is supported by the gp4vp, gp4gp, and gp4vp profiles.\nfloatToRawIntBits is not supported by pre-G80 profiles.\n\n\nSEE ALSO\nceil, floatToIntBits, floor, intBitsToFloat, round, trunc\n' )
end

function cg_floatToRawIntBits_1:new()
	Node.new(self)
	self.name = 'floatToRawIntBits'
	self.in_x = self.add_port(Input('x'))
	self.out = self.add_port(Output('out'))
end

function cg_floatToRawIntBits_1:get_type(port)

	local type_x = self.in_x.get_output().get_type()
	if ((type_x == 'float')) then
		return 'int'
	end
	if ((type_x == 'float1')) then
		return 'int1'
	end
	if ((type_x == 'float2')) then
		return 'int2'
	end
	if ((type_x == 'float3')) then
		return 'int3'
	end
	if ((type_x == 'float4')) then
		return 'int4'
	end
	return nil
end

function cg_floatToRawIntBits_1:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_floatToRawIntBits_1:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_x = 'r' .. self.in_x.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = floatToRawIntBits( ' .. in_x.. ' );\n')
end

function cg_floatToRawIntBits_1:get_tip(out)
	out.write( 'floatToRawIntBits - returns the raw 32-bit integer representation of an IEEE 754 floating-point scalar or vector ' )
end

-- #################################################### --
-- floor( a )
-- #################################################### --
local cg_floor_1 = class(Node)
function cg_floor_1:get_help(out)
	out.write( '\n\nNAME\nfloor - returns largest integer not greater than a scalar or each vector component.\n\n\nSYNOPSIS\nfloat floor(float a);\nfloat1 floor(float1 a);\nfloat2 floor(float2 a);\nfloat3 floor(float3 a);\nfloat4 floor(float4 a);\nhalf floor(half a);\nhalf1 floor(half1 a);\nhalf2 floor(half2 a);\nhalf3 floor(half3 a);\nhalf4 floor(half4 a);\nfixed floor(fixed a);\nfixed1 floor(fixed1 a);\nfixed2 floor(fixed2 a);\nfixed3 floor(fixed3 a);\nfixed4 floor(fixed4 a);\n\n\nPARAMETERS\na Vector or scalar of which to determine the floor.\n\n\nDESCRIPTION\nReturns the floor or largest integer not greater than a scalar or each vector component.\n\n\nREFERENCE IMPLEMENTATION\nfloor for a float3 vector could be implemented like this.\nfloat3 floor(float3 v)\n{\nfloat3 rv;\nint i;\nfor (i=0; i<3; i++) {\nrv[i] = v[i] - frac(v[i]);\n}\nreturn rv;\n}\n\n\nPROFILE SUPPORT\nfloor is supported in all profiles except fp20.\n\n\nSEE ALSO\nceil, round\n' )
end

function cg_floor_1:new()
	Node.new(self)
	self.name = 'floor'
	self.in_a = self.add_port(Input('a'))
	self.out = self.add_port(Output('out'))
end

function cg_floor_1:get_type(port)

	local type_a = self.in_a.get_output().get_type()
	if ((type_a == 'float')) then
		return 'float'
	end
	if ((type_a == 'float1')) then
		return 'float1'
	end
	if ((type_a == 'float2')) then
		return 'float2'
	end
	if ((type_a == 'float3')) then
		return 'float3'
	end
	if ((type_a == 'float4')) then
		return 'float4'
	end
	if ((type_a == 'half')) then
		return 'half'
	end
	if ((type_a == 'half1')) then
		return 'half1'
	end
	if ((type_a == 'half2')) then
		return 'half2'
	end
	if ((type_a == 'half3')) then
		return 'half3'
	end
	if ((type_a == 'half4')) then
		return 'half4'
	end
	if ((type_a == 'fixed')) then
		return 'fixed'
	end
	if ((type_a == 'fixed1')) then
		return 'fixed1'
	end
	if ((type_a == 'fixed2')) then
		return 'fixed2'
	end
	if ((type_a == 'fixed3')) then
		return 'fixed3'
	end
	if ((type_a == 'fixed4')) then
		return 'fixed4'
	end
	return nil
end

function cg_floor_1:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_floor_1:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_a = 'r' .. self.in_a.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = floor( ' .. in_a.. ' );\n')
end

function cg_floor_1:get_tip(out)
	out.write( 'floor - returns largest integer not greater than a scalar or each vector component. ' )
end

-- #################################################### --
-- fmod( x, y )
-- #################################################### --
local cg_fmod_2 = class(Node)
function cg_fmod_2:get_help(out)
	out.write( '\n\nNAME\nfmod - returns the remainder of x/y with the same sign as x\n\n\nSYNOPSIS\nfloat fmod(float x, float y);\nfloat1 fmod(float1 x, float1 y);\nfloat2 fmod(float2 x, float2 y);\nfloat3 fmod(float3 x, float3 y);\nfloat4 fmod(float4 x, float4 y);\nhalf fmod(half x, half y);\nhalf1 fmod(half1 x, half1 y);\nhalf2 fmod(half2 x, half2 y);\nhalf3 fmod(half3 x, half3 y);\nhalf4 fmod(half4 x, half4 y);\nfixed fmod(fixed x, fixed y);\nfixed1 fmod(fixed1 x, fixed1 y);\nfixed2 fmod(fixed2 x, fixed2 y);\nfixed3 fmod(fixed3 x, fixed3 y);\nfixed4 fmod(fixed4 x, fixed4 y);\n\n\nPARAMETERS\nx Vector or scalar numerator\ny Vector or scalar denominator\n\n\nDESCRIPTION\nfmod returns the remainder of x divided by y with the same sign as x. If y is zero, the result is\nimplementation-defined because of division by zero.\nFor vectors, the returned vector contains the signed remainder of each element of the input vector.\n\n\nREFERENCE IMPLEMENTATION\nfmod for an float2 vector could be implemented as:\nfloat2 fmod(float2 a, float2 b)\n{\nfloat2 c = frac(abs(a/b))*abs(b);\nreturn (a < 0) ? -c : c; /* if ( a < 0 ) c = 0-c */\n}\n\n\nPROFILE SUPPORT\nfmod is supported in all profiles but fp20.\n\n\nSEE ALSO\nabs, frac\n' )
end

function cg_fmod_2:new()
	Node.new(self)
	self.name = 'fmod'
	self.in_x = self.add_port(Input('x'))
	self.in_y = self.add_port(Input('y'))
	self.out = self.add_port(Output('out'))
end

function cg_fmod_2:get_type(port)

	local type_x = self.in_x.get_output().get_type()
	local type_y = self.in_y.get_output().get_type()
	if ((type_x == 'float')
	and (type_y == 'float')) then
		return 'float'
	end
	if ((type_x == 'float1')
	and (type_y == 'float1')) then
		return 'float1'
	end
	if ((type_x == 'float2')
	and (type_y == 'float2')) then
		return 'float2'
	end
	if ((type_x == 'float3')
	and (type_y == 'float3')) then
		return 'float3'
	end
	if ((type_x == 'float4')
	and (type_y == 'float4')) then
		return 'float4'
	end
	if ((type_x == 'half')
	and (type_y == 'half')) then
		return 'half'
	end
	if ((type_x == 'half1')
	and (type_y == 'half1')) then
		return 'half1'
	end
	if ((type_x == 'half2')
	and (type_y == 'half2')) then
		return 'half2'
	end
	if ((type_x == 'half3')
	and (type_y == 'half3')) then
		return 'half3'
	end
	if ((type_x == 'half4')
	and (type_y == 'half4')) then
		return 'half4'
	end
	if ((type_x == 'fixed')
	and (type_y == 'fixed')) then
		return 'fixed'
	end
	if ((type_x == 'fixed1')
	and (type_y == 'fixed1')) then
		return 'fixed1'
	end
	if ((type_x == 'fixed2')
	and (type_y == 'fixed2')) then
		return 'fixed2'
	end
	if ((type_x == 'fixed3')
	and (type_y == 'fixed3')) then
		return 'fixed3'
	end
	if ((type_x == 'fixed4')
	and (type_y == 'fixed4')) then
		return 'fixed4'
	end
	return nil
end

function cg_fmod_2:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_fmod_2:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_x = 'r' .. self.in_x.get_output().hex()
	local in_y = 'r' .. self.in_y.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = fmod( ' .. in_x.. ', ' .. in_y.. ' );\n')
end

function cg_fmod_2:get_tip(out)
	out.write( 'fmod - returns the remainder of x/y with the same sign as x ' )
end

-- #################################################### --
-- frac( a )
-- #################################################### --
local cg_frac_1 = class(Node)
function cg_frac_1:get_help(out)
	out.write( '\n\nNAME\nfrac - returns the fractional portion of a scalar or each vector component.\n\n\nSYNOPSIS\nfloat frac(float a);\nfloat1 frac(float1 a);\nfloat2 frac(float2 a);\nfloat3 frac(float3 a);\nfloat4 frac(float4 a);\nhalf frac(half a);\nhalf1 frac(half1 a);\nhalf2 frac(half2 a);\nhalf3 frac(half3 a);\nhalf4 frac(half4 a);\nfixed frac(fixed a);\nfixed1 frac(fixed1 a);\nfixed2 frac(fixed2 a);\nfixed3 frac(fixed3 a);\nfixed4 frac(fixed4 a);\n\n\nPARAMETERS\na Vector or scalar of which to return its fractional portion.\n\n\nDESCRIPTION\nReturns the fractional portion of a scalar or each vector component.\n\n\nREFERENCE IMPLEMENTATION\nfrac for a float scalar could be implemented like this.\nfloat frac(float v)\n{\nreturn v - floor(v);\n}\n\n\nPROFILE SUPPORT\nfrac is supported in all profiles except fp20.\n\n\nSEE ALSO\nceil, floor, round, trunc\n' )
end

function cg_frac_1:new()
	Node.new(self)
	self.name = 'frac'
	self.in_a = self.add_port(Input('a'))
	self.out = self.add_port(Output('out'))
end

function cg_frac_1:get_type(port)

	local type_a = self.in_a.get_output().get_type()
	if ((type_a == 'float')) then
		return 'float'
	end
	if ((type_a == 'float1')) then
		return 'float1'
	end
	if ((type_a == 'float2')) then
		return 'float2'
	end
	if ((type_a == 'float3')) then
		return 'float3'
	end
	if ((type_a == 'float4')) then
		return 'float4'
	end
	if ((type_a == 'half')) then
		return 'half'
	end
	if ((type_a == 'half1')) then
		return 'half1'
	end
	if ((type_a == 'half2')) then
		return 'half2'
	end
	if ((type_a == 'half3')) then
		return 'half3'
	end
	if ((type_a == 'half4')) then
		return 'half4'
	end
	if ((type_a == 'fixed')) then
		return 'fixed'
	end
	if ((type_a == 'fixed1')) then
		return 'fixed1'
	end
	if ((type_a == 'fixed2')) then
		return 'fixed2'
	end
	if ((type_a == 'fixed3')) then
		return 'fixed3'
	end
	if ((type_a == 'fixed4')) then
		return 'fixed4'
	end
	return nil
end

function cg_frac_1:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_frac_1:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_a = 'r' .. self.in_a.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = frac( ' .. in_a.. ' );\n')
end

function cg_frac_1:get_tip(out)
	out.write( 'frac - returns the fractional portion of a scalar or each vector component. ' )
end

-- #################################################### --
-- frexp( x, e )
-- #################################################### --
local cg_frexp_2 = class(Node)
function cg_frexp_2:get_help(out)
	out.write( '\n\nNAME\nfrexp - splits scalars and vectors into normalized fraction and a power of 2\n\n\nSYNOPSIS\nfloat frexp(float x, float e);\nfloat1 frexp(float1 x, float1 e);\nfloat2 frexp(float2 x, float2 e);\nfloat3 frexp(float3 x, float3 e);\nfloat4 frexp(float4 x, float4 e);\nhalf frexp(half x, half e);\nhalf1 frexp(half1 x, half1 e);\nhalf2 frexp(half2 x, half2 e);\nhalf3 frexp(half3 x, half3 e);\nhalf4 frexp(half4 x, half4 e);\nfixed frexp(fixed x, fixed e);\nfixed1 frexp(fixed1 x, fixed1 e);\nfixed2 frexp(fixed2 x, fixed2 e);\nfixed3 frexp(fixed3 x, fixed3 e);\nfixed4 frexp(fixed4 x, fixed4 e);\n\n\nPARAMETERS\nx Vector or scalar of which to split.\ne Vector or scalar where the exponent of x is output.\n\n\nDESCRIPTION\nThis function decomposes x into two parts: a mantissa between 0.5 and 1 (returned by the function) and an\nexponent output as e.\nIf the value x is zero, both parts of the result are zero.\nFor vectors, the returned vector contains the mantissa of each element of the input vector and the output\nvector contains the exponent of each element of the input vector.\n\n\nREFERENCE IMPLEMENTATION\nThe example below is not legal Cg because it uses the & address-of operator not supported by Cg in order\nto call the ANSI C frexp routine.\nfloat3 frexp(float3 x, out float3 e)\n{\nfloat3 rv;\nint i;\nfor (i=0; i<3; i++) {\nfloat eout;\nrv[i] = frexp(a[i], &eout); // this is the ANSI C standard library frexp()\ne[i] = eout;\n}\nreturn rv;\n}\n\n\nPROFILE SUPPORT\nfrexp is fully supported in all profiles unless otherwise specified.\nSupport in the fp20 is limited to constant compile-time evaluation.\n\n\nSEE ALSO\nexp2, log, pow\n' )
end

function cg_frexp_2:new()
	Node.new(self)
	self.name = 'frexp'
	self.in_x = self.add_port(Input('x'))
	self.in_e = self.add_port(Input('e'))
	self.out = self.add_port(Output('out'))
end

function cg_frexp_2:get_type(port)

	local type_x = self.in_x.get_output().get_type()
	local type_e = self.in_e.get_output().get_type()
	if ((type_x == 'float')
	and (type_e == 'float')) then
		return 'float'
	end
	if ((type_x == 'float1')
	and (type_e == 'float1')) then
		return 'float1'
	end
	if ((type_x == 'float2')
	and (type_e == 'float2')) then
		return 'float2'
	end
	if ((type_x == 'float3')
	and (type_e == 'float3')) then
		return 'float3'
	end
	if ((type_x == 'float4')
	and (type_e == 'float4')) then
		return 'float4'
	end
	if ((type_x == 'half')
	and (type_e == 'half')) then
		return 'half'
	end
	if ((type_x == 'half1')
	and (type_e == 'half1')) then
		return 'half1'
	end
	if ((type_x == 'half2')
	and (type_e == 'half2')) then
		return 'half2'
	end
	if ((type_x == 'half3')
	and (type_e == 'half3')) then
		return 'half3'
	end
	if ((type_x == 'half4')
	and (type_e == 'half4')) then
		return 'half4'
	end
	if ((type_x == 'fixed')
	and (type_e == 'fixed')) then
		return 'fixed'
	end
	if ((type_x == 'fixed1')
	and (type_e == 'fixed1')) then
		return 'fixed1'
	end
	if ((type_x == 'fixed2')
	and (type_e == 'fixed2')) then
		return 'fixed2'
	end
	if ((type_x == 'fixed3')
	and (type_e == 'fixed3')) then
		return 'fixed3'
	end
	if ((type_x == 'fixed4')
	and (type_e == 'fixed4')) then
		return 'fixed4'
	end
	return nil
end

function cg_frexp_2:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_frexp_2:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_x = 'r' .. self.in_x.get_output().hex()
	local in_e = 'r' .. self.in_e.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = frexp( ' .. in_x.. ', ' .. in_e.. ' );\n')
end

function cg_frexp_2:get_tip(out)
	out.write( 'frexp - splits scalars and vectors into normalized fraction and a power of 2 ' )
end

-- #################################################### --
-- fwidth( a )
-- #################################################### --
local cg_fwidth_1 = class(Node)
function cg_fwidth_1:get_help(out)
	out.write( '\n\nNAME\nfwidth - returns sum of approximate window-space partial derivatives magnitudes\n\n\nSYNOPSIS\nfloat fwidth(float a);\nfloat1 fwidth(float1 a);\nfloat2 fwidth(float2 a);\nfloat3 fwidth(float3 a);\nfloat4 fwidth(float4 a);\nhalf fwidth(half a);\nhalf1 fwidth(half1 a);\nhalf2 fwidth(half2 a);\nhalf3 fwidth(half3 a);\nhalf4 fwidth(half4 a);\nfixed fwidth(fixed a);\nfixed1 fwidth(fixed1 a);\nfixed2 fwidth(fixed2 a);\nfixed3 fwidth(fixed3 a);\nfixed4 fwidth(fixed4 a);\n\n\nPARAMETERS\na Vector or scalar of which to sum its approximate window-space partial derivative magnitudes.\nwith respect to window-space X and Y.\n\n\nDESCRIPTION\nReturns sum of the absolute values of each approximate partial derivative of a with respect to both the\nwindow-space (horizontal) x and (vertical) y) coordinate.\n.PP For vectors, the returned vector contains the sum of partial derivative magnitudes of each element of the\ninput vector.\nThis function can be used to approximate the fragment width (hence the name fwidth) for level-of-detail\ncomputations dependent on change in window-space.\nThis function is only available in fragment program profiles (but not all of them).\nThe specific way the partial derivative is computed is implementation-dependent. Typically fragments are\nrasterized in 2x2 arrangements of fragments (called quad-fragments) and the partial derivatives of a\nvariable is computed by differencing with the adjacent horizontal fragment in the quad-fragment.\nThe partial derivative computation may incorrect when fwidth is used in control flow paths where not all\nthe fragments within a quad-fragment have branched the same way.\nThe partial derivative computation may be less exact (wobbly) when the variable is computed based on\nvarying parameters interpolated with centroid interpolation.\n\n\nREFERENCE IMPLEMENTATION\nfmod for float3 vectors could be implemented this way:\nfloat3 fwidth(float3 a)\n{\nreturn abs(ddx(a)) + abs(ddy(a));\n}\n\n\nPROFILE SUPPORT\nfwidth is supported only in fragment profiles. Vertex and geometry profiles lack the concept of window\nspace.\nfwidth is unsupported in the fp20, ps_1_1, ps_1_2, ps_1_3, and arbfp1 profiles.\n\n\nSEE ALSO\nddx, ddy, fp30, fp40, gp4fp\n' )
end

function cg_fwidth_1:new()
	Node.new(self)
	self.name = 'fwidth'
	self.in_a = self.add_port(Input('a'))
	self.out = self.add_port(Output('out'))
end

function cg_fwidth_1:get_type(port)

	local type_a = self.in_a.get_output().get_type()
	if ((type_a == 'float')) then
		return 'float'
	end
	if ((type_a == 'float1')) then
		return 'float1'
	end
	if ((type_a == 'float2')) then
		return 'float2'
	end
	if ((type_a == 'float3')) then
		return 'float3'
	end
	if ((type_a == 'float4')) then
		return 'float4'
	end
	if ((type_a == 'half')) then
		return 'half'
	end
	if ((type_a == 'half1')) then
		return 'half1'
	end
	if ((type_a == 'half2')) then
		return 'half2'
	end
	if ((type_a == 'half3')) then
		return 'half3'
	end
	if ((type_a == 'half4')) then
		return 'half4'
	end
	if ((type_a == 'fixed')) then
		return 'fixed'
	end
	if ((type_a == 'fixed1')) then
		return 'fixed1'
	end
	if ((type_a == 'fixed2')) then
		return 'fixed2'
	end
	if ((type_a == 'fixed3')) then
		return 'fixed3'
	end
	if ((type_a == 'fixed4')) then
		return 'fixed4'
	end
	return nil
end

function cg_fwidth_1:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_fwidth_1:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_a = 'r' .. self.in_a.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = fwidth( ' .. in_a.. ' );\n')
end

function cg_fwidth_1:get_tip(out)
	out.write( 'fwidth - returns sum of approximate window-space partial derivatives magnitudes ' )
end

-- #################################################### --
-- intBitsToFloat( x )
-- #################################################### --
local cg_intBitsToFloat_1 = class(Node)
function cg_intBitsToFloat_1:get_help(out)
	out.write( '\n\nNAME\nintBitsToFloat - returns the float value corresponding to a given bit represention.of a scalar int value or\nvector of int values\n\n\nSYNOPSIS\nfloat intBitsToFloat(int x);\nfloat1 intBitsToFloat(int1 x);\nfloat2 intBitsToFloat(int2 x);\nfloat3 intBitsToFloat(int3 x);\nfloat4 intBitsToFloat(int4 x);\n\n\nPARAMETERS\nx Integer vector or scalar to raw cast to a scalar float or vector of floats\n\n\nDESCRIPTION\nReturns the IEEE 754 float scalar value or vector values corresponding to a given 32-bit integer bit\nrepresention for a scalar int value or vector of int values.\nThis function is based on Javas jave.lang.Float method of the same name. See:\nhttp://java.sun.com/j2se/1.4.2/docs/api/java/lang/Float.html\nThe Cg compiler can typically optimize intBitsToFloat so it has no instruction cost.\n\n\nREFERENCE IMPLEMENTATION\nintBitsToFloat operates consistent with the following ANSI C code:\nfloat floatToRawIntBits(int x)\n{\nunion {\nfloat f; // assuming 32-bit IEEE 754 single-precision\nint i; // assuming 32-bit 2s complement int\n} u;\nu.i = x;\nreturn u.f;\n}\n\n\nPROFILE SUPPORT\nintBitsToFloat is supported by the gp4vp, gp4gp, and gp4vp profiles.\nintBitsToFloat is not supported by pre-G80 profiles.\n\n\nSEE ALSO\nceil, floatToIntBits, floatToRawIntBits, floor, round, trunc\n' )
end

function cg_intBitsToFloat_1:new()
	Node.new(self)
	self.name = 'intBitsToFloat'
	self.in_x = self.add_port(Input('x'))
	self.out = self.add_port(Output('out'))
end

function cg_intBitsToFloat_1:get_type(port)

	local type_x = self.in_x.get_output().get_type()
	if ((type_x == 'int')) then
		return 'float'
	end
	if ((type_x == 'int1')) then
		return 'float1'
	end
	if ((type_x == 'int2')) then
		return 'float2'
	end
	if ((type_x == 'int3')) then
		return 'float3'
	end
	if ((type_x == 'int4')) then
		return 'float4'
	end
	return nil
end

function cg_intBitsToFloat_1:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_intBitsToFloat_1:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_x = 'r' .. self.in_x.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = intBitsToFloat( ' .. in_x.. ' );\n')
end

function cg_intBitsToFloat_1:get_tip(out)
	out.write( 'intBitsToFloat - returns the float value corresponding to a given bit represention.of a scalar int value or vector of int values ' )
end

-- #################################################### --
-- isfinite( x )
-- #################################################### --
local cg_isfinite_1 = class(Node)
function cg_isfinite_1:get_help(out)
	out.write( '\n\nNAME\nisfinite - test whether or not a scalar or each vector component is a finite value\n\n\nSYNOPSIS\nbool isfinite(float x);\nbool1 isfinite(float1 x);\nbool2 isfinite(float2 x);\nbool3 isfinite(float3 x);\nbool4 isfinite(float4 x);\nbool isfinite(half x);\nbool1 isfinite(half1 x);\nbool2 isfinite(half2 x);\nbool3 isfinite(half3 x);\nbool4 isfinite(half4 x);\nbool isfinite(fixed x);\nbool1 isfinite(fixed1 x);\nbool2 isfinite(fixed2 x);\nbool3 isfinite(fixed3 x);\nbool4 isfinite(fixed4 x);\n\n\nPARAMETERS\nx Vector or scalar to test for finiteness.\n\n\nDESCRIPTION\nReturns whether or not a scalar or each vector component is a finite value. Infinity and not-a-number\n(NaN) values are not finite.\n\n\nREFERENCE IMPLEMENTATION\nisfinite for float3 vectors could be implemented like this.\nbool3 isfinite(float3 x)\n{\n// By IEEE 754 rule, 2*Inf equals Inf\nreturn (s == s) && ((s == 0) ïï (s != 2*s));\n}\n\n\nPROFILE SUPPORT\nisfinite is supported in all profiles except fp20.\n\n\nSEE ALSO\nisinf, isnan\n' )
end

function cg_isfinite_1:new()
	Node.new(self)
	self.name = 'isfinite'
	self.in_x = self.add_port(Input('x'))
	self.out = self.add_port(Output('out'))
end

function cg_isfinite_1:get_type(port)

	local type_x = self.in_x.get_output().get_type()
	if ((type_x == 'float')) then
		return 'bool'
	end
	if ((type_x == 'float1')) then
		return 'bool1'
	end
	if ((type_x == 'float2')) then
		return 'bool2'
	end
	if ((type_x == 'float3')) then
		return 'bool3'
	end
	if ((type_x == 'float4')) then
		return 'bool4'
	end
	if ((type_x == 'half')) then
		return 'bool'
	end
	if ((type_x == 'half1')) then
		return 'bool1'
	end
	if ((type_x == 'half2')) then
		return 'bool2'
	end
	if ((type_x == 'half3')) then
		return 'bool3'
	end
	if ((type_x == 'half4')) then
		return 'bool4'
	end
	if ((type_x == 'fixed')) then
		return 'bool'
	end
	if ((type_x == 'fixed1')) then
		return 'bool1'
	end
	if ((type_x == 'fixed2')) then
		return 'bool2'
	end
	if ((type_x == 'fixed3')) then
		return 'bool3'
	end
	if ((type_x == 'fixed4')) then
		return 'bool4'
	end
	return nil
end

function cg_isfinite_1:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_isfinite_1:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_x = 'r' .. self.in_x.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = isfinite( ' .. in_x.. ' );\n')
end

function cg_isfinite_1:get_tip(out)
	out.write( 'isfinite - test whether or not a scalar or each vector component is a finite value ' )
end

-- #################################################### --
-- isinf( x )
-- #################################################### --
local cg_isinf_1 = class(Node)
function cg_isinf_1:get_help(out)
	out.write( '\n\nNAME\nisinf - test whether or not a scalar or each vector component is infinite\n\n\nSYNOPSIS\nbool isinf(float x);\nbool1 isinf(float1 x);\nbool2 isinf(float2 x);\nbool3 isinf(float3 x);\nbool4 isinf(float4 x);\nbool isinf(half x);\nbool1 isinf(half1 x);\nbool2 isinf(half2 x);\nbool3 isinf(half3 x);\nbool4 isinf(half4 x);\nbool isinf(fixed x);\nbool1 isinf(fixed1 x);\nbool2 isinf(fixed2 x);\nbool3 isinf(fixed3 x);\nbool4 isinf(fixed4 x);\n\n\nPARAMETERS\nx Vector or scalar to test if infinite.\n\n\nDESCRIPTION\nReturns whether or not a scalar or each vector component is a (negative or positive) infinite value. Finite\nand not-a-number (NaN) values are not infinite.\n\n\nREFERENCE IMPLEMENTATION\nisinf for float3 vectors could be implemented like this.\nbool3 isinf(float3 x)\n{\n// By IEEE 754 rule, 2*Inf equals Inf\nreturn (2*s == s) && (s != 0);\n}\n\n\nPROFILE SUPPORT\nisinf is supported in all profiles except fp20.\n\n\nSEE ALSO\nisfinite, isnan\n' )
end

function cg_isinf_1:new()
	Node.new(self)
	self.name = 'isinf'
	self.in_x = self.add_port(Input('x'))
	self.out = self.add_port(Output('out'))
end

function cg_isinf_1:get_type(port)

	local type_x = self.in_x.get_output().get_type()
	if ((type_x == 'float')) then
		return 'bool'
	end
	if ((type_x == 'float1')) then
		return 'bool1'
	end
	if ((type_x == 'float2')) then
		return 'bool2'
	end
	if ((type_x == 'float3')) then
		return 'bool3'
	end
	if ((type_x == 'float4')) then
		return 'bool4'
	end
	if ((type_x == 'half')) then
		return 'bool'
	end
	if ((type_x == 'half1')) then
		return 'bool1'
	end
	if ((type_x == 'half2')) then
		return 'bool2'
	end
	if ((type_x == 'half3')) then
		return 'bool3'
	end
	if ((type_x == 'half4')) then
		return 'bool4'
	end
	if ((type_x == 'fixed')) then
		return 'bool'
	end
	if ((type_x == 'fixed1')) then
		return 'bool1'
	end
	if ((type_x == 'fixed2')) then
		return 'bool2'
	end
	if ((type_x == 'fixed3')) then
		return 'bool3'
	end
	if ((type_x == 'fixed4')) then
		return 'bool4'
	end
	return nil
end

function cg_isinf_1:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_isinf_1:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_x = 'r' .. self.in_x.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = isinf( ' .. in_x.. ' );\n')
end

function cg_isinf_1:get_tip(out)
	out.write( 'isinf - test whether or not a scalar or each vector component is infinite ' )
end

-- #################################################### --
-- isnan( x )
-- #################################################### --
local cg_isnan_1 = class(Node)
function cg_isnan_1:get_help(out)
	out.write( '\n\nNAME\nisnan - test whether or not a scalar or each vector component is not-a-number\n\n\nSYNOPSIS\nbool isnan(float x);\nbool1 isnan(float1 x);\nbool2 isnan(float2 x);\nbool3 isnan(float3 x);\nbool4 isnan(float4 x);\nbool isnan(half x);\nbool1 isnan(half1 x);\nbool2 isnan(half2 x);\nbool3 isnan(half3 x);\nbool4 isnan(half4 x);\nbool isnan(fixed x);\nbool1 isnan(fixed1 x);\nbool2 isnan(fixed2 x);\nbool3 isnan(fixed3 x);\nbool4 isnan(fixed4 x);\n\n\nPARAMETERS\nx Vector or scalar to test for being NaN.\n\n\nDESCRIPTION\nReturns whether or not a scalar or each vector component is not-a-number (NaN) Finite and infinite values\nare not NaN.\n\n\nREFERENCE IMPLEMENTATION\nisnan for float3 vectors could be implemented like this.\nbool3 isnan(float3 x)\n{\n// By IEEE 754 rule, NaN is not equal to NaN\nreturn s != s;\n}\n\n\nPROFILE SUPPORT\nisnan is supported in all profiles except fp20.\n\n\nSEE ALSO\nisfinite, isinf\n' )
end

function cg_isnan_1:new()
	Node.new(self)
	self.name = 'isnan'
	self.in_x = self.add_port(Input('x'))
	self.out = self.add_port(Output('out'))
end

function cg_isnan_1:get_type(port)

	local type_x = self.in_x.get_output().get_type()
	if ((type_x == 'float')) then
		return 'bool'
	end
	if ((type_x == 'float1')) then
		return 'bool1'
	end
	if ((type_x == 'float2')) then
		return 'bool2'
	end
	if ((type_x == 'float3')) then
		return 'bool3'
	end
	if ((type_x == 'float4')) then
		return 'bool4'
	end
	if ((type_x == 'half')) then
		return 'bool'
	end
	if ((type_x == 'half1')) then
		return 'bool1'
	end
	if ((type_x == 'half2')) then
		return 'bool2'
	end
	if ((type_x == 'half3')) then
		return 'bool3'
	end
	if ((type_x == 'half4')) then
		return 'bool4'
	end
	if ((type_x == 'fixed')) then
		return 'bool'
	end
	if ((type_x == 'fixed1')) then
		return 'bool1'
	end
	if ((type_x == 'fixed2')) then
		return 'bool2'
	end
	if ((type_x == 'fixed3')) then
		return 'bool3'
	end
	if ((type_x == 'fixed4')) then
		return 'bool4'
	end
	return nil
end

function cg_isnan_1:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_isnan_1:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_x = 'r' .. self.in_x.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = isnan( ' .. in_x.. ' );\n')
end

function cg_isnan_1:get_tip(out)
	out.write( 'isnan - test whether or not a scalar or each vector component is not-a-number ' )
end

-- #################################################### --
-- ldexp( x, n )
-- #################################################### --
local cg_ldexp_2 = class(Node)
function cg_ldexp_2:get_help(out)
	out.write( '\n\nNAME\nldexp - returns x times 2 rained to n\n\n\nSYNOPSIS\nfloat ldexp(float x, float n);\nfloat1 ldexp(float1 x, float1 n);\nfloat2 ldexp(float2 x, float2 n);\nfloat3 ldexp(float3 x, float3 n);\nfloat4 ldexp(float4 x, float4 n);\nhalf ldexp(half x, half n);\nhalf1 ldexp(half1 x, half1 n);\nhalf2 ldexp(half2 x, half2 n);\nhalf3 ldexp(half3 x, half3 n);\nhalf4 ldexp(half4 x, half4 n);\nfixed ldexp(fixed x, fixed n);\nfixed1 ldexp(fixed1 x, fixed1 n);\nfixed2 ldexp(fixed2 x, fixed2 n);\nfixed3 ldexp(fixed3 x, fixed3 n);\nfixed4 ldexp(fixed4 x, fixed4 n);\n\n\nPARAMETERS\nx Vector or scalar.\nn Vector or scalar for power with which to raise 2.\n\n\nDESCRIPTION\nldexp returns x times 2 raised to the power n.\n\n\nREFERENCE IMPLEMENTATION\nldexp for float2 vectors x and n could be implemented as:\nfloat2 ldexp(float2 x, float2 n)\n{\nreturn x * exp2(n);\n}\n\n\nPROFILE SUPPORT\nldexp is supported in all profiles but fp20.\n\n\nSEE ALSO\nexp2, modf, pow\n' )
end

function cg_ldexp_2:new()
	Node.new(self)
	self.name = 'ldexp'
	self.in_x = self.add_port(Input('x'))
	self.in_n = self.add_port(Input('n'))
	self.out = self.add_port(Output('out'))
end

function cg_ldexp_2:get_type(port)

	local type_x = self.in_x.get_output().get_type()
	local type_n = self.in_n.get_output().get_type()
	if ((type_x == 'float')
	and (type_n == 'float')) then
		return 'float'
	end
	if ((type_x == 'float1')
	and (type_n == 'float1')) then
		return 'float1'
	end
	if ((type_x == 'float2')
	and (type_n == 'float2')) then
		return 'float2'
	end
	if ((type_x == 'float3')
	and (type_n == 'float3')) then
		return 'float3'
	end
	if ((type_x == 'float4')
	and (type_n == 'float4')) then
		return 'float4'
	end
	if ((type_x == 'half')
	and (type_n == 'half')) then
		return 'half'
	end
	if ((type_x == 'half1')
	and (type_n == 'half1')) then
		return 'half1'
	end
	if ((type_x == 'half2')
	and (type_n == 'half2')) then
		return 'half2'
	end
	if ((type_x == 'half3')
	and (type_n == 'half3')) then
		return 'half3'
	end
	if ((type_x == 'half4')
	and (type_n == 'half4')) then
		return 'half4'
	end
	if ((type_x == 'fixed')
	and (type_n == 'fixed')) then
		return 'fixed'
	end
	if ((type_x == 'fixed1')
	and (type_n == 'fixed1')) then
		return 'fixed1'
	end
	if ((type_x == 'fixed2')
	and (type_n == 'fixed2')) then
		return 'fixed2'
	end
	if ((type_x == 'fixed3')
	and (type_n == 'fixed3')) then
		return 'fixed3'
	end
	if ((type_x == 'fixed4')
	and (type_n == 'fixed4')) then
		return 'fixed4'
	end
	return nil
end

function cg_ldexp_2:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_ldexp_2:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_x = 'r' .. self.in_x.get_output().hex()
	local in_n = 'r' .. self.in_n.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = ldexp( ' .. in_x.. ', ' .. in_n.. ' );\n')
end

function cg_ldexp_2:get_tip(out)
	out.write( 'ldexp - returns x times 2 rained to n ' )
end

-- #################################################### --
-- length( v )
-- #################################################### --
local cg_length_1 = class(Node)
function cg_length_1:get_help(out)
	out.write( '\n\nNAME\nlength - return scalar Euclidean length of a vector\n\n\nSYNOPSIS\nfloat length(float v);\nfloat length(float1 v);\nfloat length(float2 v);\nfloat length(float3 v);\nfloat length(float4 v);\nhalf length(half v);\nhalf length(half1 v);\nhalf length(half2 v);\nhalf length(half3 v);\nhalf length(half4 v);\nfixed length(fixed v);\nfixed length(fixed1 v);\nfixed length(fixed2 v);\nfixed length(fixed3 v);\nfixed length(fixed4 v);\n\n\nPARAMETERS\nv Vector of which to determine the length.\n\n\nDESCRIPTION\nReturns the Euclidean length of a vector.\n\n\nREFERENCE IMPLEMENTATION\nlength for a float3 vector could be implemented like this.\nfloat length(float3 v)\n{\nreturn sqrt(dot(v,v));\n}\n\n\nPROFILE SUPPORT\nlength is supported in all profiles.\nSupport in the fp20 is limited.\n\n\nSEE ALSO\nmax, normalize, sqrt, dot\n' )
end

function cg_length_1:new()
	Node.new(self)
	self.name = 'length'
	self.in_v = self.add_port(Input('v'))
	self.out = self.add_port(Output('out'))
end

function cg_length_1:get_type(port)

	local type_v = self.in_v.get_output().get_type()
	if ((type_v == 'float')) then
		return 'float'
	end
	if ((type_v == 'float1')) then
		return 'float'
	end
	if ((type_v == 'float2')) then
		return 'float'
	end
	if ((type_v == 'float3')) then
		return 'float'
	end
	if ((type_v == 'float4')) then
		return 'float'
	end
	if ((type_v == 'half')) then
		return 'half'
	end
	if ((type_v == 'half1')) then
		return 'half'
	end
	if ((type_v == 'half2')) then
		return 'half'
	end
	if ((type_v == 'half3')) then
		return 'half'
	end
	if ((type_v == 'half4')) then
		return 'half'
	end
	if ((type_v == 'fixed')) then
		return 'fixed'
	end
	if ((type_v == 'fixed1')) then
		return 'fixed'
	end
	if ((type_v == 'fixed2')) then
		return 'fixed'
	end
	if ((type_v == 'fixed3')) then
		return 'fixed'
	end
	if ((type_v == 'fixed4')) then
		return 'fixed'
	end
	return nil
end

function cg_length_1:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_length_1:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_v = 'r' .. self.in_v.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = length( ' .. in_v.. ' );\n')
end

function cg_length_1:get_tip(out)
	out.write( 'length - return scalar Euclidean length of a vector ' )
end

-- #################################################### --
-- lerp( a, b, w )
-- #################################################### --
local cg_lerp_3 = class(Node)
function cg_lerp_3:get_help(out)
	out.write( '\n\nNAME\nlerp - returns linear interpolation of two scalars or vectors based on a weight\n\n\nSYNOPSIS\nfloat lerp(float a, float b, float w);\nfloat1 lerp(float1 a, float1 b, float1 w);\nfloat2 lerp(float2 a, float2 b, float2 w);\nfloat3 lerp(float3 a, float3 b, float3 w);\nfloat4 lerp(float4 a, float4 b, float4 w);\nfloat1 lerp(float1 a, float1 b, float w);\nfloat2 lerp(float2 a, float2 b, float w);\nfloat3 lerp(float3 a, float3 b, float w);\nfloat4 lerp(float4 a, float4 b, float w);\nhalf lerp(half a, half b, half w);\nhalf1 lerp(half1 a, half1 b, half1 w);\nhalf2 lerp(half2 a, half2 b, half2 w);\nhalf3 lerp(half3 a, half3 b, half3 w);\nhalf4 lerp(half4 a, half4 b, half4 w);\nhalf1 lerp(half1 a, half1 b, half w);\nhalf2 lerp(half2 a, half2 b, half w);\nhalf3 lerp(half3 a, half3 b, half w);\nhalf4 lerp(half4 a, half4 b, half w);\nfixed lerp(fixed a, fixed b, fixed w);\nfixed1 lerp(fixed1 a, fixed1 b, fixed1 w);\nfixed2 lerp(fixed2 a, fixed2 b, fixed2 w);\nfixed3 lerp(fixed3 a, fixed3 b, fixed3 w);\nfixed4 lerp(fixed4 a, fixed4 b, fixed4 w);\nfixed1 lerp(fixed1 a, fixed1 b, fixed w);\nfixed2 lerp(fixed2 a, fixed2 b, fixed w);\nfixed3 lerp(fixed3 a, fixed3 b, fixed w);\nfixed4 lerp(fixed4 a, fixed4 b, fixed w);\n\n\nPARAMETERS\na Vector or scalar to weight; returned with w is one.\nb Vector or scalar to weight; returned with w is zero.\nw Vector or scalar weight.\n\n\nDESCRIPTION\nReturns the linear interpolation of a and b based on weight w.\na and b are either both scalars or both vectors of the same length. The weight w may be a scalar or a vector\nof the same length as a and b. w can be any value (so is not restricted to be between zero and one); if w has\nvalues outside the [0,1] range, it actually extrapolates.\nlerp returns a when w is one and returns b when w is zero.\n\n\nREFERENCE IMPLEMENTATION\nlerp for float3 vectors for a and b and a float w could be implemented like this:\nfloat3 lerp(float3 a, float3 b, float w)\n{\nreturn a + w*(b-a);\n}\n\n\nPROFILE SUPPORT\nlerp is supported in all profiles.\n\n\nSEE ALSO\nsaturate, smoothstep, step\n' )
end

function cg_lerp_3:new()
	Node.new(self)
	self.name = 'lerp'
	self.in_a = self.add_port(Input('a'))
	self.in_b = self.add_port(Input('b'))
	self.in_w = self.add_port(Input('w'))
	self.out = self.add_port(Output('out'))
end

function cg_lerp_3:get_type(port)

	local type_a = self.in_a.get_output().get_type()
	local type_b = self.in_b.get_output().get_type()
	local type_w = self.in_w.get_output().get_type()
	if ((type_a == 'float')
	and (type_b == 'float')
	and (type_w == 'float')) then
		return 'float'
	end
	if ((type_a == 'float1')
	and (type_b == 'float1')
	and (type_w == 'float1')) then
		return 'float1'
	end
	if ((type_a == 'float2')
	and (type_b == 'float2')
	and (type_w == 'float2')) then
		return 'float2'
	end
	if ((type_a == 'float3')
	and (type_b == 'float3')
	and (type_w == 'float3')) then
		return 'float3'
	end
	if ((type_a == 'float4')
	and (type_b == 'float4')
	and (type_w == 'float4')) then
		return 'float4'
	end
	if ((type_a == 'float1')
	and (type_b == 'float1')
	and (type_w == 'float')) then
		return 'float1'
	end
	if ((type_a == 'float2')
	and (type_b == 'float2')
	and (type_w == 'float')) then
		return 'float2'
	end
	if ((type_a == 'float3')
	and (type_b == 'float3')
	and (type_w == 'float')) then
		return 'float3'
	end
	if ((type_a == 'float4')
	and (type_b == 'float4')
	and (type_w == 'float')) then
		return 'float4'
	end
	if ((type_a == 'half')
	and (type_b == 'half')
	and (type_w == 'half')) then
		return 'half'
	end
	if ((type_a == 'half1')
	and (type_b == 'half1')
	and (type_w == 'half1')) then
		return 'half1'
	end
	if ((type_a == 'half2')
	and (type_b == 'half2')
	and (type_w == 'half2')) then
		return 'half2'
	end
	if ((type_a == 'half3')
	and (type_b == 'half3')
	and (type_w == 'half3')) then
		return 'half3'
	end
	if ((type_a == 'half4')
	and (type_b == 'half4')
	and (type_w == 'half4')) then
		return 'half4'
	end
	if ((type_a == 'half1')
	and (type_b == 'half1')
	and (type_w == 'half')) then
		return 'half1'
	end
	if ((type_a == 'half2')
	and (type_b == 'half2')
	and (type_w == 'half')) then
		return 'half2'
	end
	if ((type_a == 'half3')
	and (type_b == 'half3')
	and (type_w == 'half')) then
		return 'half3'
	end
	if ((type_a == 'half4')
	and (type_b == 'half4')
	and (type_w == 'half')) then
		return 'half4'
	end
	if ((type_a == 'fixed')
	and (type_b == 'fixed')
	and (type_w == 'fixed')) then
		return 'fixed'
	end
	if ((type_a == 'fixed1')
	and (type_b == 'fixed1')
	and (type_w == 'fixed1')) then
		return 'fixed1'
	end
	if ((type_a == 'fixed2')
	and (type_b == 'fixed2')
	and (type_w == 'fixed2')) then
		return 'fixed2'
	end
	if ((type_a == 'fixed3')
	and (type_b == 'fixed3')
	and (type_w == 'fixed3')) then
		return 'fixed3'
	end
	if ((type_a == 'fixed4')
	and (type_b == 'fixed4')
	and (type_w == 'fixed4')) then
		return 'fixed4'
	end
	if ((type_a == 'fixed1')
	and (type_b == 'fixed1')
	and (type_w == 'fixed')) then
		return 'fixed1'
	end
	if ((type_a == 'fixed2')
	and (type_b == 'fixed2')
	and (type_w == 'fixed')) then
		return 'fixed2'
	end
	if ((type_a == 'fixed3')
	and (type_b == 'fixed3')
	and (type_w == 'fixed')) then
		return 'fixed3'
	end
	if ((type_a == 'fixed4')
	and (type_b == 'fixed4')
	and (type_w == 'fixed')) then
		return 'fixed4'
	end
	return nil
end

function cg_lerp_3:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_lerp_3:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_a = 'r' .. self.in_a.get_output().hex()
	local in_b = 'r' .. self.in_b.get_output().hex()
	local in_w = 'r' .. self.in_w.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = lerp( ' .. in_a.. ', ' .. in_b.. ', ' .. in_w.. ' );\n')
end

function cg_lerp_3:get_tip(out)
	out.write( 'lerp - returns linear interpolation of two scalars or vectors based on a weight ' )
end

-- #################################################### --
-- log( a )
-- #################################################### --
local cg_log_1 = class(Node)
function cg_log_1:get_help(out)
	out.write( '\n\nNAME\nlog - returns the natural logarithm of scalars and vectors\n\n\nSYNOPSIS\nfloat log(float a);\nfloat1 log(float1 a);\nfloat2 log(float2 a);\nfloat3 log(float3 a);\nfloat4 log(float4 a);\nhalf log(half a);\nhalf1 log(half1 a);\nhalf2 log(half2 a);\nhalf3 log(half3 a);\nhalf4 log(half4 a);\nfixed log(fixed a);\nfixed1 log(fixed1 a);\nfixed2 log(fixed2 a);\nfixed3 log(fixed3 a);\nfixed4 log(fixed4 a);\n\n\nPARAMETERS\na Vector or scalar of which to determine the natural logarithm.\n\n\nDESCRIPTION\nReturns the natural logarithm a.\nFor vectors, the returned vector contains the natural logarithm of each element of the input vector.\n\n\nREFERENCE IMPLEMENTATION\nfloat3 log(float3 a)\n{\nfloat3 rv;\nint i;\nfor (i=0; i<3; i++) {\nrv[i] = log(a[i]); // this is the ANSI C standard library log()\n}\nreturn rv;\n}\nlog is typically implemented with a native base-2 logarithm instruction.\n\n\nPROFILE SUPPORT\nlog is fully supported in all profiles unless otherwise specified.\nSupport in the fp20 is limited to constant compile-time evaluation.\n\n\nSEE ALSO\nexp, log10, log2, pow\n' )
end

function cg_log_1:new()
	Node.new(self)
	self.name = 'log'
	self.in_a = self.add_port(Input('a'))
	self.out = self.add_port(Output('out'))
end

function cg_log_1:get_type(port)

	local type_a = self.in_a.get_output().get_type()
	if ((type_a == 'float')) then
		return 'float'
	end
	if ((type_a == 'float1')) then
		return 'float1'
	end
	if ((type_a == 'float2')) then
		return 'float2'
	end
	if ((type_a == 'float3')) then
		return 'float3'
	end
	if ((type_a == 'float4')) then
		return 'float4'
	end
	if ((type_a == 'half')) then
		return 'half'
	end
	if ((type_a == 'half1')) then
		return 'half1'
	end
	if ((type_a == 'half2')) then
		return 'half2'
	end
	if ((type_a == 'half3')) then
		return 'half3'
	end
	if ((type_a == 'half4')) then
		return 'half4'
	end
	if ((type_a == 'fixed')) then
		return 'fixed'
	end
	if ((type_a == 'fixed1')) then
		return 'fixed1'
	end
	if ((type_a == 'fixed2')) then
		return 'fixed2'
	end
	if ((type_a == 'fixed3')) then
		return 'fixed3'
	end
	if ((type_a == 'fixed4')) then
		return 'fixed4'
	end
	return nil
end

function cg_log_1:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_log_1:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_a = 'r' .. self.in_a.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = log( ' .. in_a.. ' );\n')
end

function cg_log_1:get_tip(out)
	out.write( 'log - returns the natural logarithm of scalars and vectors ' )
end

-- #################################################### --
-- log10( a )
-- #################################################### --
local cg_log10_1 = class(Node)
function cg_log10_1:get_help(out)
	out.write( '\n\nNAME\nlog10 - returns the base-10 logarithm of scalars and vectors\n\n\nSYNOPSIS\nfloat log10(float a);\nfloat1 log10(float1 a);\nfloat2 log10(float2 a);\nfloat3 log10(float3 a);\nfloat4 log10(float4 a);\nhalf log10(half a);\nhalf1 log10(half1 a);\nhalf2 log10(half2 a);\nhalf3 log10(half3 a);\nhalf4 log10(half4 a);\nfixed log10(fixed a);\nfixed1 log10(fixed1 a);\nfixed2 log10(fixed2 a);\nfixed3 log10(fixed3 a);\nfixed4 log10(fixed4 a);\n\n\nPARAMETERS\na Vector or scalar of which to determine the base-10 logarithm.\n\n\nDESCRIPTION\nReturns the base-10 logarithm a.\nFor vectors, the returned vector contains the base-10 logarithm of each element of the input vector.\n\n\nREFERENCE IMPLEMENTATION\nfloat3 log10(float3 a)\n{\nfloat3 rv;\nint i;\nfor (i=0; i<3; i++) {\nrv[i] = log10(a[i]); // this is the ANSI C standard library log10()\n}\nreturn rv;\n}\nlog10 is typically implemented with a native base-10 logarithm instruction.\n\n\nPROFILE SUPPORT\nlog10 is fully supported in all profiles unless otherwise specified.\nSupport in the fp20 is limited to constant compile-time evaluation.\n\n\nSEE ALSO\nexp, log, log2, pow\n' )
end

function cg_log10_1:new()
	Node.new(self)
	self.name = 'log10'
	self.in_a = self.add_port(Input('a'))
	self.out = self.add_port(Output('out'))
end

function cg_log10_1:get_type(port)

	local type_a = self.in_a.get_output().get_type()
	if ((type_a == 'float')) then
		return 'float'
	end
	if ((type_a == 'float1')) then
		return 'float1'
	end
	if ((type_a == 'float2')) then
		return 'float2'
	end
	if ((type_a == 'float3')) then
		return 'float3'
	end
	if ((type_a == 'float4')) then
		return 'float4'
	end
	if ((type_a == 'half')) then
		return 'half'
	end
	if ((type_a == 'half1')) then
		return 'half1'
	end
	if ((type_a == 'half2')) then
		return 'half2'
	end
	if ((type_a == 'half3')) then
		return 'half3'
	end
	if ((type_a == 'half4')) then
		return 'half4'
	end
	if ((type_a == 'fixed')) then
		return 'fixed'
	end
	if ((type_a == 'fixed1')) then
		return 'fixed1'
	end
	if ((type_a == 'fixed2')) then
		return 'fixed2'
	end
	if ((type_a == 'fixed3')) then
		return 'fixed3'
	end
	if ((type_a == 'fixed4')) then
		return 'fixed4'
	end
	return nil
end

function cg_log10_1:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_log10_1:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_a = 'r' .. self.in_a.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = log10( ' .. in_a.. ' );\n')
end

function cg_log10_1:get_tip(out)
	out.write( 'log10 - returns the base-10 logarithm of scalars and vectors ' )
end

-- #################################################### --
-- log2( a )
-- #################################################### --
local cg_log2_1 = class(Node)
function cg_log2_1:get_help(out)
	out.write( '\n\nNAME\nlog2 - returns the base-2 logarithm of scalars and vectors\n\n\nSYNOPSIS\nfloat log2(float a);\nfloat1 log2(float1 a);\nfloat2 log2(float2 a);\nfloat3 log2(float3 a);\nfloat4 log2(float4 a);\nhalf log2(half a);\nhalf1 log2(half1 a);\nhalf2 log2(half2 a);\nhalf3 log2(half3 a);\nhalf4 log2(half4 a);\nfixed log2(fixed a);\nfixed1 log2(fixed1 a);\nfixed2 log2(fixed2 a);\nfixed3 log2(fixed3 a);\nfixed4 log2(fixed4 a);\n\n\nPARAMETERS\na Vector or scalar of which to determine the base-2 logarithm.\n\n\nDESCRIPTION\nReturns the base-2 logarithm a.\nFor vectors, the returned vector contains the base-2 logarithm of each element of the input vector.\n\n\nREFERENCE IMPLEMENTATION\nfloat3 log2(float3 a)\n{\nfloat3 rv;\nint i;\nfor (i=0; i<3; i++) {\nrv[i] = log2(a[i]); // this is the ANSI C standard library log2()\n}\nreturn rv;\n}\nlog2 is typically implemented with a native base-2 logarithm instruction.\n\n\nPROFILE SUPPORT\nlog2 is fully supported in all profiles unless otherwise specified.\nSupport in the fp20 is limited to constant compile-time evaluation.\n\n\nSEE ALSO\nexp, log, log10, pow\n' )
end

function cg_log2_1:new()
	Node.new(self)
	self.name = 'log2'
	self.in_a = self.add_port(Input('a'))
	self.out = self.add_port(Output('out'))
end

function cg_log2_1:get_type(port)

	local type_a = self.in_a.get_output().get_type()
	if ((type_a == 'float')) then
		return 'float'
	end
	if ((type_a == 'float1')) then
		return 'float1'
	end
	if ((type_a == 'float2')) then
		return 'float2'
	end
	if ((type_a == 'float3')) then
		return 'float3'
	end
	if ((type_a == 'float4')) then
		return 'float4'
	end
	if ((type_a == 'half')) then
		return 'half'
	end
	if ((type_a == 'half1')) then
		return 'half1'
	end
	if ((type_a == 'half2')) then
		return 'half2'
	end
	if ((type_a == 'half3')) then
		return 'half3'
	end
	if ((type_a == 'half4')) then
		return 'half4'
	end
	if ((type_a == 'fixed')) then
		return 'fixed'
	end
	if ((type_a == 'fixed1')) then
		return 'fixed1'
	end
	if ((type_a == 'fixed2')) then
		return 'fixed2'
	end
	if ((type_a == 'fixed3')) then
		return 'fixed3'
	end
	if ((type_a == 'fixed4')) then
		return 'fixed4'
	end
	return nil
end

function cg_log2_1:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_log2_1:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_a = 'r' .. self.in_a.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = log2( ' .. in_a.. ' );\n')
end

function cg_log2_1:get_tip(out)
	out.write( 'log2 - returns the base-2 logarithm of scalars and vectors ' )
end

-- #################################################### --
-- max( a, b )
-- #################################################### --
local cg_max_2 = class(Node)
function cg_max_2:get_help(out)
	out.write( '\n\nNAME\nmax - returns the maximum of two scalars or each respective component of two vectors\n\n\nSYNOPSIS\nfloat max(float a, float b);\nfloat1 max(float1 a, float1 b);\nfloat2 max(float2 a, float2 b);\nfloat3 max(float3 a, float3 b);\nfloat4 max(float4 a, float4 b);\nhalf max(half a, half b);\nhalf1 max(half1 a, half1 b);\nhalf2 max(half2 a, half2 b);\nhalf3 max(half3 a, half3 b);\nhalf4 max(half4 a, half4 b);\nfixed max(fixed a, fixed b);\nfixed1 max(fixed1 a, fixed1 b);\nfixed2 max(fixed2 a, fixed2 b);\nfixed3 max(fixed3 a, fixed3 b);\nfixed4 max(fixed4 a, fixed4 b);\n\n\nPARAMETERS\na Scalar or vector.\nb Scalar or vector.\n\n\nDESCRIPTION\nReturns the maximum of two same-typed scalars a and b or the respective components of two same-typed\nvectors a and b. The result is a three-component vector.\n\n\nREFERENCE IMPLEMENTATION\nmax for float3 vectors could be implemented this way:\nfloat3 max(float3 a, float3 b)\n{\nreturn float3(a.x > b.x ? a.x : b.x,\na.y > b.y ? a.y : b.y,\na.z > b.z ? a.z : b.z);\n}\n\n\nPROFILE SUPPORT\nmax is supported in all profiles. max is implemented as a compiler built-in.\nSupport in the fp20 is limited.\n\n\nSEE ALSO\nclamp, min\n' )
end

function cg_max_2:new()
	Node.new(self)
	self.name = 'max'
	self.in_a = self.add_port(Input('a'))
	self.in_b = self.add_port(Input('b'))
	self.out = self.add_port(Output('out'))
end

function cg_max_2:get_type(port)

	local type_a = self.in_a.get_output().get_type()
	local type_b = self.in_b.get_output().get_type()
	if ((type_a == 'float')
	and (type_b == 'float')) then
		return 'float'
	end
	if ((type_a == 'float1')
	and (type_b == 'float1')) then
		return 'float1'
	end
	if ((type_a == 'float2')
	and (type_b == 'float2')) then
		return 'float2'
	end
	if ((type_a == 'float3')
	and (type_b == 'float3')) then
		return 'float3'
	end
	if ((type_a == 'float4')
	and (type_b == 'float4')) then
		return 'float4'
	end
	if ((type_a == 'half')
	and (type_b == 'half')) then
		return 'half'
	end
	if ((type_a == 'half1')
	and (type_b == 'half1')) then
		return 'half1'
	end
	if ((type_a == 'half2')
	and (type_b == 'half2')) then
		return 'half2'
	end
	if ((type_a == 'half3')
	and (type_b == 'half3')) then
		return 'half3'
	end
	if ((type_a == 'half4')
	and (type_b == 'half4')) then
		return 'half4'
	end
	if ((type_a == 'fixed')
	and (type_b == 'fixed')) then
		return 'fixed'
	end
	if ((type_a == 'fixed1')
	and (type_b == 'fixed1')) then
		return 'fixed1'
	end
	if ((type_a == 'fixed2')
	and (type_b == 'fixed2')) then
		return 'fixed2'
	end
	if ((type_a == 'fixed3')
	and (type_b == 'fixed3')) then
		return 'fixed3'
	end
	if ((type_a == 'fixed4')
	and (type_b == 'fixed4')) then
		return 'fixed4'
	end
	return nil
end

function cg_max_2:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_max_2:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_a = 'r' .. self.in_a.get_output().hex()
	local in_b = 'r' .. self.in_b.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = max( ' .. in_a.. ', ' .. in_b.. ' );\n')
end

function cg_max_2:get_tip(out)
	out.write( 'max - returns the maximum of two scalars or each respective component of two vectors ' )
end

-- #################################################### --
-- min( a, b )
-- #################################################### --
local cg_min_2 = class(Node)
function cg_min_2:get_help(out)
	out.write( '\n\nNAME\nmin - returns the minimum of two scalars or each respective component of two vectors\n\n\nSYNOPSIS\nfloat min(float a, float b);\nfloat1 min(float1 a, float1 b);\nfloat2 min(float2 a, float2 b);\nfloat3 min(float3 a, float3 b);\nfloat4 min(float4 a, float4 b);\nhalf min(half a, half b);\nhalf1 min(half1 a, half1 b);\nhalf2 min(half2 a, half2 b);\nhalf3 min(half3 a, half3 b);\nhalf4 min(half4 a, half4 b);\nfixed min(fixed a, fixed b);\nfixed1 min(fixed1 a, fixed1 b);\nfixed2 min(fixed2 a, fixed2 b);\nfixed3 min(fixed3 a, fixed3 b);\nfixed4 min(fixed4 a, fixed4 b);\n\n\nPARAMETERS\na Scalar or vector.\nb Scalar or vector.\n\n\nDESCRIPTION\nReturns the minimum of two same-typed scalars a and b or the respective components of two same-typed\nvectors a and b. The result is a three-component vector.\n\n\nREFERENCE IMPLEMENTATION\nmin for float3 vectors could be implemented this way:\nfloat3 min(float3 a, float3 b)\n{\nreturn float3(a.x < b.x ? a.x : b.x,\na.y < b.y ? a.y : b.y,\na.z < b.z ? a.z : b.z);\n}\n\n\nPROFILE SUPPORT\nmin is supported in all profiles. min is implemented as a compiler built-in.\nSupport in the fp20 is limited.\n\n\nSEE ALSO\nclamp, max\n' )
end

function cg_min_2:new()
	Node.new(self)
	self.name = 'min'
	self.in_a = self.add_port(Input('a'))
	self.in_b = self.add_port(Input('b'))
	self.out = self.add_port(Output('out'))
end

function cg_min_2:get_type(port)

	local type_a = self.in_a.get_output().get_type()
	local type_b = self.in_b.get_output().get_type()
	if ((type_a == 'float')
	and (type_b == 'float')) then
		return 'float'
	end
	if ((type_a == 'float1')
	and (type_b == 'float1')) then
		return 'float1'
	end
	if ((type_a == 'float2')
	and (type_b == 'float2')) then
		return 'float2'
	end
	if ((type_a == 'float3')
	and (type_b == 'float3')) then
		return 'float3'
	end
	if ((type_a == 'float4')
	and (type_b == 'float4')) then
		return 'float4'
	end
	if ((type_a == 'half')
	and (type_b == 'half')) then
		return 'half'
	end
	if ((type_a == 'half1')
	and (type_b == 'half1')) then
		return 'half1'
	end
	if ((type_a == 'half2')
	and (type_b == 'half2')) then
		return 'half2'
	end
	if ((type_a == 'half3')
	and (type_b == 'half3')) then
		return 'half3'
	end
	if ((type_a == 'half4')
	and (type_b == 'half4')) then
		return 'half4'
	end
	if ((type_a == 'fixed')
	and (type_b == 'fixed')) then
		return 'fixed'
	end
	if ((type_a == 'fixed1')
	and (type_b == 'fixed1')) then
		return 'fixed1'
	end
	if ((type_a == 'fixed2')
	and (type_b == 'fixed2')) then
		return 'fixed2'
	end
	if ((type_a == 'fixed3')
	and (type_b == 'fixed3')) then
		return 'fixed3'
	end
	if ((type_a == 'fixed4')
	and (type_b == 'fixed4')) then
		return 'fixed4'
	end
	return nil
end

function cg_min_2:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_min_2:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_a = 'r' .. self.in_a.get_output().hex()
	local in_b = 'r' .. self.in_b.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = min( ' .. in_a.. ', ' .. in_b.. ' );\n')
end

function cg_min_2:get_tip(out)
	out.write( 'min - returns the minimum of two scalars or each respective component of two vectors ' )
end

-- #################################################### --
-- mul( M, v )
-- #################################################### --
local cg_mul_2 = class(Node)
function cg_mul_2:get_help(out)
	out.write( '\n\nNAME\nmul - multiply a matrix by a column vector, row vector by a matrix, or matrix by a matrix\n\n\nSYNOPSIS\nfloat4 mul(float4x4 M, float4 v);\nfloat4 mul(float4x3 M, float3 v);\nfloat4 mul(float4x2 M, float2 v);\nfloat4 mul(float4x1 M, float1 v);\nfloat3 mul(float3x4 M, float4 v);\nfloat3 mul(float3x3 M, float3 v);\nfloat3 mul(float3x2 M, float2 v);\nfloat3 mul(float3x1 M, float1 v);\nfloat2 mul(float2x4 M, float4 v);\nfloat2 mul(float2x3 M, float3 v);\nfloat2 mul(float2x2 M, float2 v);\nfloat2 mul(float2x1 M, float1 v);\nfloat1 mul(float1x4 M, float4 v);\nfloat1 mul(float1x3 M, float3 v);\nfloat1 mul(float1x2 M, float2 v);\nfloat1 mul(float1x1 M, float1 v);\nfloat4 mul(float4 v, float4x4 M);\nfloat4 mul(float3 v, float3x4 M);\nfloat4 mul(float2 v, float2x4 M);\nfloat4 mul(float1 v, float1x4 M);\nfloat3 mul(float4 v, float4x3 M);\nfloat3 mul(float3 v, float3x3 M);\nfloat3 mul(float2 v, float2x3 M);\nfloat3 mul(float1 v, float1x3 M);\nfloat2 mul(float4 v, float4x2 M);\nfloat2 mul(float3 v, float3x2 M);\nfloat2 mul(float2 v, float2x2 M);\nfloat2 mul(float1 v, float1x2 M);\nfloat1 mul(float4 v, float4x1 M);\nfloat1 mul(float3 v, float3x1 M);\nfloat1 mul(float2 v, float2x1 M);\nfloat1 mul(float1 v, float1x1 M);\nhalf4 mul(half4x4 M, half4 v);\nhalf4 mul(half4x3 M, half3 v);\nhalf4 mul(half4x2 M, half2 v);\nhalf4 mul(half4x1 M, half1 v);\nhalf3 mul(half3x4 M, half4 v);\nhalf3 mul(half3x3 M, half3 v);\nhalf3 mul(half3x2 M, half2 v);\nhalf3 mul(half3x1 M, half1 v);\nhalf2 mul(half2x4 M, half4 v);\nhalf2 mul(half2x3 M, half3 v);\nhalf2 mul(half2x2 M, half2 v);\nhalf2 mul(half2x1 M, half1 v);\nhalf1 mul(half1x4 M, half4 v);\nhalf1 mul(half1x3 M, half3 v);\nhalf1 mul(half1x2 M, half2 v);\nhalf1 mul(half1x1 M, half1 v);\nhalf4 mul(half4 v, half4x4 M);\nhalf4 mul(half3 v, half3x4 M);\nhalf4 mul(half2 v, half2x4 M);\nhalf4 mul(half1 v, half1x4 M);\nhalf3 mul(half4 v, half4x3 M);\nhalf3 mul(half3 v, half3x3 M);\nhalf3 mul(half2 v, half2x3 M);\nhalf3 mul(half1 v, half1x3 M);\nhalf2 mul(half4 v, half4x2 M);\nhalf2 mul(half3 v, half3x2 M);\nhalf2 mul(half2 v, half2x2 M);\nhalf2 mul(half1 v, half1x2 M);\nhalf1 mul(half4 v, half4x1 M);\nhalf1 mul(half3 v, half3x1 M);\nhalf1 mul(half2 v, half2x1 M);\nhalf1 mul(half1 v, half1x1 M);\nfixed4 mul(fixed4x4 M, fixed4 v);\nfixed4 mul(fixed4x3 M, fixed3 v);\nfixed4 mul(fixed4x2 M, fixed2 v);\nfixed4 mul(fixed4x1 M, fixed1 v);\nfixed3 mul(fixed3x4 M, fixed4 v);\nfixed3 mul(fixed3x3 M, fixed3 v);\nfixed3 mul(fixed3x2 M, fixed2 v);\nfixed3 mul(fixed3x1 M, fixed1 v);\nfixed2 mul(fixed2x4 M, fixed4 v);\nfixed2 mul(fixed2x3 M, fixed3 v);\nfixed2 mul(fixed2x2 M, fixed2 v);\nfixed2 mul(fixed2x1 M, fixed1 v);\nfixed1 mul(fixed1x4 M, fixed4 v);\nfixed1 mul(fixed1x3 M, fixed3 v);\nfixed1 mul(fixed1x2 M, fixed2 v);\nfixed1 mul(fixed1x1 M, fixed1 v);\nfixed4 mul(fixed4 v, fixed4x4 M);\nfixed4 mul(fixed3 v, fixed3x4 M);\nfixed4 mul(fixed2 v, fixed2x4 M);\nfixed4 mul(fixed1 v, fixed1x4 M);\nfixed3 mul(fixed4 v, fixed4x3 M);\nfixed3 mul(fixed3 v, fixed3x3 M);\nfixed3 mul(fixed2 v, fixed2x3 M);\nfixed3 mul(fixed1 v, fixed1x3 M);\nfixed2 mul(fixed4 v, fixed4x2 M);\nfixed2 mul(fixed3 v, fixed3x2 M);\nfixed2 mul(fixed2 v, fixed2x2 M);\nfixed2 mul(fixed1 v, fixed1x2 M);\nfixed1 mul(fixed4 v, fixed4x1 M);\nfixed1 mul(fixed3 v, fixed3x1 M);\nfixed1 mul(fixed2 v, fixed2x1 M);\nfixed1 mul(fixed1 v, fixed1x1 M);\nfloat1x1 mul(float1x1 A, float1x1 B);\nfloat1x2 mul(float1x1 A, float1x2 B);\nfloat1x3 mul(float1x1 A, float1x3 B);\nfloat1x4 mul(float1x1 A, float1x4 B);\nfloat1x1 mul(float1x2 A, float2x1 B);\nfloat1x2 mul(float1x2 A, float2x2 B);\nfloat1x3 mul(float1x2 A, float2x3 B);\nfloat1x4 mul(float1x2 A, float2x4 B);\nfloat1x1 mul(float1x3 A, float3x1 B);\nfloat1x2 mul(float1x3 A, float3x2 B);\nfloat1x3 mul(float1x3 A, float3x3 B);\nfloat1x4 mul(float1x3 A, float3x4 B);\nfloat1x1 mul(float1x4 A, float4x1 B);\nfloat1x2 mul(float1x4 A, float4x2 B);\nfloat1x3 mul(float1x4 A, float4x3 B);\nfloat1x4 mul(float1x4 A, float4x4 B);\nfloat2x1 mul(float2x1 A, float1x1 B);\nfloat2x2 mul(float2x1 A, float1x2 B);\nfloat2x3 mul(float2x1 A, float1x3 B);\nfloat2x4 mul(float2x1 A, float1x4 B);\nfloat2x1 mul(float2x2 A, float2x1 B);\nfloat2x2 mul(float2x2 A, float2x2 B);\nfloat2x3 mul(float2x2 A, float2x3 B);\nfloat2x4 mul(float2x2 A, float2x4 B);\nfloat2x1 mul(float2x3 A, float3x1 B);\nfloat2x2 mul(float2x3 A, float3x2 B);\nfloat2x3 mul(float2x3 A, float3x3 B);\nfloat2x4 mul(float2x3 A, float3x4 B);\nfloat2x1 mul(float2x4 A, float4x1 B);\nfloat2x2 mul(float2x4 A, float4x2 B);\nfloat2x3 mul(float2x4 A, float4x3 B);\nfloat2x4 mul(float2x4 A, float4x4 B);\nfloat3x1 mul(float3x1 A, float1x1 B);\nfloat3x2 mul(float3x1 A, float1x2 B);\nfloat3x3 mul(float3x1 A, float1x3 B);\nfloat3x4 mul(float3x1 A, float1x4 B);\nfloat3x1 mul(float3x2 A, float2x1 B);\nfloat3x2 mul(float3x2 A, float2x2 B);\nfloat3x3 mul(float3x2 A, float2x3 B);\nfloat3x4 mul(float3x2 A, float2x4 B);\nfloat3x1 mul(float3x3 A, float3x1 B);\nfloat3x2 mul(float3x3 A, float3x2 B);\nfloat3x3 mul(float3x3 A, float3x3 B);\nfloat3x4 mul(float3x3 A, float3x4 B);\nfloat3x1 mul(float3x4 A, float4x1 B);\nfloat3x2 mul(float3x4 A, float4x2 B);\nfloat3x3 mul(float3x4 A, float4x3 B);\nfloat3x4 mul(float3x4 A, float4x4 B);\nfloat4x1 mul(float4x1 A, float1x1 B);\nfloat4x2 mul(float4x1 A, float1x2 B);\nfloat4x3 mul(float4x1 A, float1x3 B);\nfloat4x4 mul(float4x1 A, float1x4 B);\nfloat4x1 mul(float4x2 A, float2x1 B);\nfloat4x2 mul(float4x2 A, float2x2 B);\nfloat4x3 mul(float4x2 A, float2x3 B);\nfloat4x4 mul(float4x2 A, float2x4 B);\nfloat4x1 mul(float4x3 A, float3x1 B);\nfloat4x2 mul(float4x3 A, float3x2 B);\nfloat4x3 mul(float4x3 A, float3x3 B);\nfloat4x4 mul(float4x3 A, float3x4 B);\nfloat4x1 mul(float4x4 A, float4x1 B);\nfloat4x2 mul(float4x4 A, float4x2 B);\nfloat4x3 mul(float4x4 A, float4x3 B);\nfloat4x4 mul(float4x4 A, float4x4 B);\n\n\nPARAMETERS\nM Matrix\nv Vector\nA Matrix\nB Matrix\n\n\nDESCRIPTION\nReturns the vector result of multiplying a matrix M by a column vector v; a row vector v by a matrix M; or a\nmatrix A by a second matrix B.\nThe following are algebrically equal (if not necessarily numerically equal):\nmul(M,v) == mul(v, tranpose(M))\nmul(v,M) == mul(tranpose(M), v)\n\n\nREFERENCE IMPLEMENTATION\nmul for a float4x3 matrix by a float3 column vector could be implemented this way:\nfloat4 mul(float4x3 M, float3 v)\n{\nfloat4 r;\nr.x = dot( M._m00_m01_m02, v );\nr.y = dot( M._m10_m11_m12, v );\nr.z = dot( M._m20_m21_m22, v );\nr.w = dot( M._m30_m31_m32, v );\nreturn r;\n}\n\n\nPROFILE SUPPORT\nmul is supported in all profiles.\nThe fifixed3 matrix-by-vector and vector-by-matrix multiplies are very efficient in the fp20 and fp30 profiles.\n\n\nSEE ALSO\ncross, dot, transpose\n' )
end

function cg_mul_2:new()
	Node.new(self)
	self.name = 'mul'
	self.in_M = self.add_port(Input('M'))
	self.in_v = self.add_port(Input('v'))
	self.out = self.add_port(Output('out'))
end

function cg_mul_2:get_type(port)

	local type_M = self.in_M.get_output().get_type()
	local type_v = self.in_v.get_output().get_type()
	if ((type_M == 'float4x4')
	and (type_v == 'float4')) then
		return 'float4'
	end
	if ((type_M == 'float4x3')
	and (type_v == 'float3')) then
		return 'float4'
	end
	if ((type_M == 'float4x2')
	and (type_v == 'float2')) then
		return 'float4'
	end
	if ((type_M == 'float4x1')
	and (type_v == 'float1')) then
		return 'float4'
	end
	if ((type_M == 'float3x4')
	and (type_v == 'float4')) then
		return 'float3'
	end
	if ((type_M == 'float3x3')
	and (type_v == 'float3')) then
		return 'float3'
	end
	if ((type_M == 'float3x2')
	and (type_v == 'float2')) then
		return 'float3'
	end
	if ((type_M == 'float3x1')
	and (type_v == 'float1')) then
		return 'float3'
	end
	if ((type_M == 'float2x4')
	and (type_v == 'float4')) then
		return 'float2'
	end
	if ((type_M == 'float2x3')
	and (type_v == 'float3')) then
		return 'float2'
	end
	if ((type_M == 'float2x2')
	and (type_v == 'float2')) then
		return 'float2'
	end
	if ((type_M == 'float2x1')
	and (type_v == 'float1')) then
		return 'float2'
	end
	if ((type_M == 'float1x4')
	and (type_v == 'float4')) then
		return 'float1'
	end
	if ((type_M == 'float1x3')
	and (type_v == 'float3')) then
		return 'float1'
	end
	if ((type_M == 'float1x2')
	and (type_v == 'float2')) then
		return 'float1'
	end
	if ((type_M == 'float1x1')
	and (type_v == 'float1')) then
		return 'float1'
	end
	if ((type_M == 'float4')
	and (type_v == 'float4x4')) then
		return 'float4'
	end
	if ((type_M == 'float3')
	and (type_v == 'float3x4')) then
		return 'float4'
	end
	if ((type_M == 'float2')
	and (type_v == 'float2x4')) then
		return 'float4'
	end
	if ((type_M == 'float1')
	and (type_v == 'float1x4')) then
		return 'float4'
	end
	if ((type_M == 'float4')
	and (type_v == 'float4x3')) then
		return 'float3'
	end
	if ((type_M == 'float3')
	and (type_v == 'float3x3')) then
		return 'float3'
	end
	if ((type_M == 'float2')
	and (type_v == 'float2x3')) then
		return 'float3'
	end
	if ((type_M == 'float1')
	and (type_v == 'float1x3')) then
		return 'float3'
	end
	if ((type_M == 'float4')
	and (type_v == 'float4x2')) then
		return 'float2'
	end
	if ((type_M == 'float3')
	and (type_v == 'float3x2')) then
		return 'float2'
	end
	if ((type_M == 'float2')
	and (type_v == 'float2x2')) then
		return 'float2'
	end
	if ((type_M == 'float1')
	and (type_v == 'float1x2')) then
		return 'float2'
	end
	if ((type_M == 'float4')
	and (type_v == 'float4x1')) then
		return 'float1'
	end
	if ((type_M == 'float3')
	and (type_v == 'float3x1')) then
		return 'float1'
	end
	if ((type_M == 'float2')
	and (type_v == 'float2x1')) then
		return 'float1'
	end
	if ((type_M == 'float1')
	and (type_v == 'float1x1')) then
		return 'float1'
	end
	if ((type_M == 'half4x4')
	and (type_v == 'half4')) then
		return 'half4'
	end
	if ((type_M == 'half4x3')
	and (type_v == 'half3')) then
		return 'half4'
	end
	if ((type_M == 'half4x2')
	and (type_v == 'half2')) then
		return 'half4'
	end
	if ((type_M == 'half4x1')
	and (type_v == 'half1')) then
		return 'half4'
	end
	if ((type_M == 'half3x4')
	and (type_v == 'half4')) then
		return 'half3'
	end
	if ((type_M == 'half3x3')
	and (type_v == 'half3')) then
		return 'half3'
	end
	if ((type_M == 'half3x2')
	and (type_v == 'half2')) then
		return 'half3'
	end
	if ((type_M == 'half3x1')
	and (type_v == 'half1')) then
		return 'half3'
	end
	if ((type_M == 'half2x4')
	and (type_v == 'half4')) then
		return 'half2'
	end
	if ((type_M == 'half2x3')
	and (type_v == 'half3')) then
		return 'half2'
	end
	if ((type_M == 'half2x2')
	and (type_v == 'half2')) then
		return 'half2'
	end
	if ((type_M == 'half2x1')
	and (type_v == 'half1')) then
		return 'half2'
	end
	if ((type_M == 'half1x4')
	and (type_v == 'half4')) then
		return 'half1'
	end
	if ((type_M == 'half1x3')
	and (type_v == 'half3')) then
		return 'half1'
	end
	if ((type_M == 'half1x2')
	and (type_v == 'half2')) then
		return 'half1'
	end
	if ((type_M == 'half1x1')
	and (type_v == 'half1')) then
		return 'half1'
	end
	if ((type_M == 'half4')
	and (type_v == 'half4x4')) then
		return 'half4'
	end
	if ((type_M == 'half3')
	and (type_v == 'half3x4')) then
		return 'half4'
	end
	if ((type_M == 'half2')
	and (type_v == 'half2x4')) then
		return 'half4'
	end
	if ((type_M == 'half1')
	and (type_v == 'half1x4')) then
		return 'half4'
	end
	if ((type_M == 'half4')
	and (type_v == 'half4x3')) then
		return 'half3'
	end
	if ((type_M == 'half3')
	and (type_v == 'half3x3')) then
		return 'half3'
	end
	if ((type_M == 'half2')
	and (type_v == 'half2x3')) then
		return 'half3'
	end
	if ((type_M == 'half1')
	and (type_v == 'half1x3')) then
		return 'half3'
	end
	if ((type_M == 'half4')
	and (type_v == 'half4x2')) then
		return 'half2'
	end
	if ((type_M == 'half3')
	and (type_v == 'half3x2')) then
		return 'half2'
	end
	if ((type_M == 'half2')
	and (type_v == 'half2x2')) then
		return 'half2'
	end
	if ((type_M == 'half1')
	and (type_v == 'half1x2')) then
		return 'half2'
	end
	if ((type_M == 'half4')
	and (type_v == 'half4x1')) then
		return 'half1'
	end
	if ((type_M == 'half3')
	and (type_v == 'half3x1')) then
		return 'half1'
	end
	if ((type_M == 'half2')
	and (type_v == 'half2x1')) then
		return 'half1'
	end
	if ((type_M == 'half1')
	and (type_v == 'half1x1')) then
		return 'half1'
	end
	if ((type_M == 'fixed4x4')
	and (type_v == 'fixed4')) then
		return 'fixed4'
	end
	if ((type_M == 'fixed4x3')
	and (type_v == 'fixed3')) then
		return 'fixed4'
	end
	if ((type_M == 'fixed4x2')
	and (type_v == 'fixed2')) then
		return 'fixed4'
	end
	if ((type_M == 'fixed4x1')
	and (type_v == 'fixed1')) then
		return 'fixed4'
	end
	if ((type_M == 'fixed3x4')
	and (type_v == 'fixed4')) then
		return 'fixed3'
	end
	if ((type_M == 'fixed3x3')
	and (type_v == 'fixed3')) then
		return 'fixed3'
	end
	if ((type_M == 'fixed3x2')
	and (type_v == 'fixed2')) then
		return 'fixed3'
	end
	if ((type_M == 'fixed3x1')
	and (type_v == 'fixed1')) then
		return 'fixed3'
	end
	if ((type_M == 'fixed2x4')
	and (type_v == 'fixed4')) then
		return 'fixed2'
	end
	if ((type_M == 'fixed2x3')
	and (type_v == 'fixed3')) then
		return 'fixed2'
	end
	if ((type_M == 'fixed2x2')
	and (type_v == 'fixed2')) then
		return 'fixed2'
	end
	if ((type_M == 'fixed2x1')
	and (type_v == 'fixed1')) then
		return 'fixed2'
	end
	if ((type_M == 'fixed1x4')
	and (type_v == 'fixed4')) then
		return 'fixed1'
	end
	if ((type_M == 'fixed1x3')
	and (type_v == 'fixed3')) then
		return 'fixed1'
	end
	if ((type_M == 'fixed1x2')
	and (type_v == 'fixed2')) then
		return 'fixed1'
	end
	if ((type_M == 'fixed1x1')
	and (type_v == 'fixed1')) then
		return 'fixed1'
	end
	if ((type_M == 'fixed4')
	and (type_v == 'fixed4x4')) then
		return 'fixed4'
	end
	if ((type_M == 'fixed3')
	and (type_v == 'fixed3x4')) then
		return 'fixed4'
	end
	if ((type_M == 'fixed2')
	and (type_v == 'fixed2x4')) then
		return 'fixed4'
	end
	if ((type_M == 'fixed1')
	and (type_v == 'fixed1x4')) then
		return 'fixed4'
	end
	if ((type_M == 'fixed4')
	and (type_v == 'fixed4x3')) then
		return 'fixed3'
	end
	if ((type_M == 'fixed3')
	and (type_v == 'fixed3x3')) then
		return 'fixed3'
	end
	if ((type_M == 'fixed2')
	and (type_v == 'fixed2x3')) then
		return 'fixed3'
	end
	if ((type_M == 'fixed1')
	and (type_v == 'fixed1x3')) then
		return 'fixed3'
	end
	if ((type_M == 'fixed4')
	and (type_v == 'fixed4x2')) then
		return 'fixed2'
	end
	if ((type_M == 'fixed3')
	and (type_v == 'fixed3x2')) then
		return 'fixed2'
	end
	if ((type_M == 'fixed2')
	and (type_v == 'fixed2x2')) then
		return 'fixed2'
	end
	if ((type_M == 'fixed1')
	and (type_v == 'fixed1x2')) then
		return 'fixed2'
	end
	if ((type_M == 'fixed4')
	and (type_v == 'fixed4x1')) then
		return 'fixed1'
	end
	if ((type_M == 'fixed3')
	and (type_v == 'fixed3x1')) then
		return 'fixed1'
	end
	if ((type_M == 'fixed2')
	and (type_v == 'fixed2x1')) then
		return 'fixed1'
	end
	if ((type_M == 'fixed1')
	and (type_v == 'fixed1x1')) then
		return 'fixed1'
	end
	if ((type_M == 'float1x1')
	and (type_v == 'float1x1')) then
		return 'float1x1'
	end
	if ((type_M == 'float1x1')
	and (type_v == 'float1x2')) then
		return 'float1x2'
	end
	if ((type_M == 'float1x1')
	and (type_v == 'float1x3')) then
		return 'float1x3'
	end
	if ((type_M == 'float1x1')
	and (type_v == 'float1x4')) then
		return 'float1x4'
	end
	if ((type_M == 'float1x2')
	and (type_v == 'float2x1')) then
		return 'float1x1'
	end
	if ((type_M == 'float1x2')
	and (type_v == 'float2x2')) then
		return 'float1x2'
	end
	if ((type_M == 'float1x2')
	and (type_v == 'float2x3')) then
		return 'float1x3'
	end
	if ((type_M == 'float1x2')
	and (type_v == 'float2x4')) then
		return 'float1x4'
	end
	if ((type_M == 'float1x3')
	and (type_v == 'float3x1')) then
		return 'float1x1'
	end
	if ((type_M == 'float1x3')
	and (type_v == 'float3x2')) then
		return 'float1x2'
	end
	if ((type_M == 'float1x3')
	and (type_v == 'float3x3')) then
		return 'float1x3'
	end
	if ((type_M == 'float1x3')
	and (type_v == 'float3x4')) then
		return 'float1x4'
	end
	if ((type_M == 'float1x4')
	and (type_v == 'float4x1')) then
		return 'float1x1'
	end
	if ((type_M == 'float1x4')
	and (type_v == 'float4x2')) then
		return 'float1x2'
	end
	if ((type_M == 'float1x4')
	and (type_v == 'float4x3')) then
		return 'float1x3'
	end
	if ((type_M == 'float1x4')
	and (type_v == 'float4x4')) then
		return 'float1x4'
	end
	if ((type_M == 'float2x1')
	and (type_v == 'float1x1')) then
		return 'float2x1'
	end
	if ((type_M == 'float2x1')
	and (type_v == 'float1x2')) then
		return 'float2x2'
	end
	if ((type_M == 'float2x1')
	and (type_v == 'float1x3')) then
		return 'float2x3'
	end
	if ((type_M == 'float2x1')
	and (type_v == 'float1x4')) then
		return 'float2x4'
	end
	if ((type_M == 'float2x2')
	and (type_v == 'float2x1')) then
		return 'float2x1'
	end
	if ((type_M == 'float2x2')
	and (type_v == 'float2x2')) then
		return 'float2x2'
	end
	if ((type_M == 'float2x2')
	and (type_v == 'float2x3')) then
		return 'float2x3'
	end
	if ((type_M == 'float2x2')
	and (type_v == 'float2x4')) then
		return 'float2x4'
	end
	if ((type_M == 'float2x3')
	and (type_v == 'float3x1')) then
		return 'float2x1'
	end
	if ((type_M == 'float2x3')
	and (type_v == 'float3x2')) then
		return 'float2x2'
	end
	if ((type_M == 'float2x3')
	and (type_v == 'float3x3')) then
		return 'float2x3'
	end
	if ((type_M == 'float2x3')
	and (type_v == 'float3x4')) then
		return 'float2x4'
	end
	if ((type_M == 'float2x4')
	and (type_v == 'float4x1')) then
		return 'float2x1'
	end
	if ((type_M == 'float2x4')
	and (type_v == 'float4x2')) then
		return 'float2x2'
	end
	if ((type_M == 'float2x4')
	and (type_v == 'float4x3')) then
		return 'float2x3'
	end
	if ((type_M == 'float2x4')
	and (type_v == 'float4x4')) then
		return 'float2x4'
	end
	if ((type_M == 'float3x1')
	and (type_v == 'float1x1')) then
		return 'float3x1'
	end
	if ((type_M == 'float3x1')
	and (type_v == 'float1x2')) then
		return 'float3x2'
	end
	if ((type_M == 'float3x1')
	and (type_v == 'float1x3')) then
		return 'float3x3'
	end
	if ((type_M == 'float3x1')
	and (type_v == 'float1x4')) then
		return 'float3x4'
	end
	if ((type_M == 'float3x2')
	and (type_v == 'float2x1')) then
		return 'float3x1'
	end
	if ((type_M == 'float3x2')
	and (type_v == 'float2x2')) then
		return 'float3x2'
	end
	if ((type_M == 'float3x2')
	and (type_v == 'float2x3')) then
		return 'float3x3'
	end
	if ((type_M == 'float3x2')
	and (type_v == 'float2x4')) then
		return 'float3x4'
	end
	if ((type_M == 'float3x3')
	and (type_v == 'float3x1')) then
		return 'float3x1'
	end
	if ((type_M == 'float3x3')
	and (type_v == 'float3x2')) then
		return 'float3x2'
	end
	if ((type_M == 'float3x3')
	and (type_v == 'float3x3')) then
		return 'float3x3'
	end
	if ((type_M == 'float3x3')
	and (type_v == 'float3x4')) then
		return 'float3x4'
	end
	if ((type_M == 'float3x4')
	and (type_v == 'float4x1')) then
		return 'float3x1'
	end
	if ((type_M == 'float3x4')
	and (type_v == 'float4x2')) then
		return 'float3x2'
	end
	if ((type_M == 'float3x4')
	and (type_v == 'float4x3')) then
		return 'float3x3'
	end
	if ((type_M == 'float3x4')
	and (type_v == 'float4x4')) then
		return 'float3x4'
	end
	if ((type_M == 'float4x1')
	and (type_v == 'float1x1')) then
		return 'float4x1'
	end
	if ((type_M == 'float4x1')
	and (type_v == 'float1x2')) then
		return 'float4x2'
	end
	if ((type_M == 'float4x1')
	and (type_v == 'float1x3')) then
		return 'float4x3'
	end
	if ((type_M == 'float4x1')
	and (type_v == 'float1x4')) then
		return 'float4x4'
	end
	if ((type_M == 'float4x2')
	and (type_v == 'float2x1')) then
		return 'float4x1'
	end
	if ((type_M == 'float4x2')
	and (type_v == 'float2x2')) then
		return 'float4x2'
	end
	if ((type_M == 'float4x2')
	and (type_v == 'float2x3')) then
		return 'float4x3'
	end
	if ((type_M == 'float4x2')
	and (type_v == 'float2x4')) then
		return 'float4x4'
	end
	if ((type_M == 'float4x3')
	and (type_v == 'float3x1')) then
		return 'float4x1'
	end
	if ((type_M == 'float4x3')
	and (type_v == 'float3x2')) then
		return 'float4x2'
	end
	if ((type_M == 'float4x3')
	and (type_v == 'float3x3')) then
		return 'float4x3'
	end
	if ((type_M == 'float4x3')
	and (type_v == 'float3x4')) then
		return 'float4x4'
	end
	if ((type_M == 'float4x4')
	and (type_v == 'float4x1')) then
		return 'float4x1'
	end
	if ((type_M == 'float4x4')
	and (type_v == 'float4x2')) then
		return 'float4x2'
	end
	if ((type_M == 'float4x4')
	and (type_v == 'float4x3')) then
		return 'float4x3'
	end
	if ((type_M == 'float4x4')
	and (type_v == 'float4x4')) then
		return 'float4x4'
	end
	return nil
end

function cg_mul_2:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_mul_2:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_M = 'r' .. self.in_M.get_output().hex()
	local in_v = 'r' .. self.in_v.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = mul( ' .. in_M.. ', ' .. in_v.. ' );\n')
end

function cg_mul_2:get_tip(out)
	out.write( 'mul - multiply a matrix by a column vector, row vector by a matrix, or matrix by a matrix ' )
end

-- #################################################### --
-- normalize( a )
-- #################################################### --
local cg_normalize_1 = class(Node)
function cg_normalize_1:get_help(out)
	out.write( '\n\nNAME\nnormalize - returns unit length vector of input a\n\n\nSYNOPSIS\nfloat2 normalize(float2 a);\nfloat3 normalize(float3 a);\nfloat4 normalize(float4 a);\nhalf2 normalize(half2 a);\nhalf3 normalize(half3 a);\nhalf4 normalize(half4 a);\nfixed2 normalize(fixed2 a);\nfixed3 normalize(fixed3 a);\nfixed4 normalize(fixed4 a);\n\n\nPARAMETERS\na Vector of which to normalize to unit length\n\n\nDESCRIPTION\nReturns unit length vector of vector input\n\n\nREFERENCE IMPLEMENTATION\n(Missing)\n\n\nPROFILE SUPPORT\n(Missing)\n\n\nSEE ALSO\n(Missing)\n' )
end

function cg_normalize_1:new()
	Node.new(self)
	self.name = 'normalize'
	self.in_a = self.add_port(Input('a'))
	self.out = self.add_port(Output('out'))
end

function cg_normalize_1:get_type(port)

	local type_a = self.in_a.get_output().get_type()
	if ((type_a == 'float2')) then
		return 'float2'
	end
	if ((type_a == 'float3')) then
		return 'float3'
	end
	if ((type_a == 'float4')) then
		return 'float4'
	end
	if ((type_a == 'half2')) then
		return 'half2'
	end
	if ((type_a == 'half3')) then
		return 'half3'
	end
	if ((type_a == 'half4')) then
		return 'half4'
	end
	if ((type_a == 'fixed2')) then
		return 'fixed2'
	end
	if ((type_a == 'fixed3')) then
		return 'fixed3'
	end
	if ((type_a == 'fixed4')) then
		return 'fixed4'
	end
	return nil
end

function cg_normalize_1:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_normalize_1:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_a = 'r' .. self.in_a.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = normalize( ' .. in_a.. ' );\n')
end

function cg_normalize_1:get_tip(out)
	out.write( 'normalize - returns unit length vector of input a ' )
end

-- #################################################### --
-- pow( x, y )
-- #################################################### --
local cg_pow_2 = class(Node)
function cg_pow_2:get_help(out)
	out.write( '\n\nNAME\npow - returns x to the y-th power of scalars and vectors\n\n\nSYNOPSIS\nfloat pow(float x, float y);\nfloat1 pow(float1 x, float1 y);\nfloat2 pow(float2 x, float2 y);\nfloat3 pow(float3 x, float3 y);\nfloat4 pow(float4 x, float4 y);\nhalf pow(half x, half y);\nhalf1 pow(half1 x, half1 y);\nhalf2 pow(half2 x, half2 y);\nhalf3 pow(half3 x, half3 y);\nhalf4 pow(half4 x, half4 y);\nfixed pow(fixed x, fixed y);\nfixed1 pow(fixed1 x, fixed1 y);\nfixed2 pow(fixed2 x, fixed2 y);\nfixed3 pow(fixed3 x, fixed3 y);\nfixed4 pow(fixed4 x, fixed4 y);\n\n\nPARAMETERS\nx Abase value.\ny The power to raise the base.\n\n\nDESCRIPTION\nReturns x to the power y.\nFor vectors, the returned vector contains the power of each element of the base vector raised to the\nrespective element of the exponent vector.\n\n\nREFERENCE IMPLEMENTATION\npow for float3 vectors could be implemented this way:\nfloat3 pow(float3 x, float3 y)\n{\nfloat3 rv;\nfor (int i=0; i<3; i++) {\nrv[i] = exp(x[i] * log(y[i]));\n}\nreturn rv;\n}\n\n\nPROFILE SUPPORT\nexp is supported in all profiles.\nSupport in the fp20 is limited to constant compile-time evaluation.\n\n\nSEE ALSO\nexp, lit, log\n' )
end

function cg_pow_2:new()
	Node.new(self)
	self.name = 'pow'
	self.in_x = self.add_port(Input('x'))
	self.in_y = self.add_port(Input('y'))
	self.out = self.add_port(Output('out'))
end

function cg_pow_2:get_type(port)

	local type_x = self.in_x.get_output().get_type()
	local type_y = self.in_y.get_output().get_type()
	if ((type_x == 'float')
	and (type_y == 'float')) then
		return 'float'
	end
	if ((type_x == 'float1')
	and (type_y == 'float1')) then
		return 'float1'
	end
	if ((type_x == 'float2')
	and (type_y == 'float2')) then
		return 'float2'
	end
	if ((type_x == 'float3')
	and (type_y == 'float3')) then
		return 'float3'
	end
	if ((type_x == 'float4')
	and (type_y == 'float4')) then
		return 'float4'
	end
	if ((type_x == 'half')
	and (type_y == 'half')) then
		return 'half'
	end
	if ((type_x == 'half1')
	and (type_y == 'half1')) then
		return 'half1'
	end
	if ((type_x == 'half2')
	and (type_y == 'half2')) then
		return 'half2'
	end
	if ((type_x == 'half3')
	and (type_y == 'half3')) then
		return 'half3'
	end
	if ((type_x == 'half4')
	and (type_y == 'half4')) then
		return 'half4'
	end
	if ((type_x == 'fixed')
	and (type_y == 'fixed')) then
		return 'fixed'
	end
	if ((type_x == 'fixed1')
	and (type_y == 'fixed1')) then
		return 'fixed1'
	end
	if ((type_x == 'fixed2')
	and (type_y == 'fixed2')) then
		return 'fixed2'
	end
	if ((type_x == 'fixed3')
	and (type_y == 'fixed3')) then
		return 'fixed3'
	end
	if ((type_x == 'fixed4')
	and (type_y == 'fixed4')) then
		return 'fixed4'
	end
	return nil
end

function cg_pow_2:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_pow_2:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_x = 'r' .. self.in_x.get_output().hex()
	local in_y = 'r' .. self.in_y.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = pow( ' .. in_x.. ', ' .. in_y.. ' );\n')
end

function cg_pow_2:get_tip(out)
	out.write( 'pow - returns x to the y-th power of scalars and vectors ' )
end

-- #################################################### --
-- radians( a )
-- #################################################### --
local cg_radians_1 = class(Node)
function cg_radians_1:get_help(out)
	out.write( '\n\nNAME\nradians - converts values of scalars and vectors from degrees to radians\n\n\nSYNOPSIS\nfloat radians(float a);\nfloat1 radians(float1 a);\nfloat2 radians(float2 a);\nfloat3 radians(float3 a);\nfloat4 radians(float4 a);\nhalf radians(half a);\nhalf1 radians(half1 a);\nhalf2 radians(half2 a);\nhalf3 radians(half3 a);\nhalf4 radians(half4 a);\nfixed radians(fixed a);\nfixed1 radians(fixed1 a);\nfixed2 radians(fixed2 a);\nfixed3 radians(fixed3 a);\nfixed4 radians(fixed4 a);\n\n\nPARAMETERS\na Vector or scalar of which to convert from degrees to radians.\n\n\nDESCRIPTION\nReturns the scalar or vector converted from degrees to radians.\nFor vectors, the returned vector contains each element of the input vector converted from degrees to\nradians.\n\n\nREFERENCE IMPLEMENTATION\nradians for a float scalar could be implemented like this.\nfloat radians(float a)\n{\nreturn 0.017453292 * a;\n}\n\n\nPROFILE SUPPORT\nradians is supported in all profiles except fp20.\n\n\nSEE ALSO\ncos, degrees, sin, tan\n' )
end

function cg_radians_1:new()
	Node.new(self)
	self.name = 'radians'
	self.in_a = self.add_port(Input('a'))
	self.out = self.add_port(Output('out'))
end

function cg_radians_1:get_type(port)

	local type_a = self.in_a.get_output().get_type()
	if ((type_a == 'float')) then
		return 'float'
	end
	if ((type_a == 'float1')) then
		return 'float1'
	end
	if ((type_a == 'float2')) then
		return 'float2'
	end
	if ((type_a == 'float3')) then
		return 'float3'
	end
	if ((type_a == 'float4')) then
		return 'float4'
	end
	if ((type_a == 'half')) then
		return 'half'
	end
	if ((type_a == 'half1')) then
		return 'half1'
	end
	if ((type_a == 'half2')) then
		return 'half2'
	end
	if ((type_a == 'half3')) then
		return 'half3'
	end
	if ((type_a == 'half4')) then
		return 'half4'
	end
	if ((type_a == 'fixed')) then
		return 'fixed'
	end
	if ((type_a == 'fixed1')) then
		return 'fixed1'
	end
	if ((type_a == 'fixed2')) then
		return 'fixed2'
	end
	if ((type_a == 'fixed3')) then
		return 'fixed3'
	end
	if ((type_a == 'fixed4')) then
		return 'fixed4'
	end
	return nil
end

function cg_radians_1:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_radians_1:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_a = 'r' .. self.in_a.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = radians( ' .. in_a.. ' );\n')
end

function cg_radians_1:get_tip(out)
	out.write( 'radians - converts values of scalars and vectors from degrees to radians ' )
end

-- #################################################### --
-- reflect( i, n )
-- #################################################### --
local cg_reflect_2 = class(Node)
function cg_reflect_2:get_help(out)
	out.write( '\n\nNAME\nreflect - returns the reflectiton vector given an incidence vector and a normal vector.\n\n\nSYNOPSIS\nfloat reflect(float i, float n);\nfloat2 reflect(float2 i, float2 n);\nfloat3 reflect(float3 i, float3 n);\nfloat4 reflect(float4 i, float4 n);\n\n\nPARAMETERS\ni Incidence vector.\nn Normal vector.\n\n\nDESCRIPTION\nReturns the reflectiton vector given an incidence vector i and a normal vector n. The resulting vector is the\nidentical number of components as the two input vectors.\nThe normal vector n should be normalized. If n is normalized, the output vector will have the same length\nas the input incidence vector i.\n\n\nREFERENCE IMPLEMENTATION\nreflect for float3 vectors could be implemented this way:\nfloat3 reflect( float3 i, float3 n )\n{\nreturn i - 2.0 * n * dot(n,i);\n}\n\n\nPROFILE SUPPORT\nreflect is supported in all profiles.\nSupport in the fp20 is limited.\n\n\nSEE ALSO\ndot, length, refract\n' )
end

function cg_reflect_2:new()
	Node.new(self)
	self.name = 'reflect'
	self.in_i = self.add_port(Input('i'))
	self.in_n = self.add_port(Input('n'))
	self.out = self.add_port(Output('out'))
end

function cg_reflect_2:get_type(port)

	local type_i = self.in_i.get_output().get_type()
	local type_n = self.in_n.get_output().get_type()
	if ((type_i == 'float')
	and (type_n == 'float')) then
		return 'float'
	end
	if ((type_i == 'float2')
	and (type_n == 'float2')) then
		return 'float2'
	end
	if ((type_i == 'float3')
	and (type_n == 'float3')) then
		return 'float3'
	end
	if ((type_i == 'float4')
	and (type_n == 'float4')) then
		return 'float4'
	end
	return nil
end

function cg_reflect_2:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_reflect_2:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_i = 'r' .. self.in_i.get_output().hex()
	local in_n = 'r' .. self.in_n.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = reflect( ' .. in_i.. ', ' .. in_n.. ' );\n')
end

function cg_reflect_2:get_tip(out)
	out.write( 'reflect - returns the reflectiton vector given an incidence vector and a normal vector. ' )
end

-- #################################################### --
-- refract( i, n, eta )
-- #################################################### --
local cg_refract_3 = class(Node)
function cg_refract_3:get_help(out)
	out.write( '\n\nNAME\nrefract - computes a refraction vector.\n\n\nSYNOPSIS\nfixed3 refract(fixed3 i, fixed3 n, fixed eta);\nhalf3 refract(half3 i, half3 n, half eta);\nfloat3 refract(float3 i, float3 n, float eta);\n\n\nPARAMETERS\ni Incidence vector.\nn Normal vector.\neta Ratio of indices of refraction at the surface interface.\n\n\nDESCRIPTION\nReturns a refraction vector given an incidence vector, a normal vector for a surface, and a ratio of indices of\nrefraction at the surfaces interface.\nThe incidence vector i and normal vector n should be normalized.\n\n\nREFERENCE IMPLEMENTATION\nreflect for float3 vectors could be implemented this way:\nfloat3 refract( float3 i, float3 n, float eta )\n{\nfloat cosi = dot(-i, n);\nfloat cost2 = 1.0f - eta * eta * (1.0f - cosi*cosi);\nfloat3 t = eta*i + ((eta*cosi - sqrt(abs(cost2))) * n);\nreturn t * (float3)(cost2 > 0);\n}\n\n\nPROFILE SUPPORT\nrefract is supported in all profiles.\nSupport in the fp20 is limited.\n\n\nSEE ALSO\nabs, cos, dot, reflect, sqrt\n' )
end

function cg_refract_3:new()
	Node.new(self)
	self.name = 'refract'
	self.in_i = self.add_port(Input('i'))
	self.in_n = self.add_port(Input('n'))
	self.in_eta = self.add_port(Input('eta'))
	self.out = self.add_port(Output('out'))
end

function cg_refract_3:get_type(port)

	local type_i = self.in_i.get_output().get_type()
	local type_n = self.in_n.get_output().get_type()
	local type_eta = self.in_eta.get_output().get_type()
	if ((type_i == 'fixed3')
	and (type_n == 'fixed3')
	and (type_eta == 'fixed')) then
		return 'fixed3'
	end
	if ((type_i == 'half3')
	and (type_n == 'half3')
	and (type_eta == 'half')) then
		return 'half3'
	end
	if ((type_i == 'float3')
	and (type_n == 'float3')
	and (type_eta == 'float')) then
		return 'float3'
	end
	return nil
end

function cg_refract_3:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_refract_3:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_i = 'r' .. self.in_i.get_output().hex()
	local in_n = 'r' .. self.in_n.get_output().hex()
	local in_eta = 'r' .. self.in_eta.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = refract( ' .. in_i.. ', ' .. in_n.. ', ' .. in_eta.. ' );\n')
end

function cg_refract_3:get_tip(out)
	out.write( 'refract - computes a refraction vector. ' )
end

-- #################################################### --
-- round( a )
-- #################################################### --
local cg_round_1 = class(Node)
function cg_round_1:get_help(out)
	out.write( '\n\nNAME\nround - returns the rounded value of scalars or vectors\n\n\nSYNOPSIS\nfloat round(float a);\nfloat1 round(float1 a);\nfloat2 round(float2 a);\nfloat3 round(float3 a);\nfloat4 round(float4 a);\nhalf round(half a);\nhalf1 round(half1 a);\nhalf2 round(half2 a);\nhalf3 round(half3 a);\nhalf4 round(half4 a);\nfixed round(fixed a);\nfixed1 round(fixed1 a);\nfixed2 round(fixed2 a);\nfixed3 round(fixed3 a);\nfixed4 round(fixed4 a);\n\n\nPARAMETERS\na Scalar or vector.\n\n\nDESCRIPTION\nReturns the rounded value of a scalar or vector.\nFor vectors, the returned vector contains the rounded value of each element of the input vector.\nThe round operation returns the nearest integer to the operand. The value returned by round() if the\nfractional portion of the operand is 0.5 is profile dependent. On older profiles without built-in round()\nsupport, round-to-nearest up rounding is used. On profiles newer than fp40/vp40, round-to-nearest even is\nused.\n\n\nREFERENCE IMPLEMENTATION\nround for float could be implemented this way:\n// round-to-nearest even profiles\nfloat round(float a)\n{\nfloat x = a + 0.5;\nfloat f = floor(x);\nfloat r;\nif (x == f) {\nif (a > 0)\nr = f - fmod(f, 2);\nelse\nr = f + fmod(f, 2);\n} else\nr = f;\nreturn r;\n}\n// round-to-nearest up profiles\nfloat round(float a)\n{\nreturn floor(x + 0.5);\n}\n\n\nPROFILE SUPPORT\nround is supported in all profiles except fp20.\n\n\nSEE ALSO\nceil, floor, fmod, trunc\n' )
end

function cg_round_1:new()
	Node.new(self)
	self.name = 'round'
	self.in_a = self.add_port(Input('a'))
	self.out = self.add_port(Output('out'))
end

function cg_round_1:get_type(port)

	local type_a = self.in_a.get_output().get_type()
	if ((type_a == 'float')) then
		return 'float'
	end
	if ((type_a == 'float1')) then
		return 'float1'
	end
	if ((type_a == 'float2')) then
		return 'float2'
	end
	if ((type_a == 'float3')) then
		return 'float3'
	end
	if ((type_a == 'float4')) then
		return 'float4'
	end
	if ((type_a == 'half')) then
		return 'half'
	end
	if ((type_a == 'half1')) then
		return 'half1'
	end
	if ((type_a == 'half2')) then
		return 'half2'
	end
	if ((type_a == 'half3')) then
		return 'half3'
	end
	if ((type_a == 'half4')) then
		return 'half4'
	end
	if ((type_a == 'fixed')) then
		return 'fixed'
	end
	if ((type_a == 'fixed1')) then
		return 'fixed1'
	end
	if ((type_a == 'fixed2')) then
		return 'fixed2'
	end
	if ((type_a == 'fixed3')) then
		return 'fixed3'
	end
	if ((type_a == 'fixed4')) then
		return 'fixed4'
	end
	return nil
end

function cg_round_1:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_round_1:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_a = 'r' .. self.in_a.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = round( ' .. in_a.. ' );\n')
end

function cg_round_1:get_tip(out)
	out.write( 'round - returns the rounded value of scalars or vectors ' )
end

-- #################################################### --
-- saturate( x )
-- #################################################### --
local cg_saturate_1 = class(Node)
function cg_saturate_1:get_help(out)
	out.write( '\n\nNAME\nsaturate - returns smallest integer not less than a scalar or each vector component.\n\n\nSYNOPSIS\nfloat saturate(float x);\nfloat1 saturate(float1 x);\nfloat2 saturate(float2 x);\nfloat3 saturate(float3 x);\nfloat4 saturate(float4 x);\nhalf saturate(half x);\nhalf1 saturate(half1 x);\nhalf2 saturate(half2 x);\nhalf3 saturate(half3 x);\nhalf4 saturate(half4 x);\nfixed saturate(fixed x);\nfixed1 saturate(fixed1 x);\nfixed2 saturate(fixed2 x);\nfixed3 saturate(fixed3 x);\nfixed4 saturate(fixed4 x);\n\n\nPARAMETERS\nx Vector or scalar to saturate.\n\n\nDESCRIPTION\nReturns x saturated to the range [0,1] as follows:\n1) Returns 0 if x is less than 0; else\n2) Returns 1 if x is greater than 1; else\n3) Returns x otherwise.\nFor vectors, the returned vector contains the saturated result of each element of the vector x saturated to\n[0,1].\n\n\nREFERENCE IMPLEMENTATION\nsaturate for float scalars could be implemented like this.\nfloat saturate(float x)\n{\nreturn max(0, min(1, x));\n}\n\n\nPROFILE SUPPORT\nsaturate is supported in all profiles.\nsaturate is very efficient in the fp20, fp30, and fp40 profiles.\n\n\nSEE ALSO\nclamp, max, min\n' )
end

function cg_saturate_1:new()
	Node.new(self)
	self.name = 'saturate'
	self.in_x = self.add_port(Input('x'))
	self.out = self.add_port(Output('out'))
end

function cg_saturate_1:get_type(port)

	local type_x = self.in_x.get_output().get_type()
	if ((type_x == 'float')) then
		return 'float'
	end
	if ((type_x == 'float1')) then
		return 'float1'
	end
	if ((type_x == 'float2')) then
		return 'float2'
	end
	if ((type_x == 'float3')) then
		return 'float3'
	end
	if ((type_x == 'float4')) then
		return 'float4'
	end
	if ((type_x == 'half')) then
		return 'half'
	end
	if ((type_x == 'half1')) then
		return 'half1'
	end
	if ((type_x == 'half2')) then
		return 'half2'
	end
	if ((type_x == 'half3')) then
		return 'half3'
	end
	if ((type_x == 'half4')) then
		return 'half4'
	end
	if ((type_x == 'fixed')) then
		return 'fixed'
	end
	if ((type_x == 'fixed1')) then
		return 'fixed1'
	end
	if ((type_x == 'fixed2')) then
		return 'fixed2'
	end
	if ((type_x == 'fixed3')) then
		return 'fixed3'
	end
	if ((type_x == 'fixed4')) then
		return 'fixed4'
	end
	return nil
end

function cg_saturate_1:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_saturate_1:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_x = 'r' .. self.in_x.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = saturate( ' .. in_x.. ' );\n')
end

function cg_saturate_1:get_tip(out)
	out.write( 'saturate - returns smallest integer not less than a scalar or each vector component. ' )
end

-- #################################################### --
-- sin( a )
-- #################################################### --
local cg_sin_1 = class(Node)
function cg_sin_1:get_help(out)
	out.write( '\n\nNAME\nsin - returns sine of scalars and vectors.\n\n\nSYNOPSIS\nfloat sin(float a);\nfloat1 sin(float1 a);\nfloat2 sin(float2 a);\nfloat3 sin(float3 a);\nfloat4 sin(float4 a);\nhalf sin(half a);\nhalf1 sin(half1 a);\nhalf2 sin(half2 a);\nhalf3 sin(half3 a);\nhalf4 sin(half4 a);\nfixed sin(fixed a);\nfixed1 sin(fixed1 a);\nfixed2 sin(fixed2 a);\nfixed3 sin(fixed3 a);\nfixed4 sin(fixed4 a);\n\n\nPARAMETERS\na Vector or scalar of which to determine the sine.\n\n\nDESCRIPTION\nReturns the sine of a in radians. The return value is in the range [-1,+1].\nFor vectors, the returned vector contains the sine of each element of the input vector.\n\n\nREFERENCE IMPLEMENTATION\nsin is best implemented as a native sine instruction, however sin for a float scalar could be implemented by\nan approximation like this.\nfloat sin(float a)\n{\n/* C simulation gives a max absolute error of less than 1.8e-7 */\nfloat4 c0 = float4( 0.0, 0.5,\n1.0, 0.0 );\nfloat4 c1 = float4( 0.25, -9.0,\n0.75, 0.159154943091 );\nfloat4 c2 = float4( 24.9808039603, -24.9808039603,\n-60.1458091736, 60.1458091736 );\nfloat4 c3 = float4( 85.4537887573, -85.4537887573,\n-64.9393539429, 64.9393539429 );\nfloat4 c4 = float4( 19.7392082214, -19.7392082214,\n-1.0, 1.0 );\n/* r0.x = sin(a) */\nfloat3 r0, r1, r2;\nr1.x = c1.w * a - c1.x; // only difference from cos!\nr1.y = frac( r1.x ); // and extract fraction\nr2.x = (float) ( r1.y < c1.x ); // range check: 0.0 to 0.25\nr2.yz = (float2) ( r1.yy >= c1.yz ); // range check: 0.75 to 1.0\nr2.y = dot( r2, c4.zwz ); // range check: 0.25 to 0.75\nr0 = c0.xyz - r1.yyy; // range centering\nr0 = r0 * r0;\nr1 = c2.xyx * r0 + c2.zwz; // start power series\nr1 = r1 * r0 + c3.xyx;\nr1 = r1 * r0 + c3.zwz;\nr1 = r1 * r0 + c4.xyx;\nr1 = r1 * r0 + c4.zwz;\nr0.x = dot( r1, -r2 ); // range extract\nreturn r0.x;\n}\n\n\nPROFILE SUPPORT\nsin is fully supported in all profiles unless otherwise specified.\nsin is supported via an approximation (shown above) in the vs_1, vp20, and arbvp1 profiles.\nsin is unsupported in the fp20, ps_1_1, ps_1_2, and ps_1_3 profiles.\n\n\nSEE ALSO\nasin, cos, dot, frac, tan\n' )
end

function cg_sin_1:new()
	Node.new(self)
	self.name = 'sin'
	self.in_a = self.add_port(Input('a'))
	self.out = self.add_port(Output('out'))
end

function cg_sin_1:get_type(port)

	local type_a = self.in_a.get_output().get_type()
	if ((type_a == 'float')) then
		return 'float'
	end
	if ((type_a == 'float1')) then
		return 'float1'
	end
	if ((type_a == 'float2')) then
		return 'float2'
	end
	if ((type_a == 'float3')) then
		return 'float3'
	end
	if ((type_a == 'float4')) then
		return 'float4'
	end
	if ((type_a == 'half')) then
		return 'half'
	end
	if ((type_a == 'half1')) then
		return 'half1'
	end
	if ((type_a == 'half2')) then
		return 'half2'
	end
	if ((type_a == 'half3')) then
		return 'half3'
	end
	if ((type_a == 'half4')) then
		return 'half4'
	end
	if ((type_a == 'fixed')) then
		return 'fixed'
	end
	if ((type_a == 'fixed1')) then
		return 'fixed1'
	end
	if ((type_a == 'fixed2')) then
		return 'fixed2'
	end
	if ((type_a == 'fixed3')) then
		return 'fixed3'
	end
	if ((type_a == 'fixed4')) then
		return 'fixed4'
	end
	return nil
end

function cg_sin_1:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_sin_1:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_a = 'r' .. self.in_a.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = sin( ' .. in_a.. ' );\n')
end

function cg_sin_1:get_tip(out)
	out.write( 'sin - returns sine of scalars and vectors. ' )
end

-- #################################################### --
-- sinh( a )
-- #################################################### --
local cg_sinh_1 = class(Node)
function cg_sinh_1:get_help(out)
	out.write( '\n\nNAME\nsinh - returns hyperbolic sine of scalars and vectors.\n\n\nSYNOPSIS\nfloat sinh(float a);\nfloat1 sinh(float1 a);\nfloat2 sinh(float2 a);\nfloat3 sinh(float3 a);\nfloat4 sinh(float4 a);\nhalf sinh(half a);\nhalf1 sinh(half1 a);\nhalf2 sinh(half2 a);\nhalf3 sinh(half3 a);\nhalf4 sinh(half4 a);\nfixed sinh(fixed a);\nfixed1 sinh(fixed1 a);\nfixed2 sinh(fixed2 a);\nfixed3 sinh(fixed3 a);\nfixed4 sinh(fixed4 a);\n\n\nPARAMETERS\na Vector or scalar of which to determine the hyperbolic sine.\n\n\nDESCRIPTION\nReturns the hyperbolic sine of a.\nFor vectors, the returned vector contains the hyperbolic sine of each element of the input vector.\n\n\nREFERENCE IMPLEMENTATION\nsinh for a scalar float could be implemented like this.\nfloat sinh(float x)\n{\nreturn 0.5 * (exp(x)-exp(-x));\n}\n\n\nPROFILE SUPPORT\nsinh is supported in all profiles except fp20.\n\n\nSEE ALSO\nacos, cos, cosh, exp, tanh\n' )
end

function cg_sinh_1:new()
	Node.new(self)
	self.name = 'sinh'
	self.in_a = self.add_port(Input('a'))
	self.out = self.add_port(Output('out'))
end

function cg_sinh_1:get_type(port)

	local type_a = self.in_a.get_output().get_type()
	if ((type_a == 'float')) then
		return 'float'
	end
	if ((type_a == 'float1')) then
		return 'float1'
	end
	if ((type_a == 'float2')) then
		return 'float2'
	end
	if ((type_a == 'float3')) then
		return 'float3'
	end
	if ((type_a == 'float4')) then
		return 'float4'
	end
	if ((type_a == 'half')) then
		return 'half'
	end
	if ((type_a == 'half1')) then
		return 'half1'
	end
	if ((type_a == 'half2')) then
		return 'half2'
	end
	if ((type_a == 'half3')) then
		return 'half3'
	end
	if ((type_a == 'half4')) then
		return 'half4'
	end
	if ((type_a == 'fixed')) then
		return 'fixed'
	end
	if ((type_a == 'fixed1')) then
		return 'fixed1'
	end
	if ((type_a == 'fixed2')) then
		return 'fixed2'
	end
	if ((type_a == 'fixed3')) then
		return 'fixed3'
	end
	if ((type_a == 'fixed4')) then
		return 'fixed4'
	end
	return nil
end

function cg_sinh_1:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_sinh_1:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_a = 'r' .. self.in_a.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = sinh( ' .. in_a.. ' );\n')
end

function cg_sinh_1:get_tip(out)
	out.write( 'sinh - returns hyperbolic sine of scalars and vectors. ' )
end

-- #################################################### --
-- sqrt( a )
-- #################################################### --
local cg_sqrt_1 = class(Node)
function cg_sqrt_1:get_help(out)
	out.write( '\n\nNAME\nsqrt - returns the square root of a scalar or each vector component.\n\n\nSYNOPSIS\nfloat sqrt(float a);\nfloat1 sqrt(float1 a);\nfloat2 sqrt(float2 a);\nfloat3 sqrt(float3 a);\nfloat4 sqrt(float4 a);\nhalf sqrt(half a);\nhalf1 sqrt(half1 a);\nhalf2 sqrt(half2 a);\nhalf3 sqrt(half3 a);\nhalf4 sqrt(half4 a);\nfixed sqrt(fixed a);\nfixed1 sqrt(fixed1 a);\nfixed2 sqrt(fixed2 a);\nfixed3 sqrt(fixed3 a);\nfixed4 sqrt(fixed4 a);\n\n\nPARAMETERS\na Vector or scalar of which to return the square root.\n\n\nDESCRIPTION\nReturns the square root of a scalar or each vector component.\n\n\nREFERENCE IMPLEMENTATION\n(Missing)\n\n\nPROFILE SUPPORT\n(Missing)\n\n\nSEE ALSO\n(Missing)\n' )
end

function cg_sqrt_1:new()
	Node.new(self)
	self.name = 'sqrt'
	self.in_a = self.add_port(Input('a'))
	self.out = self.add_port(Output('out'))
end

function cg_sqrt_1:get_type(port)

	local type_a = self.in_a.get_output().get_type()
	if ((type_a == 'float')) then
		return 'float'
	end
	if ((type_a == 'float1')) then
		return 'float1'
	end
	if ((type_a == 'float2')) then
		return 'float2'
	end
	if ((type_a == 'float3')) then
		return 'float3'
	end
	if ((type_a == 'float4')) then
		return 'float4'
	end
	if ((type_a == 'half')) then
		return 'half'
	end
	if ((type_a == 'half1')) then
		return 'half1'
	end
	if ((type_a == 'half2')) then
		return 'half2'
	end
	if ((type_a == 'half3')) then
		return 'half3'
	end
	if ((type_a == 'half4')) then
		return 'half4'
	end
	if ((type_a == 'fixed')) then
		return 'fixed'
	end
	if ((type_a == 'fixed1')) then
		return 'fixed1'
	end
	if ((type_a == 'fixed2')) then
		return 'fixed2'
	end
	if ((type_a == 'fixed3')) then
		return 'fixed3'
	end
	if ((type_a == 'fixed4')) then
		return 'fixed4'
	end
	return nil
end

function cg_sqrt_1:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_sqrt_1:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_a = 'r' .. self.in_a.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = sqrt( ' .. in_a.. ' );\n')
end

function cg_sqrt_1:get_tip(out)
	out.write( 'sqrt - returns the square root of a scalar or each vector component. ' )
end

-- #################################################### --
-- tan( a )
-- #################################################### --
local cg_tan_1 = class(Node)
function cg_tan_1:get_help(out)
	out.write( '\n\nNAME\ntan - returns tangent of scalars and vectors.\n\n\nSYNOPSIS\nfloat tan(float a);\nfloat1 tan(float1 a);\nfloat2 tan(float2 a);\nfloat3 tan(float3 a);\nfloat4 tan(float4 a);\nhalf tan(half a);\nhalf1 tan(half1 a);\nhalf2 tan(half2 a);\nhalf3 tan(half3 a);\nhalf4 tan(half4 a);\nfixed tan(fixed a);\nfixed1 tan(fixed1 a);\nfixed2 tan(fixed2 a);\nfixed3 tan(fixed3 a);\nfixed4 tan(fixed4 a);\n\n\nPARAMETERS\na Vector or scalar of which to determine the tangent.\n\n\nDESCRIPTION\nReturns the tangent of a in radians.\nFor vectors, the returned vector contains the tangent of each element of the input vector.\n\n\nREFERENCE IMPLEMENTATION\ntan can be implemented in terms of the sin and cos functions like this:\nfloat tan(float a) {\nfloat s, c;\nsincos(a, s, c);\nreturn s / c;\n}\n\n\nPROFILE SUPPORT\ntan is fully supported in all profiles unless otherwise specified.\ntan is supported via approximations of sin and cos functions (see the respective sin and cos manual pages\nfor details) in the vs_1, vp20, and arbvp1 profiles.\ntan is unsupported in the fp20, ps_1_1, ps_1_2, and ps_1_3 profiles.\n\n\nSEE ALSO\natan, atan2, cos, dot, frac, sin, sincos\n' )
end

function cg_tan_1:new()
	Node.new(self)
	self.name = 'tan'
	self.in_a = self.add_port(Input('a'))
	self.out = self.add_port(Output('out'))
end

function cg_tan_1:get_type(port)

	local type_a = self.in_a.get_output().get_type()
	if ((type_a == 'float')) then
		return 'float'
	end
	if ((type_a == 'float1')) then
		return 'float1'
	end
	if ((type_a == 'float2')) then
		return 'float2'
	end
	if ((type_a == 'float3')) then
		return 'float3'
	end
	if ((type_a == 'float4')) then
		return 'float4'
	end
	if ((type_a == 'half')) then
		return 'half'
	end
	if ((type_a == 'half1')) then
		return 'half1'
	end
	if ((type_a == 'half2')) then
		return 'half2'
	end
	if ((type_a == 'half3')) then
		return 'half3'
	end
	if ((type_a == 'half4')) then
		return 'half4'
	end
	if ((type_a == 'fixed')) then
		return 'fixed'
	end
	if ((type_a == 'fixed1')) then
		return 'fixed1'
	end
	if ((type_a == 'fixed2')) then
		return 'fixed2'
	end
	if ((type_a == 'fixed3')) then
		return 'fixed3'
	end
	if ((type_a == 'fixed4')) then
		return 'fixed4'
	end
	return nil
end

function cg_tan_1:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_tan_1:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_a = 'r' .. self.in_a.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = tan( ' .. in_a.. ' );\n')
end

function cg_tan_1:get_tip(out)
	out.write( 'tan - returns tangent of scalars and vectors. ' )
end

-- #################################################### --
-- tanh( a )
-- #################################################### --
local cg_tanh_1 = class(Node)
function cg_tanh_1:get_help(out)
	out.write( '\n\nNAME\ntanh - returns hyperbolic tangent of scalars and vectors.\n\n\nSYNOPSIS\nfloat tanh(float a);\nfloat1 tanh(float1 a);\nfloat2 tanh(float2 a);\nfloat3 tanh(float3 a);\nfloat4 tanh(float4 a);\nhalf tanh(half a);\nhalf1 tanh(half1 a);\nhalf2 tanh(half2 a);\nhalf3 tanh(half3 a);\nhalf4 tanh(half4 a);\nfixed tanh(fixed a);\nfixed1 tanh(fixed1 a);\nfixed2 tanh(fixed2 a);\nfixed3 tanh(fixed3 a);\nfixed4 tanh(fixed4 a);\n\n\nPARAMETERS\na Vector or scalar of which to determine the hyperbolic tangent.\n\n\nDESCRIPTION\nReturns the hyperbolic tangent of a.\nFor vectors, the returned vector contains the hyperbolic tangent of each element of the input vector.\n\n\nREFERENCE IMPLEMENTATION\ntanh for a scalar float could be implemented like this.\nfloat tanh(float x)\n{\nfloat exp2x = exp(2*x);\nreturn (exp2x - 1) / (exp2x + 1);\n}\n\n\nPROFILE SUPPORT\ntanh is supported in all profiles except fp20.\n\n\nSEE ALSO\natan, atan2, cosh, exp, sinh, tan\n' )
end

function cg_tanh_1:new()
	Node.new(self)
	self.name = 'tanh'
	self.in_a = self.add_port(Input('a'))
	self.out = self.add_port(Output('out'))
end

function cg_tanh_1:get_type(port)

	local type_a = self.in_a.get_output().get_type()
	if ((type_a == 'float')) then
		return 'float'
	end
	if ((type_a == 'float1')) then
		return 'float1'
	end
	if ((type_a == 'float2')) then
		return 'float2'
	end
	if ((type_a == 'float3')) then
		return 'float3'
	end
	if ((type_a == 'float4')) then
		return 'float4'
	end
	if ((type_a == 'half')) then
		return 'half'
	end
	if ((type_a == 'half1')) then
		return 'half1'
	end
	if ((type_a == 'half2')) then
		return 'half2'
	end
	if ((type_a == 'half3')) then
		return 'half3'
	end
	if ((type_a == 'half4')) then
		return 'half4'
	end
	if ((type_a == 'fixed')) then
		return 'fixed'
	end
	if ((type_a == 'fixed1')) then
		return 'fixed1'
	end
	if ((type_a == 'fixed2')) then
		return 'fixed2'
	end
	if ((type_a == 'fixed3')) then
		return 'fixed3'
	end
	if ((type_a == 'fixed4')) then
		return 'fixed4'
	end
	return nil
end

function cg_tanh_1:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_tanh_1:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_a = 'r' .. self.in_a.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = tanh( ' .. in_a.. ' );\n')
end

function cg_tanh_1:get_tip(out)
	out.write( 'tanh - returns hyperbolic tangent of scalars and vectors. ' )
end

-- #################################################### --
-- tex1D( samp, s )
-- #################################################### --
local cg_tex1D_2 = class(Node)
function cg_tex1D_2:get_help(out)
	out.write( '\n\nNAME\ntex1D - performs a texture lookup in a given 1D sampler and, in some cases, a shadow comparison. May\nalso use pre computed derivatives if those are provided.\n\n\nSYNOPSIS\nfloat4 tex1D(sampler1D samp, float s)\nfloat4 tex1D(sampler1D samp, float s, int texelOff)\nfloat4 tex1D(sampler1D samp, float2 s)\nfloat4 tex1D(sampler1D samp, float2 s, int texelOff)\nfloat4 tex1D(sampler1D samp, float s, float dx, float dy)\nfloat4 tex1D(sampler1D samp, float s, float dx, float dy, int texelOff)\nfloat4 tex1D(sampler1D samp, float2 s, float dx, float dy)\nfloat4 tex1D(sampler1D samp, float2 s, float dx, float dy, int texelOff)\nint4 tex1D(isampler1D samp, float s);\nint4 tex1D(isampler1D samp, float s, int texelOff);\nint4 tex1D(isampler1D samp, float s, float dx, float dy)\nint4 tex1D(isampler1D samp, float s, float dx, float dy, int texelOff)\nuint4 tex1D(usampler1D samp, float s);\nuint4 tex1D(usampler1D samp, float s, int texelOff);\nuint4 tex1D(usampler1D samp, float s, float dx, float dy)\nuint4 tex1D(usampler1D samp, float s, float dx, float dy,int texelOff)\n\n\nPARAMETERS\nsamp Sampler to lookup.\ns Coordinates to perform the lookup. If an extra coordinate compared to the texture dimensionality\nis present it is used to perform a shadow comparison. The value used in the shadow comparison is\nalways the last component of the coordinate vector.\ndx Pre computed derivative along the x axis.\ndy Pre computed derivative along the y axis.\ntexelOff Offset to be added to obtain the final texel.\n\n\nDESCRIPTION\nPerforms a texture lookup in sampler samp using coordinates s, may use and derivatives dx and dy, also\nmay perform shadow comparison and use texel offset texelOff to compute final texel.\n\n\nPROFILE SUPPORT\ntex1D is supported in all fragment profiles and all vertex profiles starting with vp40, variants with shadow\ncomparison are only supported in fp40 and newer profiles, variants with texel offsets are only supported in\ngp4 and newer profiles, variants with integer textures are also only supported in gp4 and newer profiles.\n\n\nSEE ALSO\ntex1Dbias, tex1Dlod, tex1Dproj\n' )
end

function cg_tex1D_2:new()
	Node.new(self)
	self.name = 'tex1D'
	self.in_samp = self.add_port(Input('samp'))
	self.in_s = self.add_port(Input('s'))
	self.out = self.add_port(Output('out'))
end

function cg_tex1D_2:get_type(port)

	local type_samp = self.in_samp.get_output().get_type()
	local type_s = self.in_s.get_output().get_type()
	if ((type_samp == 'sampler1D')
	and (type_s == 'float')) then
		return 'float4'
	end
	if ((type_samp == 'sampler1D')
	and (type_s == 'float2')) then
		return 'float4'
	end
	if ((type_samp == 'isampler1D')
	and (type_s == 'float')) then
		return 'int4'
	end
	if ((type_samp == 'usampler1D')
	and (type_s == 'float')) then
		return 'uint4'
	end
	return nil
end

function cg_tex1D_2:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_tex1D_2:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_samp = 'r' .. self.in_samp.get_output().hex()
	local in_s = 'r' .. self.in_s.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = tex1D( ' .. in_samp.. ', ' .. in_s.. ' );\n')
end

function cg_tex1D_2:get_tip(out)
	out.write( 'tex1D - performs a texture lookup in a given 1D sampler and, in some cases, a shadow comparison. May also use pre computed derivatives if those are provided. ' )
end

-- #################################################### --
-- tex1D( samp, s, texelOff )
-- #################################################### --
local cg_tex1D_3 = class(Node)
function cg_tex1D_3:get_help(out)
	out.write( '\n\nNAME\ntex1D - performs a texture lookup in a given 1D sampler and, in some cases, a shadow comparison. May\nalso use pre computed derivatives if those are provided.\n\n\nSYNOPSIS\nfloat4 tex1D(sampler1D samp, float s)\nfloat4 tex1D(sampler1D samp, float s, int texelOff)\nfloat4 tex1D(sampler1D samp, float2 s)\nfloat4 tex1D(sampler1D samp, float2 s, int texelOff)\nfloat4 tex1D(sampler1D samp, float s, float dx, float dy)\nfloat4 tex1D(sampler1D samp, float s, float dx, float dy, int texelOff)\nfloat4 tex1D(sampler1D samp, float2 s, float dx, float dy)\nfloat4 tex1D(sampler1D samp, float2 s, float dx, float dy, int texelOff)\nint4 tex1D(isampler1D samp, float s);\nint4 tex1D(isampler1D samp, float s, int texelOff);\nint4 tex1D(isampler1D samp, float s, float dx, float dy)\nint4 tex1D(isampler1D samp, float s, float dx, float dy, int texelOff)\nuint4 tex1D(usampler1D samp, float s);\nuint4 tex1D(usampler1D samp, float s, int texelOff);\nuint4 tex1D(usampler1D samp, float s, float dx, float dy)\nuint4 tex1D(usampler1D samp, float s, float dx, float dy,int texelOff)\n\n\nPARAMETERS\nsamp Sampler to lookup.\ns Coordinates to perform the lookup. If an extra coordinate compared to the texture dimensionality\nis present it is used to perform a shadow comparison. The value used in the shadow comparison is\nalways the last component of the coordinate vector.\ndx Pre computed derivative along the x axis.\ndy Pre computed derivative along the y axis.\ntexelOff Offset to be added to obtain the final texel.\n\n\nDESCRIPTION\nPerforms a texture lookup in sampler samp using coordinates s, may use and derivatives dx and dy, also\nmay perform shadow comparison and use texel offset texelOff to compute final texel.\n\n\nPROFILE SUPPORT\ntex1D is supported in all fragment profiles and all vertex profiles starting with vp40, variants with shadow\ncomparison are only supported in fp40 and newer profiles, variants with texel offsets are only supported in\ngp4 and newer profiles, variants with integer textures are also only supported in gp4 and newer profiles.\n\n\nSEE ALSO\ntex1Dbias, tex1Dlod, tex1Dproj\n' )
end

function cg_tex1D_3:new()
	Node.new(self)
	self.name = 'tex1D'
	self.in_samp = self.add_port(Input('samp'))
	self.in_s = self.add_port(Input('s'))
	self.in_texelOff = self.add_port(Input('texelOff'))
	self.out = self.add_port(Output('out'))
end

function cg_tex1D_3:get_type(port)

	local type_samp = self.in_samp.get_output().get_type()
	local type_s = self.in_s.get_output().get_type()
	local type_texelOff = self.in_texelOff.get_output().get_type()
	if ((type_samp == 'sampler1D')
	and (type_s == 'float')
	and (type_texelOff == 'int')) then
		return 'float4'
	end
	if ((type_samp == 'sampler1D')
	and (type_s == 'float2')
	and (type_texelOff == 'int')) then
		return 'float4'
	end
	if ((type_samp == 'isampler1D')
	and (type_s == 'float')
	and (type_texelOff == 'int')) then
		return 'int4'
	end
	if ((type_samp == 'usampler1D')
	and (type_s == 'float')
	and (type_texelOff == 'int')) then
		return 'uint4'
	end
	return nil
end

function cg_tex1D_3:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_tex1D_3:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_samp = 'r' .. self.in_samp.get_output().hex()
	local in_s = 'r' .. self.in_s.get_output().hex()
	local in_texelOff = 'r' .. self.in_texelOff.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = tex1D( ' .. in_samp.. ', ' .. in_s.. ', ' .. in_texelOff.. ' );\n')
end

function cg_tex1D_3:get_tip(out)
	out.write( 'tex1D - performs a texture lookup in a given 1D sampler and, in some cases, a shadow comparison. May also use pre computed derivatives if those are provided. ' )
end

-- #################################################### --
-- tex1D( samp, s, dx, dy )
-- #################################################### --
local cg_tex1D_4 = class(Node)
function cg_tex1D_4:get_help(out)
	out.write( '\n\nNAME\ntex1D - performs a texture lookup in a given 1D sampler and, in some cases, a shadow comparison. May\nalso use pre computed derivatives if those are provided.\n\n\nSYNOPSIS\nfloat4 tex1D(sampler1D samp, float s)\nfloat4 tex1D(sampler1D samp, float s, int texelOff)\nfloat4 tex1D(sampler1D samp, float2 s)\nfloat4 tex1D(sampler1D samp, float2 s, int texelOff)\nfloat4 tex1D(sampler1D samp, float s, float dx, float dy)\nfloat4 tex1D(sampler1D samp, float s, float dx, float dy, int texelOff)\nfloat4 tex1D(sampler1D samp, float2 s, float dx, float dy)\nfloat4 tex1D(sampler1D samp, float2 s, float dx, float dy, int texelOff)\nint4 tex1D(isampler1D samp, float s);\nint4 tex1D(isampler1D samp, float s, int texelOff);\nint4 tex1D(isampler1D samp, float s, float dx, float dy)\nint4 tex1D(isampler1D samp, float s, float dx, float dy, int texelOff)\nuint4 tex1D(usampler1D samp, float s);\nuint4 tex1D(usampler1D samp, float s, int texelOff);\nuint4 tex1D(usampler1D samp, float s, float dx, float dy)\nuint4 tex1D(usampler1D samp, float s, float dx, float dy,int texelOff)\n\n\nPARAMETERS\nsamp Sampler to lookup.\ns Coordinates to perform the lookup. If an extra coordinate compared to the texture dimensionality\nis present it is used to perform a shadow comparison. The value used in the shadow comparison is\nalways the last component of the coordinate vector.\ndx Pre computed derivative along the x axis.\ndy Pre computed derivative along the y axis.\ntexelOff Offset to be added to obtain the final texel.\n\n\nDESCRIPTION\nPerforms a texture lookup in sampler samp using coordinates s, may use and derivatives dx and dy, also\nmay perform shadow comparison and use texel offset texelOff to compute final texel.\n\n\nPROFILE SUPPORT\ntex1D is supported in all fragment profiles and all vertex profiles starting with vp40, variants with shadow\ncomparison are only supported in fp40 and newer profiles, variants with texel offsets are only supported in\ngp4 and newer profiles, variants with integer textures are also only supported in gp4 and newer profiles.\n\n\nSEE ALSO\ntex1Dbias, tex1Dlod, tex1Dproj\n' )
end

function cg_tex1D_4:new()
	Node.new(self)
	self.name = 'tex1D'
	self.in_samp = self.add_port(Input('samp'))
	self.in_s = self.add_port(Input('s'))
	self.in_dx = self.add_port(Input('dx'))
	self.in_dy = self.add_port(Input('dy'))
	self.out = self.add_port(Output('out'))
end

function cg_tex1D_4:get_type(port)

	local type_samp = self.in_samp.get_output().get_type()
	local type_s = self.in_s.get_output().get_type()
	local type_dx = self.in_dx.get_output().get_type()
	local type_dy = self.in_dy.get_output().get_type()
	if ((type_samp == 'sampler1D')
	and (type_s == 'float')
	and (type_dx == 'float')
	and (type_dy == 'float')) then
		return 'float4'
	end
	if ((type_samp == 'sampler1D')
	and (type_s == 'float2')
	and (type_dx == 'float')
	and (type_dy == 'float')) then
		return 'float4'
	end
	if ((type_samp == 'isampler1D')
	and (type_s == 'float')
	and (type_dx == 'float')
	and (type_dy == 'float')) then
		return 'int4'
	end
	if ((type_samp == 'usampler1D')
	and (type_s == 'float')
	and (type_dx == 'float')
	and (type_dy == 'float')) then
		return 'uint4'
	end
	return nil
end

function cg_tex1D_4:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_tex1D_4:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_samp = 'r' .. self.in_samp.get_output().hex()
	local in_s = 'r' .. self.in_s.get_output().hex()
	local in_dx = 'r' .. self.in_dx.get_output().hex()
	local in_dy = 'r' .. self.in_dy.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = tex1D( ' .. in_samp.. ', ' .. in_s.. ', ' .. in_dx.. ', ' .. in_dy.. ' );\n')
end

function cg_tex1D_4:get_tip(out)
	out.write( 'tex1D - performs a texture lookup in a given 1D sampler and, in some cases, a shadow comparison. May also use pre computed derivatives if those are provided. ' )
end

-- #################################################### --
-- tex1D( samp, s, dx, dy, texelOff )
-- #################################################### --
local cg_tex1D_5 = class(Node)
function cg_tex1D_5:get_help(out)
	out.write( '\n\nNAME\ntex1D - performs a texture lookup in a given 1D sampler and, in some cases, a shadow comparison. May\nalso use pre computed derivatives if those are provided.\n\n\nSYNOPSIS\nfloat4 tex1D(sampler1D samp, float s)\nfloat4 tex1D(sampler1D samp, float s, int texelOff)\nfloat4 tex1D(sampler1D samp, float2 s)\nfloat4 tex1D(sampler1D samp, float2 s, int texelOff)\nfloat4 tex1D(sampler1D samp, float s, float dx, float dy)\nfloat4 tex1D(sampler1D samp, float s, float dx, float dy, int texelOff)\nfloat4 tex1D(sampler1D samp, float2 s, float dx, float dy)\nfloat4 tex1D(sampler1D samp, float2 s, float dx, float dy, int texelOff)\nint4 tex1D(isampler1D samp, float s);\nint4 tex1D(isampler1D samp, float s, int texelOff);\nint4 tex1D(isampler1D samp, float s, float dx, float dy)\nint4 tex1D(isampler1D samp, float s, float dx, float dy, int texelOff)\nuint4 tex1D(usampler1D samp, float s);\nuint4 tex1D(usampler1D samp, float s, int texelOff);\nuint4 tex1D(usampler1D samp, float s, float dx, float dy)\nuint4 tex1D(usampler1D samp, float s, float dx, float dy,int texelOff)\n\n\nPARAMETERS\nsamp Sampler to lookup.\ns Coordinates to perform the lookup. If an extra coordinate compared to the texture dimensionality\nis present it is used to perform a shadow comparison. The value used in the shadow comparison is\nalways the last component of the coordinate vector.\ndx Pre computed derivative along the x axis.\ndy Pre computed derivative along the y axis.\ntexelOff Offset to be added to obtain the final texel.\n\n\nDESCRIPTION\nPerforms a texture lookup in sampler samp using coordinates s, may use and derivatives dx and dy, also\nmay perform shadow comparison and use texel offset texelOff to compute final texel.\n\n\nPROFILE SUPPORT\ntex1D is supported in all fragment profiles and all vertex profiles starting with vp40, variants with shadow\ncomparison are only supported in fp40 and newer profiles, variants with texel offsets are only supported in\ngp4 and newer profiles, variants with integer textures are also only supported in gp4 and newer profiles.\n\n\nSEE ALSO\ntex1Dbias, tex1Dlod, tex1Dproj\n' )
end

function cg_tex1D_5:new()
	Node.new(self)
	self.name = 'tex1D'
	self.in_samp = self.add_port(Input('samp'))
	self.in_s = self.add_port(Input('s'))
	self.in_dx = self.add_port(Input('dx'))
	self.in_dy = self.add_port(Input('dy'))
	self.in_texelOff = self.add_port(Input('texelOff'))
	self.out = self.add_port(Output('out'))
end

function cg_tex1D_5:get_type(port)

	local type_samp = self.in_samp.get_output().get_type()
	local type_s = self.in_s.get_output().get_type()
	local type_dx = self.in_dx.get_output().get_type()
	local type_dy = self.in_dy.get_output().get_type()
	local type_texelOff = self.in_texelOff.get_output().get_type()
	if ((type_samp == 'sampler1D')
	and (type_s == 'float')
	and (type_dx == 'float')
	and (type_dy == 'float')
	and (type_texelOff == 'int')) then
		return 'float4'
	end
	if ((type_samp == 'sampler1D')
	and (type_s == 'float2')
	and (type_dx == 'float')
	and (type_dy == 'float')
	and (type_texelOff == 'int')) then
		return 'float4'
	end
	if ((type_samp == 'isampler1D')
	and (type_s == 'float')
	and (type_dx == 'float')
	and (type_dy == 'float')
	and (type_texelOff == 'int')) then
		return 'int4'
	end
	if ((type_samp == 'usampler1D')
	and (type_s == 'float')
	and (type_dx == 'float')
	and (type_dy == 'float')
	and (type_texelOff == 'int')) then
		return 'uint4'
	end
	return nil
end

function cg_tex1D_5:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_tex1D_5:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_samp = 'r' .. self.in_samp.get_output().hex()
	local in_s = 'r' .. self.in_s.get_output().hex()
	local in_dx = 'r' .. self.in_dx.get_output().hex()
	local in_dy = 'r' .. self.in_dy.get_output().hex()
	local in_texelOff = 'r' .. self.in_texelOff.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = tex1D( ' .. in_samp.. ', ' .. in_s.. ', ' .. in_dx.. ', ' .. in_dy.. ', ' .. in_texelOff.. ' );\n')
end

function cg_tex1D_5:get_tip(out)
	out.write( 'tex1D - performs a texture lookup in a given 1D sampler and, in some cases, a shadow comparison. May also use pre computed derivatives if those are provided. ' )
end

-- #################################################### --
-- tex1DARRAY( samp, s )
-- #################################################### --
local cg_tex1DARRAY_2 = class(Node)
function cg_tex1DARRAY_2:get_help(out)
	out.write( '\n\nNAME\ntex1DARRAY - performs a texture lookup in a given sampler array may use pre computed derivatives and,\nin some cases, perform a shadow comparison.\n\n\nSYNOPSIS\nfloat4 tex1DARRAY(sampler1DARRAY samp, float2 s)\nfloat4 tex1DARRAY(sampler1DARRAY samp, float2 s, int texelOff)\nfloat4 tex1DARRAY(sampler1DARRAY samp, float3 s)\nfloat4 tex1DARRAY(sampler1DARRAY samp, float3 s, int texelOff)\nfloat4 tex1DARRAY(sampler1DARRAY samp, float2 s, float dx, float dy)\nfloat4 tex1DARRAY(sampler1DARRAY samp, float2 s, float dx, float dy,\nint texelOff)\nfloat4 tex1DARRAY(sampler1DARRAY samp, float3 s, float dx, float dy)\nfloat4 tex1DARRAY(sampler1DARRAY samp, float3 s, float dx, float dy,\nint texelOff)\nint4 tex1DARRAY(isampler1DARRAY samp, float2 s)\nint4 tex1DARRAY(isampler1DARRAY samp, float2 s, int texelOff)\nint4 tex1DARRAY(isampler1DARRAY samp, float2 s, float dx, float dy)\nint4 tex1DARRAY(isampler1DARRAY samp, float2 s, float dx, float dy,\nint texelOff)\nuint4 tex1DARRAY(usampler1DARRAY samp, float2 s)\nuint4 tex1DARRAY(usampler1DARRAY samp, float2 s, int texelOff)\nuint4 tex1DARRAY(usampler1DARRAY samp, float2 s, float dx, float dy)\nuint4 tex1DARRAY(usampler1DARRAY samp, float2 s, float dx, float dy,\nint texelOff)\n\n\nPARAMETERS\nsamp Sampler array to look up.\ns Coordinates to perform the lookup. The value used to select the layer is passed immediatelly after\nthe regular coordinates, if an extra coordinate is present it is used to perform a shadow\ncomparison.\ndx Pre computed derivative along the x axis.\ndy Pre computed derivative along the y axis.\ntexelOff Offset to be added to obtain the final texel.\n\n\nDESCRIPTION\nPerforms a texture lookup in sampler samp using coordinates s, the texture to be sampled is selected from\nthe layer specified in the coordinates. Also may use the derivatives dx and dy, the lookup may involve a\nshadow comparison and use texel offset texelOff to compute the final texel.\n\n\nPROFILE SUPPORT\ntex1DARRAY is only supported in gp4 and newer profiles.\n\n\nSEE ALSO\ntex1DARRAYbias, tex1DARRAYlod\n' )
end

function cg_tex1DARRAY_2:new()
	Node.new(self)
	self.name = 'tex1DARRAY'
	self.in_samp = self.add_port(Input('samp'))
	self.in_s = self.add_port(Input('s'))
	self.out = self.add_port(Output('out'))
end

function cg_tex1DARRAY_2:get_type(port)

	local type_samp = self.in_samp.get_output().get_type()
	local type_s = self.in_s.get_output().get_type()
	if ((type_samp == 'sampler1DARRAY')
	and (type_s == 'float2')) then
		return 'float4'
	end
	if ((type_samp == 'sampler1DARRAY')
	and (type_s == 'float3')) then
		return 'float4'
	end
	if ((type_samp == 'isampler1DARRAY')
	and (type_s == 'float2')) then
		return 'int4'
	end
	if ((type_samp == 'usampler1DARRAY')
	and (type_s == 'float2')) then
		return 'uint4'
	end
	return nil
end

function cg_tex1DARRAY_2:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_tex1DARRAY_2:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_samp = 'r' .. self.in_samp.get_output().hex()
	local in_s = 'r' .. self.in_s.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = tex1DARRAY( ' .. in_samp.. ', ' .. in_s.. ' );\n')
end

function cg_tex1DARRAY_2:get_tip(out)
	out.write( 'tex1DARRAY - performs a texture lookup in a given sampler array may use pre computed derivatives and, in some cases, perform a shadow comparison. ' )
end

-- #################################################### --
-- tex1DARRAY( samp, s, texelOff )
-- #################################################### --
local cg_tex1DARRAY_3 = class(Node)
function cg_tex1DARRAY_3:get_help(out)
	out.write( '\n\nNAME\ntex1DARRAY - performs a texture lookup in a given sampler array may use pre computed derivatives and,\nin some cases, perform a shadow comparison.\n\n\nSYNOPSIS\nfloat4 tex1DARRAY(sampler1DARRAY samp, float2 s)\nfloat4 tex1DARRAY(sampler1DARRAY samp, float2 s, int texelOff)\nfloat4 tex1DARRAY(sampler1DARRAY samp, float3 s)\nfloat4 tex1DARRAY(sampler1DARRAY samp, float3 s, int texelOff)\nfloat4 tex1DARRAY(sampler1DARRAY samp, float2 s, float dx, float dy)\nfloat4 tex1DARRAY(sampler1DARRAY samp, float2 s, float dx, float dy,\nint texelOff)\nfloat4 tex1DARRAY(sampler1DARRAY samp, float3 s, float dx, float dy)\nfloat4 tex1DARRAY(sampler1DARRAY samp, float3 s, float dx, float dy,\nint texelOff)\nint4 tex1DARRAY(isampler1DARRAY samp, float2 s)\nint4 tex1DARRAY(isampler1DARRAY samp, float2 s, int texelOff)\nint4 tex1DARRAY(isampler1DARRAY samp, float2 s, float dx, float dy)\nint4 tex1DARRAY(isampler1DARRAY samp, float2 s, float dx, float dy,\nint texelOff)\nuint4 tex1DARRAY(usampler1DARRAY samp, float2 s)\nuint4 tex1DARRAY(usampler1DARRAY samp, float2 s, int texelOff)\nuint4 tex1DARRAY(usampler1DARRAY samp, float2 s, float dx, float dy)\nuint4 tex1DARRAY(usampler1DARRAY samp, float2 s, float dx, float dy,\nint texelOff)\n\n\nPARAMETERS\nsamp Sampler array to look up.\ns Coordinates to perform the lookup. The value used to select the layer is passed immediatelly after\nthe regular coordinates, if an extra coordinate is present it is used to perform a shadow\ncomparison.\ndx Pre computed derivative along the x axis.\ndy Pre computed derivative along the y axis.\ntexelOff Offset to be added to obtain the final texel.\n\n\nDESCRIPTION\nPerforms a texture lookup in sampler samp using coordinates s, the texture to be sampled is selected from\nthe layer specified in the coordinates. Also may use the derivatives dx and dy, the lookup may involve a\nshadow comparison and use texel offset texelOff to compute the final texel.\n\n\nPROFILE SUPPORT\ntex1DARRAY is only supported in gp4 and newer profiles.\n\n\nSEE ALSO\ntex1DARRAYbias, tex1DARRAYlod\n' )
end

function cg_tex1DARRAY_3:new()
	Node.new(self)
	self.name = 'tex1DARRAY'
	self.in_samp = self.add_port(Input('samp'))
	self.in_s = self.add_port(Input('s'))
	self.in_texelOff = self.add_port(Input('texelOff'))
	self.out = self.add_port(Output('out'))
end

function cg_tex1DARRAY_3:get_type(port)

	local type_samp = self.in_samp.get_output().get_type()
	local type_s = self.in_s.get_output().get_type()
	local type_texelOff = self.in_texelOff.get_output().get_type()
	if ((type_samp == 'sampler1DARRAY')
	and (type_s == 'float2')
	and (type_texelOff == 'int')) then
		return 'float4'
	end
	if ((type_samp == 'sampler1DARRAY')
	and (type_s == 'float3')
	and (type_texelOff == 'int')) then
		return 'float4'
	end
	if ((type_samp == 'isampler1DARRAY')
	and (type_s == 'float2')
	and (type_texelOff == 'int')) then
		return 'int4'
	end
	if ((type_samp == 'usampler1DARRAY')
	and (type_s == 'float2')
	and (type_texelOff == 'int')) then
		return 'uint4'
	end
	return nil
end

function cg_tex1DARRAY_3:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_tex1DARRAY_3:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_samp = 'r' .. self.in_samp.get_output().hex()
	local in_s = 'r' .. self.in_s.get_output().hex()
	local in_texelOff = 'r' .. self.in_texelOff.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = tex1DARRAY( ' .. in_samp.. ', ' .. in_s.. ', ' .. in_texelOff.. ' );\n')
end

function cg_tex1DARRAY_3:get_tip(out)
	out.write( 'tex1DARRAY - performs a texture lookup in a given sampler array may use pre computed derivatives and, in some cases, perform a shadow comparison. ' )
end

-- #################################################### --
-- tex1DARRAY( samp, s, dx, dy )
-- #################################################### --
local cg_tex1DARRAY_4 = class(Node)
function cg_tex1DARRAY_4:get_help(out)
	out.write( '\n\nNAME\ntex1DARRAY - performs a texture lookup in a given sampler array may use pre computed derivatives and,\nin some cases, perform a shadow comparison.\n\n\nSYNOPSIS\nfloat4 tex1DARRAY(sampler1DARRAY samp, float2 s)\nfloat4 tex1DARRAY(sampler1DARRAY samp, float2 s, int texelOff)\nfloat4 tex1DARRAY(sampler1DARRAY samp, float3 s)\nfloat4 tex1DARRAY(sampler1DARRAY samp, float3 s, int texelOff)\nfloat4 tex1DARRAY(sampler1DARRAY samp, float2 s, float dx, float dy)\nfloat4 tex1DARRAY(sampler1DARRAY samp, float2 s, float dx, float dy,\nint texelOff)\nfloat4 tex1DARRAY(sampler1DARRAY samp, float3 s, float dx, float dy)\nfloat4 tex1DARRAY(sampler1DARRAY samp, float3 s, float dx, float dy,\nint texelOff)\nint4 tex1DARRAY(isampler1DARRAY samp, float2 s)\nint4 tex1DARRAY(isampler1DARRAY samp, float2 s, int texelOff)\nint4 tex1DARRAY(isampler1DARRAY samp, float2 s, float dx, float dy)\nint4 tex1DARRAY(isampler1DARRAY samp, float2 s, float dx, float dy,\nint texelOff)\nuint4 tex1DARRAY(usampler1DARRAY samp, float2 s)\nuint4 tex1DARRAY(usampler1DARRAY samp, float2 s, int texelOff)\nuint4 tex1DARRAY(usampler1DARRAY samp, float2 s, float dx, float dy)\nuint4 tex1DARRAY(usampler1DARRAY samp, float2 s, float dx, float dy,\nint texelOff)\n\n\nPARAMETERS\nsamp Sampler array to look up.\ns Coordinates to perform the lookup. The value used to select the layer is passed immediatelly after\nthe regular coordinates, if an extra coordinate is present it is used to perform a shadow\ncomparison.\ndx Pre computed derivative along the x axis.\ndy Pre computed derivative along the y axis.\ntexelOff Offset to be added to obtain the final texel.\n\n\nDESCRIPTION\nPerforms a texture lookup in sampler samp using coordinates s, the texture to be sampled is selected from\nthe layer specified in the coordinates. Also may use the derivatives dx and dy, the lookup may involve a\nshadow comparison and use texel offset texelOff to compute the final texel.\n\n\nPROFILE SUPPORT\ntex1DARRAY is only supported in gp4 and newer profiles.\n\n\nSEE ALSO\ntex1DARRAYbias, tex1DARRAYlod\n' )
end

function cg_tex1DARRAY_4:new()
	Node.new(self)
	self.name = 'tex1DARRAY'
	self.in_samp = self.add_port(Input('samp'))
	self.in_s = self.add_port(Input('s'))
	self.in_dx = self.add_port(Input('dx'))
	self.in_dy = self.add_port(Input('dy'))
	self.out = self.add_port(Output('out'))
end

function cg_tex1DARRAY_4:get_type(port)

	local type_samp = self.in_samp.get_output().get_type()
	local type_s = self.in_s.get_output().get_type()
	local type_dx = self.in_dx.get_output().get_type()
	local type_dy = self.in_dy.get_output().get_type()
	if ((type_samp == 'sampler1DARRAY')
	and (type_s == 'float2')
	and (type_dx == 'float')
	and (type_dy == 'float')) then
		return 'float4'
	end
	if ((type_samp == 'sampler1DARRAY')
	and (type_s == 'float3')
	and (type_dx == 'float')
	and (type_dy == 'float')) then
		return 'float4'
	end
	if ((type_samp == 'isampler1DARRAY')
	and (type_s == 'float2')
	and (type_dx == 'float')
	and (type_dy == 'float')) then
		return 'int4'
	end
	if ((type_samp == 'usampler1DARRAY')
	and (type_s == 'float2')
	and (type_dx == 'float')
	and (type_dy == 'float')) then
		return 'uint4'
	end
	return nil
end

function cg_tex1DARRAY_4:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_tex1DARRAY_4:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_samp = 'r' .. self.in_samp.get_output().hex()
	local in_s = 'r' .. self.in_s.get_output().hex()
	local in_dx = 'r' .. self.in_dx.get_output().hex()
	local in_dy = 'r' .. self.in_dy.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = tex1DARRAY( ' .. in_samp.. ', ' .. in_s.. ', ' .. in_dx.. ', ' .. in_dy.. ' );\n')
end

function cg_tex1DARRAY_4:get_tip(out)
	out.write( 'tex1DARRAY - performs a texture lookup in a given sampler array may use pre computed derivatives and, in some cases, perform a shadow comparison. ' )
end

-- #################################################### --
-- tex1DARRAY( samp, s, dx, dy, texelOff )
-- #################################################### --
local cg_tex1DARRAY_5 = class(Node)
function cg_tex1DARRAY_5:get_help(out)
	out.write( '\n\nNAME\ntex1DARRAY - performs a texture lookup in a given sampler array may use pre computed derivatives and,\nin some cases, perform a shadow comparison.\n\n\nSYNOPSIS\nfloat4 tex1DARRAY(sampler1DARRAY samp, float2 s)\nfloat4 tex1DARRAY(sampler1DARRAY samp, float2 s, int texelOff)\nfloat4 tex1DARRAY(sampler1DARRAY samp, float3 s)\nfloat4 tex1DARRAY(sampler1DARRAY samp, float3 s, int texelOff)\nfloat4 tex1DARRAY(sampler1DARRAY samp, float2 s, float dx, float dy)\nfloat4 tex1DARRAY(sampler1DARRAY samp, float2 s, float dx, float dy,\nint texelOff)\nfloat4 tex1DARRAY(sampler1DARRAY samp, float3 s, float dx, float dy)\nfloat4 tex1DARRAY(sampler1DARRAY samp, float3 s, float dx, float dy,\nint texelOff)\nint4 tex1DARRAY(isampler1DARRAY samp, float2 s)\nint4 tex1DARRAY(isampler1DARRAY samp, float2 s, int texelOff)\nint4 tex1DARRAY(isampler1DARRAY samp, float2 s, float dx, float dy)\nint4 tex1DARRAY(isampler1DARRAY samp, float2 s, float dx, float dy,\nint texelOff)\nuint4 tex1DARRAY(usampler1DARRAY samp, float2 s)\nuint4 tex1DARRAY(usampler1DARRAY samp, float2 s, int texelOff)\nuint4 tex1DARRAY(usampler1DARRAY samp, float2 s, float dx, float dy)\nuint4 tex1DARRAY(usampler1DARRAY samp, float2 s, float dx, float dy,\nint texelOff)\n\n\nPARAMETERS\nsamp Sampler array to look up.\ns Coordinates to perform the lookup. The value used to select the layer is passed immediatelly after\nthe regular coordinates, if an extra coordinate is present it is used to perform a shadow\ncomparison.\ndx Pre computed derivative along the x axis.\ndy Pre computed derivative along the y axis.\ntexelOff Offset to be added to obtain the final texel.\n\n\nDESCRIPTION\nPerforms a texture lookup in sampler samp using coordinates s, the texture to be sampled is selected from\nthe layer specified in the coordinates. Also may use the derivatives dx and dy, the lookup may involve a\nshadow comparison and use texel offset texelOff to compute the final texel.\n\n\nPROFILE SUPPORT\ntex1DARRAY is only supported in gp4 and newer profiles.\n\n\nSEE ALSO\ntex1DARRAYbias, tex1DARRAYlod\n' )
end

function cg_tex1DARRAY_5:new()
	Node.new(self)
	self.name = 'tex1DARRAY'
	self.in_samp = self.add_port(Input('samp'))
	self.in_s = self.add_port(Input('s'))
	self.in_dx = self.add_port(Input('dx'))
	self.in_dy = self.add_port(Input('dy'))
	self.in_texelOff = self.add_port(Input('texelOff'))
	self.out = self.add_port(Output('out'))
end

function cg_tex1DARRAY_5:get_type(port)

	local type_samp = self.in_samp.get_output().get_type()
	local type_s = self.in_s.get_output().get_type()
	local type_dx = self.in_dx.get_output().get_type()
	local type_dy = self.in_dy.get_output().get_type()
	local type_texelOff = self.in_texelOff.get_output().get_type()
	if ((type_samp == 'sampler1DARRAY')
	and (type_s == 'float2')
	and (type_dx == 'float')
	and (type_dy == 'float')
	and (type_texelOff == 'int')) then
		return 'float4'
	end
	if ((type_samp == 'sampler1DARRAY')
	and (type_s == 'float3')
	and (type_dx == 'float')
	and (type_dy == 'float')
	and (type_texelOff == 'int')) then
		return 'float4'
	end
	if ((type_samp == 'isampler1DARRAY')
	and (type_s == 'float2')
	and (type_dx == 'float')
	and (type_dy == 'float')
	and (type_texelOff == 'int')) then
		return 'int4'
	end
	if ((type_samp == 'usampler1DARRAY')
	and (type_s == 'float2')
	and (type_dx == 'float')
	and (type_dy == 'float')
	and (type_texelOff == 'int')) then
		return 'uint4'
	end
	return nil
end

function cg_tex1DARRAY_5:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_tex1DARRAY_5:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_samp = 'r' .. self.in_samp.get_output().hex()
	local in_s = 'r' .. self.in_s.get_output().hex()
	local in_dx = 'r' .. self.in_dx.get_output().hex()
	local in_dy = 'r' .. self.in_dy.get_output().hex()
	local in_texelOff = 'r' .. self.in_texelOff.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = tex1DARRAY( ' .. in_samp.. ', ' .. in_s.. ', ' .. in_dx.. ', ' .. in_dy.. ', ' .. in_texelOff.. ' );\n')
end

function cg_tex1DARRAY_5:get_tip(out)
	out.write( 'tex1DARRAY - performs a texture lookup in a given sampler array may use pre computed derivatives and, in some cases, perform a shadow comparison. ' )
end

-- #################################################### --
-- tex1DARRAYbias( samp, s )
-- #################################################### --
local cg_tex1DARRAYbias_2 = class(Node)
function cg_tex1DARRAYbias_2:get_help(out)
	out.write( '\n\nNAME\ntex1DARRAYbias - performs a texture lookup with bias in a given sampler array.\n\n\nSYNOPSIS\nfloat4 tex1DARRAYbias(sampler1DARRAY samp, float4 s)\nfloat4 tex1DARRAYbias(sampler1DARRAY samp, float4 s, int texelOff)\nint4 tex1DARRAYbias(isampler1DARRAY samp, float4 s)\nint4 tex1DARRAYbias(isampler1DARRAY samp, float4 s, int texelOff)\nuint4 tex1DARRAYbias(usampler1DARRAY samp, float4 s)\nuint4 tex1DARRAYbias(usampler1DARRAY samp, float4 s, int texelOff)\n\n\nPARAMETERS\nsamp Sampler array to lookup.\ns Coordinates to perform the lookup. The value used to select the layer should be passed in the\nvector component right after the regular coordinates. The bias value should be passed as the last\ncomponent of the coordinate vector.\ntexelOff Offset to be added to obtain the final texel.\n\n\nDESCRIPTION\nPerforms a texture lookup with bias in sampler samp using coordinates s, the texture to be sampled is\nselected from the layer specified in the coordinates.\n\n\nPROFILE SUPPORT\ntex1DARRAYbias is only supported in gp4 and newer profiles.\n\n\nSEE ALSO\ntex1DARRAY, tex1DARRAYlod\n' )
end

function cg_tex1DARRAYbias_2:new()
	Node.new(self)
	self.name = 'tex1DARRAYbias'
	self.in_samp = self.add_port(Input('samp'))
	self.in_s = self.add_port(Input('s'))
	self.out = self.add_port(Output('out'))
end

function cg_tex1DARRAYbias_2:get_type(port)

	local type_samp = self.in_samp.get_output().get_type()
	local type_s = self.in_s.get_output().get_type()
	if ((type_samp == 'sampler1DARRAY')
	and (type_s == 'float4')) then
		return 'float4'
	end
	if ((type_samp == 'isampler1DARRAY')
	and (type_s == 'float4')) then
		return 'int4'
	end
	if ((type_samp == 'usampler1DARRAY')
	and (type_s == 'float4')) then
		return 'uint4'
	end
	return nil
end

function cg_tex1DARRAYbias_2:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_tex1DARRAYbias_2:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_samp = 'r' .. self.in_samp.get_output().hex()
	local in_s = 'r' .. self.in_s.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = tex1DARRAYbias( ' .. in_samp.. ', ' .. in_s.. ' );\n')
end

function cg_tex1DARRAYbias_2:get_tip(out)
	out.write( 'tex1DARRAYbias - performs a texture lookup with bias in a given sampler array. ' )
end

-- #################################################### --
-- tex1DARRAYbias( samp, s, texelOff )
-- #################################################### --
local cg_tex1DARRAYbias_3 = class(Node)
function cg_tex1DARRAYbias_3:get_help(out)
	out.write( '\n\nNAME\ntex1DARRAYbias - performs a texture lookup with bias in a given sampler array.\n\n\nSYNOPSIS\nfloat4 tex1DARRAYbias(sampler1DARRAY samp, float4 s)\nfloat4 tex1DARRAYbias(sampler1DARRAY samp, float4 s, int texelOff)\nint4 tex1DARRAYbias(isampler1DARRAY samp, float4 s)\nint4 tex1DARRAYbias(isampler1DARRAY samp, float4 s, int texelOff)\nuint4 tex1DARRAYbias(usampler1DARRAY samp, float4 s)\nuint4 tex1DARRAYbias(usampler1DARRAY samp, float4 s, int texelOff)\n\n\nPARAMETERS\nsamp Sampler array to lookup.\ns Coordinates to perform the lookup. The value used to select the layer should be passed in the\nvector component right after the regular coordinates. The bias value should be passed as the last\ncomponent of the coordinate vector.\ntexelOff Offset to be added to obtain the final texel.\n\n\nDESCRIPTION\nPerforms a texture lookup with bias in sampler samp using coordinates s, the texture to be sampled is\nselected from the layer specified in the coordinates.\n\n\nPROFILE SUPPORT\ntex1DARRAYbias is only supported in gp4 and newer profiles.\n\n\nSEE ALSO\ntex1DARRAY, tex1DARRAYlod\n' )
end

function cg_tex1DARRAYbias_3:new()
	Node.new(self)
	self.name = 'tex1DARRAYbias'
	self.in_samp = self.add_port(Input('samp'))
	self.in_s = self.add_port(Input('s'))
	self.in_texelOff = self.add_port(Input('texelOff'))
	self.out = self.add_port(Output('out'))
end

function cg_tex1DARRAYbias_3:get_type(port)

	local type_samp = self.in_samp.get_output().get_type()
	local type_s = self.in_s.get_output().get_type()
	local type_texelOff = self.in_texelOff.get_output().get_type()
	if ((type_samp == 'sampler1DARRAY')
	and (type_s == 'float4')
	and (type_texelOff == 'int')) then
		return 'float4'
	end
	if ((type_samp == 'isampler1DARRAY')
	and (type_s == 'float4')
	and (type_texelOff == 'int')) then
		return 'int4'
	end
	if ((type_samp == 'usampler1DARRAY')
	and (type_s == 'float4')
	and (type_texelOff == 'int')) then
		return 'uint4'
	end
	return nil
end

function cg_tex1DARRAYbias_3:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_tex1DARRAYbias_3:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_samp = 'r' .. self.in_samp.get_output().hex()
	local in_s = 'r' .. self.in_s.get_output().hex()
	local in_texelOff = 'r' .. self.in_texelOff.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = tex1DARRAYbias( ' .. in_samp.. ', ' .. in_s.. ', ' .. in_texelOff.. ' );\n')
end

function cg_tex1DARRAYbias_3:get_tip(out)
	out.write( 'tex1DARRAYbias - performs a texture lookup with bias in a given sampler array. ' )
end

-- #################################################### --
-- tex1DARRAYcmpbias( samp, s )
-- #################################################### --
local cg_tex1DARRAYcmpbias_2 = class(Node)
function cg_tex1DARRAYcmpbias_2:get_help(out)
	out.write( '\n\nNAME\ntex1DARRAYcmpbias - performs a texture lookup with shadow compare and bias in a given sampler\narray.\n\n\nSYNOPSIS\nfloat4 tex1DARRAYcmpbias(sampler1DARRAY samp, float4 s)\nfloat4 tex1DARRAYcmpbias(sampler1DARRAY samp, float4 s, int texelOff)\n\n\nPARAMETERS\nsamp Sampler array to lookup.\ns Coordinates to perform the lookup. The value used to select the layer is the second coordinate,\nthe third is the value used in the shadow comparison, the fourth corresponds to the bias value.\ntexelOff Offset to be added to obtain the final texel.\n\n\nDESCRIPTION\nPerforms a texture lookup with bias in sampler samp using coordinates s, the texture to be sampled is\nselected from the layer specified in the coordinates, the lookup involves a shadow comparison and may use\ntexel offset texelOff to compute the final texel.\n\n\nPROFILE SUPPORT\ntex1DARRAYcmpbias is only supported in gp4 and newer profiles.\n\n\nSEE ALSO\ntex1DARRAYbias, tex1DARRAYlod, tex1DARRAYcmplod\n' )
end

function cg_tex1DARRAYcmpbias_2:new()
	Node.new(self)
	self.name = 'tex1DARRAYcmpbias'
	self.in_samp = self.add_port(Input('samp'))
	self.in_s = self.add_port(Input('s'))
	self.out = self.add_port(Output('out'))
end

function cg_tex1DARRAYcmpbias_2:get_type(port)

	local type_samp = self.in_samp.get_output().get_type()
	local type_s = self.in_s.get_output().get_type()
	if ((type_samp == 'sampler1DARRAY')
	and (type_s == 'float4')) then
		return 'float4'
	end
	return nil
end

function cg_tex1DARRAYcmpbias_2:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_tex1DARRAYcmpbias_2:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_samp = 'r' .. self.in_samp.get_output().hex()
	local in_s = 'r' .. self.in_s.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = tex1DARRAYcmpbias( ' .. in_samp.. ', ' .. in_s.. ' );\n')
end

function cg_tex1DARRAYcmpbias_2:get_tip(out)
	out.write( 'tex1DARRAYcmpbias - performs a texture lookup with shadow compare and bias in a given sampler array. ' )
end

-- #################################################### --
-- tex1DARRAYcmpbias( samp, s, texelOff )
-- #################################################### --
local cg_tex1DARRAYcmpbias_3 = class(Node)
function cg_tex1DARRAYcmpbias_3:get_help(out)
	out.write( '\n\nNAME\ntex1DARRAYcmpbias - performs a texture lookup with shadow compare and bias in a given sampler\narray.\n\n\nSYNOPSIS\nfloat4 tex1DARRAYcmpbias(sampler1DARRAY samp, float4 s)\nfloat4 tex1DARRAYcmpbias(sampler1DARRAY samp, float4 s, int texelOff)\n\n\nPARAMETERS\nsamp Sampler array to lookup.\ns Coordinates to perform the lookup. The value used to select the layer is the second coordinate,\nthe third is the value used in the shadow comparison, the fourth corresponds to the bias value.\ntexelOff Offset to be added to obtain the final texel.\n\n\nDESCRIPTION\nPerforms a texture lookup with bias in sampler samp using coordinates s, the texture to be sampled is\nselected from the layer specified in the coordinates, the lookup involves a shadow comparison and may use\ntexel offset texelOff to compute the final texel.\n\n\nPROFILE SUPPORT\ntex1DARRAYcmpbias is only supported in gp4 and newer profiles.\n\n\nSEE ALSO\ntex1DARRAYbias, tex1DARRAYlod, tex1DARRAYcmplod\n' )
end

function cg_tex1DARRAYcmpbias_3:new()
	Node.new(self)
	self.name = 'tex1DARRAYcmpbias'
	self.in_samp = self.add_port(Input('samp'))
	self.in_s = self.add_port(Input('s'))
	self.in_texelOff = self.add_port(Input('texelOff'))
	self.out = self.add_port(Output('out'))
end

function cg_tex1DARRAYcmpbias_3:get_type(port)

	local type_samp = self.in_samp.get_output().get_type()
	local type_s = self.in_s.get_output().get_type()
	local type_texelOff = self.in_texelOff.get_output().get_type()
	if ((type_samp == 'sampler1DARRAY')
	and (type_s == 'float4')
	and (type_texelOff == 'int')) then
		return 'float4'
	end
	return nil
end

function cg_tex1DARRAYcmpbias_3:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_tex1DARRAYcmpbias_3:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_samp = 'r' .. self.in_samp.get_output().hex()
	local in_s = 'r' .. self.in_s.get_output().hex()
	local in_texelOff = 'r' .. self.in_texelOff.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = tex1DARRAYcmpbias( ' .. in_samp.. ', ' .. in_s.. ', ' .. in_texelOff.. ' );\n')
end

function cg_tex1DARRAYcmpbias_3:get_tip(out)
	out.write( 'tex1DARRAYcmpbias - performs a texture lookup with shadow compare and bias in a given sampler array. ' )
end

-- #################################################### --
-- tex1DARRAYcmplod( samp, s )
-- #################################################### --
local cg_tex1DARRAYcmplod_2 = class(Node)
function cg_tex1DARRAYcmplod_2:get_help(out)
	out.write( '\n\nNAME\ntex1DARRAYcmplod - performs a texture lookup with shadow compare and a level of detail in a given\nsampler array.\n\n\nSYNOPSIS\nfloat4 tex1DARRAYcmplod(sampler1DARRAY samp, float4 s)\nfloat4 tex1DARRAYcmplod(sampler1DARRAY samp, float4 s, int texelOff)\nsamp Sampler array to look up.\ns Coordinates to perform the lookup. The value used to select the layer is the second coordinate,\nthe third is the value used in the shadow comparison, the fourth corresponds to the level of detail.\ntexelOff Offset to be added to obtain the final texel.\n\n\nDESCRIPTION\nPerforms a texture lookup with level of detail in sampler samp using coordinates s, the texture to be\nsampled is selected from the layer specified in the coordinates, the lookup involves a shadow comparison\nand may use texel offset texelOff to compute the final texel.\n\n\nPROFILE SUPPORT\ntex1DARRAYcmplod is only supported in gp4 and newer profiles.\n\n\nSEE ALSO\ntex1DARRAYlod, tex1DARRAYbias, tex1DARRAYcmpbias.de Sh\n\$1\n' )
end

function cg_tex1DARRAYcmplod_2:new()
	Node.new(self)
	self.name = 'tex1DARRAYcmplod'
	self.in_samp = self.add_port(Input('samp'))
	self.in_s = self.add_port(Input('s'))
	self.out = self.add_port(Output('out'))
end

function cg_tex1DARRAYcmplod_2:get_type(port)

	local type_samp = self.in_samp.get_output().get_type()
	local type_s = self.in_s.get_output().get_type()
	if ((type_samp == 'sampler1DARRAY')
	and (type_s == 'float4')) then
		return 'float4'
	end
	return nil
end

function cg_tex1DARRAYcmplod_2:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_tex1DARRAYcmplod_2:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_samp = 'r' .. self.in_samp.get_output().hex()
	local in_s = 'r' .. self.in_s.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = tex1DARRAYcmplod( ' .. in_samp.. ', ' .. in_s.. ' );\n')
end

function cg_tex1DARRAYcmplod_2:get_tip(out)
	out.write( 'tex1DARRAYcmplod - performs a texture lookup with shadow compare and a level of detail in a given sampler array. ' )
end

-- #################################################### --
-- tex1DARRAYcmplod( samp, s, texelOff )
-- #################################################### --
local cg_tex1DARRAYcmplod_3 = class(Node)
function cg_tex1DARRAYcmplod_3:get_help(out)
	out.write( '\n\nNAME\ntex1DARRAYcmplod - performs a texture lookup with shadow compare and a level of detail in a given\nsampler array.\n\n\nSYNOPSIS\nfloat4 tex1DARRAYcmplod(sampler1DARRAY samp, float4 s)\nfloat4 tex1DARRAYcmplod(sampler1DARRAY samp, float4 s, int texelOff)\nsamp Sampler array to look up.\ns Coordinates to perform the lookup. The value used to select the layer is the second coordinate,\nthe third is the value used in the shadow comparison, the fourth corresponds to the level of detail.\ntexelOff Offset to be added to obtain the final texel.\n\n\nDESCRIPTION\nPerforms a texture lookup with level of detail in sampler samp using coordinates s, the texture to be\nsampled is selected from the layer specified in the coordinates, the lookup involves a shadow comparison\nand may use texel offset texelOff to compute the final texel.\n\n\nPROFILE SUPPORT\ntex1DARRAYcmplod is only supported in gp4 and newer profiles.\n\n\nSEE ALSO\ntex1DARRAYlod, tex1DARRAYbias, tex1DARRAYcmpbias.de Sh\n\$1\n' )
end

function cg_tex1DARRAYcmplod_3:new()
	Node.new(self)
	self.name = 'tex1DARRAYcmplod'
	self.in_samp = self.add_port(Input('samp'))
	self.in_s = self.add_port(Input('s'))
	self.in_texelOff = self.add_port(Input('texelOff'))
	self.out = self.add_port(Output('out'))
end

function cg_tex1DARRAYcmplod_3:get_type(port)

	local type_samp = self.in_samp.get_output().get_type()
	local type_s = self.in_s.get_output().get_type()
	local type_texelOff = self.in_texelOff.get_output().get_type()
	if ((type_samp == 'sampler1DARRAY')
	and (type_s == 'float4')
	and (type_texelOff == 'int')) then
		return 'float4'
	end
	return nil
end

function cg_tex1DARRAYcmplod_3:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_tex1DARRAYcmplod_3:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_samp = 'r' .. self.in_samp.get_output().hex()
	local in_s = 'r' .. self.in_s.get_output().hex()
	local in_texelOff = 'r' .. self.in_texelOff.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = tex1DARRAYcmplod( ' .. in_samp.. ', ' .. in_s.. ', ' .. in_texelOff.. ' );\n')
end

function cg_tex1DARRAYcmplod_3:get_tip(out)
	out.write( 'tex1DARRAYcmplod - performs a texture lookup with shadow compare and a level of detail in a given sampler array. ' )
end

-- #################################################### --
-- tex1DARRAYfetch( samp, s )
-- #################################################### --
local cg_tex1DARRAYfetch_2 = class(Node)
function cg_tex1DARRAYfetch_2:get_help(out)
	out.write( '\n\nNAME\ntex1DARRAYfetch - performs an unfiltered texture lookup in a given sampler array.\n\n\nSYNOPSIS\nfloat4 tex1DARRAYfetch(sampler1DARRAY samp, int4 s)\nfloat4 tex1DARRAYfetch(sampler1DARRAY samp, int4 s, int texelOff)\nint4 tex1DARRAYfetch(isampler1DARRAY samp, int4 s)\nint4 tex1DARRAYfetch(isampler1DARRAY samp, int4 s, int texelOff)\nuint4 tex1DARRAYfetch(usampler1DARRAY samp, int4 s)\nuint4 tex1DARRAYfetch(usampler1DARRAY samp, int4 s, int texelOff)\n\n\nPARAMETERS\nsamp Sampler array to lookup.\ns Coordinates to perform the lookup, the layer is selected by the component right after the regular\ncoordinates, the level of detail is provided by the last component of the coordinate vector.\ntexelOff Offset to be added to obtain the final texel.\n\n\nDESCRIPTION\nPerforms an unfiltered texture lookup in sampler array samp using coordinates s. The layer to be accessed is\nselected by the component right after the regular coordinates, the level of detail is provided by the last\ncomponent of the coordinate vector. May use texel offset texelOff to compute final texel.\n\n\nPROFILE SUPPORT\ntex1DARRAYfetch is only supported in gp4 and newer profiles.\n\n\nSEE ALSO\ntex1Dfetch.de Sh\n\$1\n' )
end

function cg_tex1DARRAYfetch_2:new()
	Node.new(self)
	self.name = 'tex1DARRAYfetch'
	self.in_samp = self.add_port(Input('samp'))
	self.in_s = self.add_port(Input('s'))
	self.out = self.add_port(Output('out'))
end

function cg_tex1DARRAYfetch_2:get_type(port)

	local type_samp = self.in_samp.get_output().get_type()
	local type_s = self.in_s.get_output().get_type()
	if ((type_samp == 'sampler1DARRAY')
	and (type_s == 'int4')) then
		return 'float4'
	end
	if ((type_samp == 'isampler1DARRAY')
	and (type_s == 'int4')) then
		return 'int4'
	end
	if ((type_samp == 'usampler1DARRAY')
	and (type_s == 'int4')) then
		return 'uint4'
	end
	return nil
end

function cg_tex1DARRAYfetch_2:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_tex1DARRAYfetch_2:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_samp = 'r' .. self.in_samp.get_output().hex()
	local in_s = 'r' .. self.in_s.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = tex1DARRAYfetch( ' .. in_samp.. ', ' .. in_s.. ' );\n')
end

function cg_tex1DARRAYfetch_2:get_tip(out)
	out.write( 'tex1DARRAYfetch - performs an unfiltered texture lookup in a given sampler array. ' )
end

-- #################################################### --
-- tex1DARRAYfetch( samp, s, texelOff )
-- #################################################### --
local cg_tex1DARRAYfetch_3 = class(Node)
function cg_tex1DARRAYfetch_3:get_help(out)
	out.write( '\n\nNAME\ntex1DARRAYfetch - performs an unfiltered texture lookup in a given sampler array.\n\n\nSYNOPSIS\nfloat4 tex1DARRAYfetch(sampler1DARRAY samp, int4 s)\nfloat4 tex1DARRAYfetch(sampler1DARRAY samp, int4 s, int texelOff)\nint4 tex1DARRAYfetch(isampler1DARRAY samp, int4 s)\nint4 tex1DARRAYfetch(isampler1DARRAY samp, int4 s, int texelOff)\nuint4 tex1DARRAYfetch(usampler1DARRAY samp, int4 s)\nuint4 tex1DARRAYfetch(usampler1DARRAY samp, int4 s, int texelOff)\n\n\nPARAMETERS\nsamp Sampler array to lookup.\ns Coordinates to perform the lookup, the layer is selected by the component right after the regular\ncoordinates, the level of detail is provided by the last component of the coordinate vector.\ntexelOff Offset to be added to obtain the final texel.\n\n\nDESCRIPTION\nPerforms an unfiltered texture lookup in sampler array samp using coordinates s. The layer to be accessed is\nselected by the component right after the regular coordinates, the level of detail is provided by the last\ncomponent of the coordinate vector. May use texel offset texelOff to compute final texel.\n\n\nPROFILE SUPPORT\ntex1DARRAYfetch is only supported in gp4 and newer profiles.\n\n\nSEE ALSO\ntex1Dfetch.de Sh\n\$1\n' )
end

function cg_tex1DARRAYfetch_3:new()
	Node.new(self)
	self.name = 'tex1DARRAYfetch'
	self.in_samp = self.add_port(Input('samp'))
	self.in_s = self.add_port(Input('s'))
	self.in_texelOff = self.add_port(Input('texelOff'))
	self.out = self.add_port(Output('out'))
end

function cg_tex1DARRAYfetch_3:get_type(port)

	local type_samp = self.in_samp.get_output().get_type()
	local type_s = self.in_s.get_output().get_type()
	local type_texelOff = self.in_texelOff.get_output().get_type()
	if ((type_samp == 'sampler1DARRAY')
	and (type_s == 'int4')
	and (type_texelOff == 'int')) then
		return 'float4'
	end
	if ((type_samp == 'isampler1DARRAY')
	and (type_s == 'int4')
	and (type_texelOff == 'int')) then
		return 'int4'
	end
	if ((type_samp == 'usampler1DARRAY')
	and (type_s == 'int4')
	and (type_texelOff == 'int')) then
		return 'uint4'
	end
	return nil
end

function cg_tex1DARRAYfetch_3:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_tex1DARRAYfetch_3:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_samp = 'r' .. self.in_samp.get_output().hex()
	local in_s = 'r' .. self.in_s.get_output().hex()
	local in_texelOff = 'r' .. self.in_texelOff.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = tex1DARRAYfetch( ' .. in_samp.. ', ' .. in_s.. ', ' .. in_texelOff.. ' );\n')
end

function cg_tex1DARRAYfetch_3:get_tip(out)
	out.write( 'tex1DARRAYfetch - performs an unfiltered texture lookup in a given sampler array. ' )
end

-- #################################################### --
-- tex1DARRAYlod( samp, s )
-- #################################################### --
local cg_tex1DARRAYlod_2 = class(Node)
function cg_tex1DARRAYlod_2:get_help(out)
	out.write( '\n\nNAME\ntex1DARRAYlod - performs a texture lookup with a specified level of detail in a given sampler array.\n\n\nSYNOPSIS\nfloat4 tex1DARRAYlod(sampler1DARRAY samp, float4 s)\nfloat4 tex1DARRAYlod(sampler1DARRAY samp, float4 s, int texelOff)\nint4 tex1DARRAYlod(isampler1DARRAY samp, float4 s)\nint4 tex1DARRAYlod(isampler1DARRAY samp, float4 s, int texelOff)\nuint4 tex1DARRAYlod(usampler1DARRAY samp, float4 s)\nuint4 tex1DARRAYlod(usampler1DARRAY samp, float4 s, int texelOff)\n\n\nPARAMETERS\nsamp Sampler array to lookup.\ns Coordinates to perform the lookup.The value used to select the layer should be passed in the\nvector component right after the regular coordinates. The level of detail value should be passed as\nthe last component of the coordinate vector.\ntexelOff Offset to be added to obtain the final texel.\n\n\nDESCRIPTION\nPerforms a texture lookup with a specified level of detail in sampler samp using coordinates s, the texture to\nbe sampled is selected from the layer specified in the coordinates.\n\n\nPROFILE SUPPORT\ntex1DARRAYlod is only supported in gp4 and newer profiles.\n\n\nSEE ALSO\ntex1DARRAY, tex1DARRAYbias.de Sh\n\$1\n' )
end

function cg_tex1DARRAYlod_2:new()
	Node.new(self)
	self.name = 'tex1DARRAYlod'
	self.in_samp = self.add_port(Input('samp'))
	self.in_s = self.add_port(Input('s'))
	self.out = self.add_port(Output('out'))
end

function cg_tex1DARRAYlod_2:get_type(port)

	local type_samp = self.in_samp.get_output().get_type()
	local type_s = self.in_s.get_output().get_type()
	if ((type_samp == 'sampler1DARRAY')
	and (type_s == 'float4')) then
		return 'float4'
	end
	if ((type_samp == 'isampler1DARRAY')
	and (type_s == 'float4')) then
		return 'int4'
	end
	if ((type_samp == 'usampler1DARRAY')
	and (type_s == 'float4')) then
		return 'uint4'
	end
	return nil
end

function cg_tex1DARRAYlod_2:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_tex1DARRAYlod_2:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_samp = 'r' .. self.in_samp.get_output().hex()
	local in_s = 'r' .. self.in_s.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = tex1DARRAYlod( ' .. in_samp.. ', ' .. in_s.. ' );\n')
end

function cg_tex1DARRAYlod_2:get_tip(out)
	out.write( 'tex1DARRAYlod - performs a texture lookup with a specified level of detail in a given sampler array. ' )
end

-- #################################################### --
-- tex1DARRAYlod( samp, s, texelOff )
-- #################################################### --
local cg_tex1DARRAYlod_3 = class(Node)
function cg_tex1DARRAYlod_3:get_help(out)
	out.write( '\n\nNAME\ntex1DARRAYlod - performs a texture lookup with a specified level of detail in a given sampler array.\n\n\nSYNOPSIS\nfloat4 tex1DARRAYlod(sampler1DARRAY samp, float4 s)\nfloat4 tex1DARRAYlod(sampler1DARRAY samp, float4 s, int texelOff)\nint4 tex1DARRAYlod(isampler1DARRAY samp, float4 s)\nint4 tex1DARRAYlod(isampler1DARRAY samp, float4 s, int texelOff)\nuint4 tex1DARRAYlod(usampler1DARRAY samp, float4 s)\nuint4 tex1DARRAYlod(usampler1DARRAY samp, float4 s, int texelOff)\n\n\nPARAMETERS\nsamp Sampler array to lookup.\ns Coordinates to perform the lookup.The value used to select the layer should be passed in the\nvector component right after the regular coordinates. The level of detail value should be passed as\nthe last component of the coordinate vector.\ntexelOff Offset to be added to obtain the final texel.\n\n\nDESCRIPTION\nPerforms a texture lookup with a specified level of detail in sampler samp using coordinates s, the texture to\nbe sampled is selected from the layer specified in the coordinates.\n\n\nPROFILE SUPPORT\ntex1DARRAYlod is only supported in gp4 and newer profiles.\n\n\nSEE ALSO\ntex1DARRAY, tex1DARRAYbias.de Sh\n\$1\n' )
end

function cg_tex1DARRAYlod_3:new()
	Node.new(self)
	self.name = 'tex1DARRAYlod'
	self.in_samp = self.add_port(Input('samp'))
	self.in_s = self.add_port(Input('s'))
	self.in_texelOff = self.add_port(Input('texelOff'))
	self.out = self.add_port(Output('out'))
end

function cg_tex1DARRAYlod_3:get_type(port)

	local type_samp = self.in_samp.get_output().get_type()
	local type_s = self.in_s.get_output().get_type()
	local type_texelOff = self.in_texelOff.get_output().get_type()
	if ((type_samp == 'sampler1DARRAY')
	and (type_s == 'float4')
	and (type_texelOff == 'int')) then
		return 'float4'
	end
	if ((type_samp == 'isampler1DARRAY')
	and (type_s == 'float4')
	and (type_texelOff == 'int')) then
		return 'int4'
	end
	if ((type_samp == 'usampler1DARRAY')
	and (type_s == 'float4')
	and (type_texelOff == 'int')) then
		return 'uint4'
	end
	return nil
end

function cg_tex1DARRAYlod_3:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_tex1DARRAYlod_3:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_samp = 'r' .. self.in_samp.get_output().hex()
	local in_s = 'r' .. self.in_s.get_output().hex()
	local in_texelOff = 'r' .. self.in_texelOff.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = tex1DARRAYlod( ' .. in_samp.. ', ' .. in_s.. ', ' .. in_texelOff.. ' );\n')
end

function cg_tex1DARRAYlod_3:get_tip(out)
	out.write( 'tex1DARRAYlod - performs a texture lookup with a specified level of detail in a given sampler array. ' )
end

-- #################################################### --
-- tex1DARRAYproj( samp, s )
-- #################################################### --
local cg_tex1DARRAYproj_2 = class(Node)
function cg_tex1DARRAYproj_2:get_help(out)
	out.write( '\n\nNAME\ntex1DARRAYproj - performs a texture lookup with projection in a given sampler array. May perform a\nshadow comparison if argument for shadow comparison is provided.\n\n\nSYNOPSIS\nfloat4 tex1DARRAYproj(sampler1DARRAY samp, float3 s)\nfloat4 tex1DARRAYproj(sampler1DARRAY samp, float3 s, int texelOff)\nfloat4 tex1DARRAYproj(sampler1DARRAY samp, float4 s)\nfloat4 tex1DARRAYproj(sampler1DARRAY samp, float4 s, int texelOff)\nint4 tex1DARRAYproj(isampler1DARRAY samp, float3 s)\nint4 tex1DARRAYproj(isampler1DARRAY samp, float3 s, int texelOff)\nuint4 tex1DARRAYproj(usampler1DARRAY samp, float3 s)\nuint4 tex1DARRAYproj(usampler1DARRAY samp, float3 s, int texelOff)\n\n\nPARAMETERS\nsamp Sampler array to lookup.\ns Coordinates to perform the lookup. The value used to select the layer should be passed as the\ncomponent right after the lookup coordinates. The value used in the projection should be passed\nas the last component of the coordinate vector. The value used in the shadow comparison, if\npresent, should be passed as the next-to-last component of the coordinate vector.\ntexelOff Offset to be added to obtain the final texel.\n\n\nDESCRIPTION\nPerforms a texture lookup in sampler array samp using coordinates s, the layer used in the lookup is first\nselected using the coordinate component right after the regular coordinates. The coordinates used in the\nlookup are then projected, that is, divided by the last component of the coordinate vector and them used in\nthe lookup. If an extra coordinate is present it is used to perform a shadow comparison, the value used in\nthe shadow comparison is always the next-to-last component in the coordinate vector.\n\n\nPROFILE SUPPORT\ntex1DARRAYproj is only supported in gp4 and newer profiles.\n\n\nSEE ALSO\ntex1D, tex1Dproj\n' )
end

function cg_tex1DARRAYproj_2:new()
	Node.new(self)
	self.name = 'tex1DARRAYproj'
	self.in_samp = self.add_port(Input('samp'))
	self.in_s = self.add_port(Input('s'))
	self.out = self.add_port(Output('out'))
end

function cg_tex1DARRAYproj_2:get_type(port)

	local type_samp = self.in_samp.get_output().get_type()
	local type_s = self.in_s.get_output().get_type()
	if ((type_samp == 'sampler1DARRAY')
	and (type_s == 'float3')) then
		return 'float4'
	end
	if ((type_samp == 'sampler1DARRAY')
	and (type_s == 'float4')) then
		return 'float4'
	end
	if ((type_samp == 'isampler1DARRAY')
	and (type_s == 'float3')) then
		return 'int4'
	end
	if ((type_samp == 'usampler1DARRAY')
	and (type_s == 'float3')) then
		return 'uint4'
	end
	return nil
end

function cg_tex1DARRAYproj_2:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_tex1DARRAYproj_2:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_samp = 'r' .. self.in_samp.get_output().hex()
	local in_s = 'r' .. self.in_s.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = tex1DARRAYproj( ' .. in_samp.. ', ' .. in_s.. ' );\n')
end

function cg_tex1DARRAYproj_2:get_tip(out)
	out.write( 'tex1DARRAYproj - performs a texture lookup with projection in a given sampler array. May perform a shadow comparison if argument for shadow comparison is provided. ' )
end

-- #################################################### --
-- tex1DARRAYproj( samp, s, texelOff )
-- #################################################### --
local cg_tex1DARRAYproj_3 = class(Node)
function cg_tex1DARRAYproj_3:get_help(out)
	out.write( '\n\nNAME\ntex1DARRAYproj - performs a texture lookup with projection in a given sampler array. May perform a\nshadow comparison if argument for shadow comparison is provided.\n\n\nSYNOPSIS\nfloat4 tex1DARRAYproj(sampler1DARRAY samp, float3 s)\nfloat4 tex1DARRAYproj(sampler1DARRAY samp, float3 s, int texelOff)\nfloat4 tex1DARRAYproj(sampler1DARRAY samp, float4 s)\nfloat4 tex1DARRAYproj(sampler1DARRAY samp, float4 s, int texelOff)\nint4 tex1DARRAYproj(isampler1DARRAY samp, float3 s)\nint4 tex1DARRAYproj(isampler1DARRAY samp, float3 s, int texelOff)\nuint4 tex1DARRAYproj(usampler1DARRAY samp, float3 s)\nuint4 tex1DARRAYproj(usampler1DARRAY samp, float3 s, int texelOff)\n\n\nPARAMETERS\nsamp Sampler array to lookup.\ns Coordinates to perform the lookup. The value used to select the layer should be passed as the\ncomponent right after the lookup coordinates. The value used in the projection should be passed\nas the last component of the coordinate vector. The value used in the shadow comparison, if\npresent, should be passed as the next-to-last component of the coordinate vector.\ntexelOff Offset to be added to obtain the final texel.\n\n\nDESCRIPTION\nPerforms a texture lookup in sampler array samp using coordinates s, the layer used in the lookup is first\nselected using the coordinate component right after the regular coordinates. The coordinates used in the\nlookup are then projected, that is, divided by the last component of the coordinate vector and them used in\nthe lookup. If an extra coordinate is present it is used to perform a shadow comparison, the value used in\nthe shadow comparison is always the next-to-last component in the coordinate vector.\n\n\nPROFILE SUPPORT\ntex1DARRAYproj is only supported in gp4 and newer profiles.\n\n\nSEE ALSO\ntex1D, tex1Dproj\n' )
end

function cg_tex1DARRAYproj_3:new()
	Node.new(self)
	self.name = 'tex1DARRAYproj'
	self.in_samp = self.add_port(Input('samp'))
	self.in_s = self.add_port(Input('s'))
	self.in_texelOff = self.add_port(Input('texelOff'))
	self.out = self.add_port(Output('out'))
end

function cg_tex1DARRAYproj_3:get_type(port)

	local type_samp = self.in_samp.get_output().get_type()
	local type_s = self.in_s.get_output().get_type()
	local type_texelOff = self.in_texelOff.get_output().get_type()
	if ((type_samp == 'sampler1DARRAY')
	and (type_s == 'float3')
	and (type_texelOff == 'int')) then
		return 'float4'
	end
	if ((type_samp == 'sampler1DARRAY')
	and (type_s == 'float4')
	and (type_texelOff == 'int')) then
		return 'float4'
	end
	if ((type_samp == 'isampler1DARRAY')
	and (type_s == 'float3')
	and (type_texelOff == 'int')) then
		return 'int4'
	end
	if ((type_samp == 'usampler1DARRAY')
	and (type_s == 'float3')
	and (type_texelOff == 'int')) then
		return 'uint4'
	end
	return nil
end

function cg_tex1DARRAYproj_3:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_tex1DARRAYproj_3:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_samp = 'r' .. self.in_samp.get_output().hex()
	local in_s = 'r' .. self.in_s.get_output().hex()
	local in_texelOff = 'r' .. self.in_texelOff.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = tex1DARRAYproj( ' .. in_samp.. ', ' .. in_s.. ', ' .. in_texelOff.. ' );\n')
end

function cg_tex1DARRAYproj_3:get_tip(out)
	out.write( 'tex1DARRAYproj - performs a texture lookup with projection in a given sampler array. May perform a shadow comparison if argument for shadow comparison is provided. ' )
end

-- #################################################### --
-- tex1DARRAYsize( samp, lod )
-- #################################################### --
local cg_tex1DARRAYsize_2 = class(Node)
function cg_tex1DARRAYsize_2:get_help(out)
	out.write( '\n\nNAME\ntex1DARRAYsize - returns the size of a given texture array image for a given level of detail.\n\n\nSYNOPSIS\nint3 tex1DARRAYsize(sampler1DARRAY samp, int lod)\nint3 tex1DARRAYsize(isampler1DARRAY samp, int lod)\nint3 tex1DARRAYsize(usampler1DARRAY samp, int lod)\n\n\nPARAMETERS\nsamp Sampler to be queried for size.\nlod Level of detail to obtain size.\n\n\nDESCRIPTION\nGiven a sampler array and a level of detail the size of one element of the corresponding texture array for a\ngiven level of detail is returned as a result of the operation.\n\n\nPROFILE SUPPORT\ntex1DARRAYsize is only supported in gp4 and newer profiles.\n\n\nSEE ALSO\ntex1Dsize.de Sh\n\$1\n' )
end

function cg_tex1DARRAYsize_2:new()
	Node.new(self)
	self.name = 'tex1DARRAYsize'
	self.in_samp = self.add_port(Input('samp'))
	self.in_lod = self.add_port(Input('lod'))
	self.out = self.add_port(Output('out'))
end

function cg_tex1DARRAYsize_2:get_type(port)

	local type_samp = self.in_samp.get_output().get_type()
	local type_lod = self.in_lod.get_output().get_type()
	if ((type_samp == 'sampler1DARRAY')
	and (type_lod == 'int')) then
		return 'int3'
	end
	if ((type_samp == 'isampler1DARRAY')
	and (type_lod == 'int')) then
		return 'int3'
	end
	if ((type_samp == 'usampler1DARRAY')
	and (type_lod == 'int')) then
		return 'int3'
	end
	return nil
end

function cg_tex1DARRAYsize_2:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_tex1DARRAYsize_2:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_samp = 'r' .. self.in_samp.get_output().hex()
	local in_lod = 'r' .. self.in_lod.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = tex1DARRAYsize( ' .. in_samp.. ', ' .. in_lod.. ' );\n')
end

function cg_tex1DARRAYsize_2:get_tip(out)
	out.write( 'tex1DARRAYsize - returns the size of a given texture array image for a given level of detail. ' )
end

-- #################################################### --
-- tex1Dbias( samp, s )
-- #################################################### --
local cg_tex1Dbias_2 = class(Node)
function cg_tex1Dbias_2:get_help(out)
	out.write( '\n\nNAME\ntex1Dbias - performs a texture lookup with bias in a given sampler.\n\n\nSYNOPSIS\nfloat4 tex1Dbias(sampler1D samp, float4 s)\nfloat4 tex1Dbias(sampler1D samp, float4 s, int texelOff)\nint4 tex1Dbias(isampler1D samp, float4 s)\nint4 tex1Dbias(isampler1D samp, float4 s, int texelOff)\nuint4 tex1Dbias(usampler1D samp, float4 s)\nuint4 tex1Dbias(usampler1D samp, float4 s, int texelOff)\n\n\nPARAMETERS\nsamp Sampler to lookup.\ns Coordinates to perform the lookup. The bias value should be passed as the last component of the\ncoordinate vector.\ntexelOff Offset to be added to obtain the final texel.\n\n\nDESCRIPTION\nPerforms a texture lookup with bias in sampler samp using coordinates s.\n\n\nPROFILE SUPPORT\ntex1Dbias is supported in fragment profiles starting with fp30 and in vertex profiles starting with vp40.\nVariants with texelOff are only supported in gp4 and newer profiles. Variants with integer samplers are also\nonly suppported in gp4 and newer profiles.\n\n\nSEE ALSO\ntex1Dlod, tex1Dcmpbias.de Sh\n\$1\n' )
end

function cg_tex1Dbias_2:new()
	Node.new(self)
	self.name = 'tex1Dbias'
	self.in_samp = self.add_port(Input('samp'))
	self.in_s = self.add_port(Input('s'))
	self.out = self.add_port(Output('out'))
end

function cg_tex1Dbias_2:get_type(port)

	local type_samp = self.in_samp.get_output().get_type()
	local type_s = self.in_s.get_output().get_type()
	if ((type_samp == 'sampler1D')
	and (type_s == 'float4')) then
		return 'float4'
	end
	if ((type_samp == 'isampler1D')
	and (type_s == 'float4')) then
		return 'int4'
	end
	if ((type_samp == 'usampler1D')
	and (type_s == 'float4')) then
		return 'uint4'
	end
	return nil
end

function cg_tex1Dbias_2:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_tex1Dbias_2:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_samp = 'r' .. self.in_samp.get_output().hex()
	local in_s = 'r' .. self.in_s.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = tex1Dbias( ' .. in_samp.. ', ' .. in_s.. ' );\n')
end

function cg_tex1Dbias_2:get_tip(out)
	out.write( 'tex1Dbias - performs a texture lookup with bias in a given sampler. ' )
end

-- #################################################### --
-- tex1Dbias( samp, s, texelOff )
-- #################################################### --
local cg_tex1Dbias_3 = class(Node)
function cg_tex1Dbias_3:get_help(out)
	out.write( '\n\nNAME\ntex1Dbias - performs a texture lookup with bias in a given sampler.\n\n\nSYNOPSIS\nfloat4 tex1Dbias(sampler1D samp, float4 s)\nfloat4 tex1Dbias(sampler1D samp, float4 s, int texelOff)\nint4 tex1Dbias(isampler1D samp, float4 s)\nint4 tex1Dbias(isampler1D samp, float4 s, int texelOff)\nuint4 tex1Dbias(usampler1D samp, float4 s)\nuint4 tex1Dbias(usampler1D samp, float4 s, int texelOff)\n\n\nPARAMETERS\nsamp Sampler to lookup.\ns Coordinates to perform the lookup. The bias value should be passed as the last component of the\ncoordinate vector.\ntexelOff Offset to be added to obtain the final texel.\n\n\nDESCRIPTION\nPerforms a texture lookup with bias in sampler samp using coordinates s.\n\n\nPROFILE SUPPORT\ntex1Dbias is supported in fragment profiles starting with fp30 and in vertex profiles starting with vp40.\nVariants with texelOff are only supported in gp4 and newer profiles. Variants with integer samplers are also\nonly suppported in gp4 and newer profiles.\n\n\nSEE ALSO\ntex1Dlod, tex1Dcmpbias.de Sh\n\$1\n' )
end

function cg_tex1Dbias_3:new()
	Node.new(self)
	self.name = 'tex1Dbias'
	self.in_samp = self.add_port(Input('samp'))
	self.in_s = self.add_port(Input('s'))
	self.in_texelOff = self.add_port(Input('texelOff'))
	self.out = self.add_port(Output('out'))
end

function cg_tex1Dbias_3:get_type(port)

	local type_samp = self.in_samp.get_output().get_type()
	local type_s = self.in_s.get_output().get_type()
	local type_texelOff = self.in_texelOff.get_output().get_type()
	if ((type_samp == 'sampler1D')
	and (type_s == 'float4')
	and (type_texelOff == 'int')) then
		return 'float4'
	end
	if ((type_samp == 'isampler1D')
	and (type_s == 'float4')
	and (type_texelOff == 'int')) then
		return 'int4'
	end
	if ((type_samp == 'usampler1D')
	and (type_s == 'float4')
	and (type_texelOff == 'int')) then
		return 'uint4'
	end
	return nil
end

function cg_tex1Dbias_3:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_tex1Dbias_3:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_samp = 'r' .. self.in_samp.get_output().hex()
	local in_s = 'r' .. self.in_s.get_output().hex()
	local in_texelOff = 'r' .. self.in_texelOff.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = tex1Dbias( ' .. in_samp.. ', ' .. in_s.. ', ' .. in_texelOff.. ' );\n')
end

function cg_tex1Dbias_3:get_tip(out)
	out.write( 'tex1Dbias - performs a texture lookup with bias in a given sampler. ' )
end

-- #################################################### --
-- tex1Dcmpbias( samp, s )
-- #################################################### --
local cg_tex1Dcmpbias_2 = class(Node)
function cg_tex1Dcmpbias_2:get_help(out)
	out.write( '\n\nNAME\ntex1Dcmpbias - performs a texture lookup with bias and shadow compare in a given sampler.\n\n\nSYNOPSIS\nfloat4 tex1Dcmpbias(sampler1D samp, float4 s)\nfloat4 tex1Dcmpbias(sampler1D samp, float4 s, int texelOff)\n\n\nPARAMETERS\nsamp Sampler to lookup.\ns Coordinates to perform the lookup. The value used in the shadow comparison should be passed\nright after the normal coordinates. The bias value should be passed as the last component of the\ncoordinate vector.\ntexelOff Offset to be added to obtain the final texel.\n\n\nDESCRIPTION\nPerforms a texture lookup with shadow compare and bias in sampler samp using coordinates s.\n\n\nPROFILE SUPPORT\ntex1Dcmpbias is supported in fragment profiles starting with fp40 and in vertex profiles starting with vp40.\nVariants with texelOff are only supported in gp4 and newer profiles.\n\n\nSEE ALSO\ntex1Dcmplod, tex1Dbias.de Sh\n\$1\n' )
end

function cg_tex1Dcmpbias_2:new()
	Node.new(self)
	self.name = 'tex1Dcmpbias'
	self.in_samp = self.add_port(Input('samp'))
	self.in_s = self.add_port(Input('s'))
	self.out = self.add_port(Output('out'))
end

function cg_tex1Dcmpbias_2:get_type(port)

	local type_samp = self.in_samp.get_output().get_type()
	local type_s = self.in_s.get_output().get_type()
	if ((type_samp == 'sampler1D')
	and (type_s == 'float4')) then
		return 'float4'
	end
	return nil
end

function cg_tex1Dcmpbias_2:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_tex1Dcmpbias_2:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_samp = 'r' .. self.in_samp.get_output().hex()
	local in_s = 'r' .. self.in_s.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = tex1Dcmpbias( ' .. in_samp.. ', ' .. in_s.. ' );\n')
end

function cg_tex1Dcmpbias_2:get_tip(out)
	out.write( 'tex1Dcmpbias - performs a texture lookup with bias and shadow compare in a given sampler. ' )
end

-- #################################################### --
-- tex1Dcmpbias( samp, s, texelOff )
-- #################################################### --
local cg_tex1Dcmpbias_3 = class(Node)
function cg_tex1Dcmpbias_3:get_help(out)
	out.write( '\n\nNAME\ntex1Dcmpbias - performs a texture lookup with bias and shadow compare in a given sampler.\n\n\nSYNOPSIS\nfloat4 tex1Dcmpbias(sampler1D samp, float4 s)\nfloat4 tex1Dcmpbias(sampler1D samp, float4 s, int texelOff)\n\n\nPARAMETERS\nsamp Sampler to lookup.\ns Coordinates to perform the lookup. The value used in the shadow comparison should be passed\nright after the normal coordinates. The bias value should be passed as the last component of the\ncoordinate vector.\ntexelOff Offset to be added to obtain the final texel.\n\n\nDESCRIPTION\nPerforms a texture lookup with shadow compare and bias in sampler samp using coordinates s.\n\n\nPROFILE SUPPORT\ntex1Dcmpbias is supported in fragment profiles starting with fp40 and in vertex profiles starting with vp40.\nVariants with texelOff are only supported in gp4 and newer profiles.\n\n\nSEE ALSO\ntex1Dcmplod, tex1Dbias.de Sh\n\$1\n' )
end

function cg_tex1Dcmpbias_3:new()
	Node.new(self)
	self.name = 'tex1Dcmpbias'
	self.in_samp = self.add_port(Input('samp'))
	self.in_s = self.add_port(Input('s'))
	self.in_texelOff = self.add_port(Input('texelOff'))
	self.out = self.add_port(Output('out'))
end

function cg_tex1Dcmpbias_3:get_type(port)

	local type_samp = self.in_samp.get_output().get_type()
	local type_s = self.in_s.get_output().get_type()
	local type_texelOff = self.in_texelOff.get_output().get_type()
	if ((type_samp == 'sampler1D')
	and (type_s == 'float4')
	and (type_texelOff == 'int')) then
		return 'float4'
	end
	return nil
end

function cg_tex1Dcmpbias_3:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_tex1Dcmpbias_3:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_samp = 'r' .. self.in_samp.get_output().hex()
	local in_s = 'r' .. self.in_s.get_output().hex()
	local in_texelOff = 'r' .. self.in_texelOff.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = tex1Dcmpbias( ' .. in_samp.. ', ' .. in_s.. ', ' .. in_texelOff.. ' );\n')
end

function cg_tex1Dcmpbias_3:get_tip(out)
	out.write( 'tex1Dcmpbias - performs a texture lookup with bias and shadow compare in a given sampler. ' )
end

-- #################################################### --
-- tex1Dcmplod( samp, s )
-- #################################################### --
local cg_tex1Dcmplod_2 = class(Node)
function cg_tex1Dcmplod_2:get_help(out)
	out.write( '\n\nNAME\ntex1Dcmplod - performs a texture lookup with a specified level of detail and a shadow compare in a given\nsampler.\n\n\nSYNOPSIS\nfloat4 tex1Dcmplod(sampler1D samp, float4 s)\nfloat4 tex1Dcmplod(sampler1D samp, float4 s, int texelOff)\nint4 tex1Dcmplod(isampler1D samp, float4 s)\nint4 tex1Dcmplod(isampler1D samp, float4 s, int texelOff)\nuint4 tex1Dcmplod(usampler1D samp, float4 s)\nuint4 tex1Dcmplod(usampler1D samp, float4 s, int texelOff)\n\n\nPARAMETERS\nsamp Sampler to lookup.\ns Coordinates to perform the lookup. The value used in the shadow comparison should be passed\nright after the normal coordinates. The level of detail corresponds to the last component of the\ncoordinate vector.\ntexelOff Offset to be added to obtain the final texel.\n\n\nDESCRIPTION\nPerforms a texture lookup with shadow compare and a specified level of detail in sampler samp using\ncoordinates s.\n\n\nPROFILE SUPPORT\ntex1Dcmplod is supported in fragment profiles starting with fp40 and in vertex profiles starting with vp40.\nVariants with texelOff are only supported in gp4 and newer profiles. Variants with integer samplers are also\nonly suppported in gp4 and newer profiles.\n\n\nSEE ALSO\ntex1Dlod, tex1Dcmpbias\n' )
end

function cg_tex1Dcmplod_2:new()
	Node.new(self)
	self.name = 'tex1Dcmplod'
	self.in_samp = self.add_port(Input('samp'))
	self.in_s = self.add_port(Input('s'))
	self.out = self.add_port(Output('out'))
end

function cg_tex1Dcmplod_2:get_type(port)

	local type_samp = self.in_samp.get_output().get_type()
	local type_s = self.in_s.get_output().get_type()
	if ((type_samp == 'sampler1D')
	and (type_s == 'float4')) then
		return 'float4'
	end
	if ((type_samp == 'isampler1D')
	and (type_s == 'float4')) then
		return 'int4'
	end
	if ((type_samp == 'usampler1D')
	and (type_s == 'float4')) then
		return 'uint4'
	end
	return nil
end

function cg_tex1Dcmplod_2:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_tex1Dcmplod_2:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_samp = 'r' .. self.in_samp.get_output().hex()
	local in_s = 'r' .. self.in_s.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = tex1Dcmplod( ' .. in_samp.. ', ' .. in_s.. ' );\n')
end

function cg_tex1Dcmplod_2:get_tip(out)
	out.write( 'tex1Dcmplod - performs a texture lookup with a specified level of detail and a shadow compare in a given sampler. ' )
end

-- #################################################### --
-- tex1Dcmplod( samp, s, texelOff )
-- #################################################### --
local cg_tex1Dcmplod_3 = class(Node)
function cg_tex1Dcmplod_3:get_help(out)
	out.write( '\n\nNAME\ntex1Dcmplod - performs a texture lookup with a specified level of detail and a shadow compare in a given\nsampler.\n\n\nSYNOPSIS\nfloat4 tex1Dcmplod(sampler1D samp, float4 s)\nfloat4 tex1Dcmplod(sampler1D samp, float4 s, int texelOff)\nint4 tex1Dcmplod(isampler1D samp, float4 s)\nint4 tex1Dcmplod(isampler1D samp, float4 s, int texelOff)\nuint4 tex1Dcmplod(usampler1D samp, float4 s)\nuint4 tex1Dcmplod(usampler1D samp, float4 s, int texelOff)\n\n\nPARAMETERS\nsamp Sampler to lookup.\ns Coordinates to perform the lookup. The value used in the shadow comparison should be passed\nright after the normal coordinates. The level of detail corresponds to the last component of the\ncoordinate vector.\ntexelOff Offset to be added to obtain the final texel.\n\n\nDESCRIPTION\nPerforms a texture lookup with shadow compare and a specified level of detail in sampler samp using\ncoordinates s.\n\n\nPROFILE SUPPORT\ntex1Dcmplod is supported in fragment profiles starting with fp40 and in vertex profiles starting with vp40.\nVariants with texelOff are only supported in gp4 and newer profiles. Variants with integer samplers are also\nonly suppported in gp4 and newer profiles.\n\n\nSEE ALSO\ntex1Dlod, tex1Dcmpbias\n' )
end

function cg_tex1Dcmplod_3:new()
	Node.new(self)
	self.name = 'tex1Dcmplod'
	self.in_samp = self.add_port(Input('samp'))
	self.in_s = self.add_port(Input('s'))
	self.in_texelOff = self.add_port(Input('texelOff'))
	self.out = self.add_port(Output('out'))
end

function cg_tex1Dcmplod_3:get_type(port)

	local type_samp = self.in_samp.get_output().get_type()
	local type_s = self.in_s.get_output().get_type()
	local type_texelOff = self.in_texelOff.get_output().get_type()
	if ((type_samp == 'sampler1D')
	and (type_s == 'float4')
	and (type_texelOff == 'int')) then
		return 'float4'
	end
	if ((type_samp == 'isampler1D')
	and (type_s == 'float4')
	and (type_texelOff == 'int')) then
		return 'int4'
	end
	if ((type_samp == 'usampler1D')
	and (type_s == 'float4')
	and (type_texelOff == 'int')) then
		return 'uint4'
	end
	return nil
end

function cg_tex1Dcmplod_3:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_tex1Dcmplod_3:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_samp = 'r' .. self.in_samp.get_output().hex()
	local in_s = 'r' .. self.in_s.get_output().hex()
	local in_texelOff = 'r' .. self.in_texelOff.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = tex1Dcmplod( ' .. in_samp.. ', ' .. in_s.. ', ' .. in_texelOff.. ' );\n')
end

function cg_tex1Dcmplod_3:get_tip(out)
	out.write( 'tex1Dcmplod - performs a texture lookup with a specified level of detail and a shadow compare in a given sampler. ' )
end

-- #################################################### --
-- tex1Dfetch( samp, s )
-- #################################################### --
local cg_tex1Dfetch_2 = class(Node)
function cg_tex1Dfetch_2:get_help(out)
	out.write( '\n\nNAME\ntex1Dfetch - performs an unfiltered texture lookup in a given sampler.\n\n\nSYNOPSIS\nfloat4 tex1Dfetch(sampler1D samp, int4 s)\nfloat4 tex1Dfetch(sampler1D samp, int4 s, int texelOff)\nint4 tex1Dfetch(isampler1D samp, int4 s)\nint4 tex1Dfetch(isampler1D samp, int4 s, int texelOff)\nuint4 tex1Dfetch(usampler1D samp, int4 s)\nuint4 tex1Dfetch(usampler1D samp, int4 s, int texelOff)\n\n\nPARAMETERS\nsamp Sampler to lookup.\ns Coordinates to perform the lookup. The level of detail is stored in the last component of the\ncoordinate vector.\ntexelOff Offset to be added to obtain the final texel.\n\n\nDESCRIPTION\nPerforms an unfiltered texture lookup in sampler samp using coordinates s. The level of detail is provided\nby the last component of the coordinate vector. May use texel offset texelOff to compute final texel.\n\n\nPROFILE SUPPORT\ntex1Dfetch is only supported in gp4 and newer profiles.\n\n\nSEE ALSO\ntex1D, tex1DARRAYfetch.de Sh\n\$1\n' )
end

function cg_tex1Dfetch_2:new()
	Node.new(self)
	self.name = 'tex1Dfetch'
	self.in_samp = self.add_port(Input('samp'))
	self.in_s = self.add_port(Input('s'))
	self.out = self.add_port(Output('out'))
end

function cg_tex1Dfetch_2:get_type(port)

	local type_samp = self.in_samp.get_output().get_type()
	local type_s = self.in_s.get_output().get_type()
	if ((type_samp == 'sampler1D')
	and (type_s == 'int4')) then
		return 'float4'
	end
	if ((type_samp == 'isampler1D')
	and (type_s == 'int4')) then
		return 'int4'
	end
	if ((type_samp == 'usampler1D')
	and (type_s == 'int4')) then
		return 'uint4'
	end
	return nil
end

function cg_tex1Dfetch_2:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_tex1Dfetch_2:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_samp = 'r' .. self.in_samp.get_output().hex()
	local in_s = 'r' .. self.in_s.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = tex1Dfetch( ' .. in_samp.. ', ' .. in_s.. ' );\n')
end

function cg_tex1Dfetch_2:get_tip(out)
	out.write( 'tex1Dfetch - performs an unfiltered texture lookup in a given sampler. ' )
end

-- #################################################### --
-- tex1Dfetch( samp, s, texelOff )
-- #################################################### --
local cg_tex1Dfetch_3 = class(Node)
function cg_tex1Dfetch_3:get_help(out)
	out.write( '\n\nNAME\ntex1Dfetch - performs an unfiltered texture lookup in a given sampler.\n\n\nSYNOPSIS\nfloat4 tex1Dfetch(sampler1D samp, int4 s)\nfloat4 tex1Dfetch(sampler1D samp, int4 s, int texelOff)\nint4 tex1Dfetch(isampler1D samp, int4 s)\nint4 tex1Dfetch(isampler1D samp, int4 s, int texelOff)\nuint4 tex1Dfetch(usampler1D samp, int4 s)\nuint4 tex1Dfetch(usampler1D samp, int4 s, int texelOff)\n\n\nPARAMETERS\nsamp Sampler to lookup.\ns Coordinates to perform the lookup. The level of detail is stored in the last component of the\ncoordinate vector.\ntexelOff Offset to be added to obtain the final texel.\n\n\nDESCRIPTION\nPerforms an unfiltered texture lookup in sampler samp using coordinates s. The level of detail is provided\nby the last component of the coordinate vector. May use texel offset texelOff to compute final texel.\n\n\nPROFILE SUPPORT\ntex1Dfetch is only supported in gp4 and newer profiles.\n\n\nSEE ALSO\ntex1D, tex1DARRAYfetch.de Sh\n\$1\n' )
end

function cg_tex1Dfetch_3:new()
	Node.new(self)
	self.name = 'tex1Dfetch'
	self.in_samp = self.add_port(Input('samp'))
	self.in_s = self.add_port(Input('s'))
	self.in_texelOff = self.add_port(Input('texelOff'))
	self.out = self.add_port(Output('out'))
end

function cg_tex1Dfetch_3:get_type(port)

	local type_samp = self.in_samp.get_output().get_type()
	local type_s = self.in_s.get_output().get_type()
	local type_texelOff = self.in_texelOff.get_output().get_type()
	if ((type_samp == 'sampler1D')
	and (type_s == 'int4')
	and (type_texelOff == 'int')) then
		return 'float4'
	end
	if ((type_samp == 'isampler1D')
	and (type_s == 'int4')
	and (type_texelOff == 'int')) then
		return 'int4'
	end
	if ((type_samp == 'usampler1D')
	and (type_s == 'int4')
	and (type_texelOff == 'int')) then
		return 'uint4'
	end
	return nil
end

function cg_tex1Dfetch_3:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_tex1Dfetch_3:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_samp = 'r' .. self.in_samp.get_output().hex()
	local in_s = 'r' .. self.in_s.get_output().hex()
	local in_texelOff = 'r' .. self.in_texelOff.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = tex1Dfetch( ' .. in_samp.. ', ' .. in_s.. ', ' .. in_texelOff.. ' );\n')
end

function cg_tex1Dfetch_3:get_tip(out)
	out.write( 'tex1Dfetch - performs an unfiltered texture lookup in a given sampler. ' )
end

-- #################################################### --
-- tex1Dlod( samp, s )
-- #################################################### --
local cg_tex1Dlod_2 = class(Node)
function cg_tex1Dlod_2:get_help(out)
	out.write( '\n\nNAME\ntex1Dlod - performs a texture lookup with a specified level of detail in a given sampler.\n\n\nSYNOPSIS\nfloat4 tex1Dlod(sampler1D samp, float4 s)\nfloat4 tex1Dlod(sampler1D samp, float4 s, int texelOff)\nint4 tex1Dlod(isampler1D samp, float4 s)\nint4 tex1Dlod(isampler1D samp, float4 s, int texelOff)\nuint4 tex1Dlod(usampler1D samp, float4 s)\nuint4 tex1Dlod(usampler1D samp, float4 s, int texelOff)\n\n\nPARAMETERS\nsamp Sampler to lookup.\ns Coordinates to perform the lookup. The level of detail should be passed as the last component of\nthe coordinate vector.\ntexelOff Offset to be added to obtain the final texel.\n\n\nDESCRIPTION\nPerforms a texture lookup with a specified level of detail in sampler samp using coordinates s.\n\n\nPROFILE SUPPORT\ntex1Dlod is supported in fragment profiles starting with fp40 and in vertex profiles starting with vp40.\nVariants with texelOff are only supported in gp4 and newer profiles. Variants with integer samplers are also\nonly suppported in gp4 and newer profiles.\n\n\nSEE ALSO\ntex1Dbias, tex1Dcmplod.de Sh\n\$1\n' )
end

function cg_tex1Dlod_2:new()
	Node.new(self)
	self.name = 'tex1Dlod'
	self.in_samp = self.add_port(Input('samp'))
	self.in_s = self.add_port(Input('s'))
	self.out = self.add_port(Output('out'))
end

function cg_tex1Dlod_2:get_type(port)

	local type_samp = self.in_samp.get_output().get_type()
	local type_s = self.in_s.get_output().get_type()
	if ((type_samp == 'sampler1D')
	and (type_s == 'float4')) then
		return 'float4'
	end
	if ((type_samp == 'isampler1D')
	and (type_s == 'float4')) then
		return 'int4'
	end
	if ((type_samp == 'usampler1D')
	and (type_s == 'float4')) then
		return 'uint4'
	end
	return nil
end

function cg_tex1Dlod_2:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_tex1Dlod_2:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_samp = 'r' .. self.in_samp.get_output().hex()
	local in_s = 'r' .. self.in_s.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = tex1Dlod( ' .. in_samp.. ', ' .. in_s.. ' );\n')
end

function cg_tex1Dlod_2:get_tip(out)
	out.write( 'tex1Dlod - performs a texture lookup with a specified level of detail in a given sampler. ' )
end

-- #################################################### --
-- tex1Dlod( samp, s, texelOff )
-- #################################################### --
local cg_tex1Dlod_3 = class(Node)
function cg_tex1Dlod_3:get_help(out)
	out.write( '\n\nNAME\ntex1Dlod - performs a texture lookup with a specified level of detail in a given sampler.\n\n\nSYNOPSIS\nfloat4 tex1Dlod(sampler1D samp, float4 s)\nfloat4 tex1Dlod(sampler1D samp, float4 s, int texelOff)\nint4 tex1Dlod(isampler1D samp, float4 s)\nint4 tex1Dlod(isampler1D samp, float4 s, int texelOff)\nuint4 tex1Dlod(usampler1D samp, float4 s)\nuint4 tex1Dlod(usampler1D samp, float4 s, int texelOff)\n\n\nPARAMETERS\nsamp Sampler to lookup.\ns Coordinates to perform the lookup. The level of detail should be passed as the last component of\nthe coordinate vector.\ntexelOff Offset to be added to obtain the final texel.\n\n\nDESCRIPTION\nPerforms a texture lookup with a specified level of detail in sampler samp using coordinates s.\n\n\nPROFILE SUPPORT\ntex1Dlod is supported in fragment profiles starting with fp40 and in vertex profiles starting with vp40.\nVariants with texelOff are only supported in gp4 and newer profiles. Variants with integer samplers are also\nonly suppported in gp4 and newer profiles.\n\n\nSEE ALSO\ntex1Dbias, tex1Dcmplod.de Sh\n\$1\n' )
end

function cg_tex1Dlod_3:new()
	Node.new(self)
	self.name = 'tex1Dlod'
	self.in_samp = self.add_port(Input('samp'))
	self.in_s = self.add_port(Input('s'))
	self.in_texelOff = self.add_port(Input('texelOff'))
	self.out = self.add_port(Output('out'))
end

function cg_tex1Dlod_3:get_type(port)

	local type_samp = self.in_samp.get_output().get_type()
	local type_s = self.in_s.get_output().get_type()
	local type_texelOff = self.in_texelOff.get_output().get_type()
	if ((type_samp == 'sampler1D')
	and (type_s == 'float4')
	and (type_texelOff == 'int')) then
		return 'float4'
	end
	if ((type_samp == 'isampler1D')
	and (type_s == 'float4')
	and (type_texelOff == 'int')) then
		return 'int4'
	end
	if ((type_samp == 'usampler1D')
	and (type_s == 'float4')
	and (type_texelOff == 'int')) then
		return 'uint4'
	end
	return nil
end

function cg_tex1Dlod_3:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_tex1Dlod_3:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_samp = 'r' .. self.in_samp.get_output().hex()
	local in_s = 'r' .. self.in_s.get_output().hex()
	local in_texelOff = 'r' .. self.in_texelOff.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = tex1Dlod( ' .. in_samp.. ', ' .. in_s.. ', ' .. in_texelOff.. ' );\n')
end

function cg_tex1Dlod_3:get_tip(out)
	out.write( 'tex1Dlod - performs a texture lookup with a specified level of detail in a given sampler. ' )
end

-- #################################################### --
-- tex1Dproj( samp, s )
-- #################################################### --
local cg_tex1Dproj_2 = class(Node)
function cg_tex1Dproj_2:get_help(out)
	out.write( '\n\nNAME\ntex1Dproj - performs a texture lookup with projection in a given sampler. May perform a shadow\ncomparison if argument for shadow comparison is provided.\n\n\nSYNOPSIS\nfloat4 tex1Dproj(sampler1D samp, float2 s)\nfloat4 tex1Dproj(sampler1D samp, float2 s, int texelOff)\nfloat4 tex1Dproj(sampler1D samp, float3 s)\nfloat4 tex1Dproj(sampler1D samp, float3 s, int texelOff)\nint4 tex1Dproj(isampler1D samp, float2 s)\nint4 tex1Dproj(isampler1D samp, float2 s, int texelOff)\nuint4 tex1Dproj(usampler1D samp, float2 s)\nuint4 tex1Dproj(usampler1D samp, float2 s, int texelOff)\n\n\nPARAMETERS\nsamp Sampler to lookup.\ns Coordinates to perform the lookup. The value used in the projection should be passed as the last\ncomponent of the coordinate vector. The value used in the shadow comparison, if present, should\nbe passed as the next-to-last component of the coordinate vector.\ntexelOff Offset to be added to obtain the final texel.\n\n\nDESCRIPTION\nPerforms a texture lookup in sampler samp using coordinates s, the coordinates used in the lookup are first\nprojected, that is, divided by the last component of the coordinate vector and them used in the lookup. If an\nextra coordinate is present it is used to perform a shadow comparison, the value used in the shadow\ncomparison is always the next-to-last component in the coordinate vector.\n\n\nPROFILE SUPPORT\ntex1Dproj is supported in all fragment profiles and all vertex profiles starting with vp40, variants with\nshadow comparison are only supported in fp40 and newer profiles, variants with texel offsets are only\nsupported in gp4 and newer profiles.\n\n\nSEE ALSO\ntex1D, tex1DARRAYproj\n' )
end

function cg_tex1Dproj_2:new()
	Node.new(self)
	self.name = 'tex1Dproj'
	self.in_samp = self.add_port(Input('samp'))
	self.in_s = self.add_port(Input('s'))
	self.out = self.add_port(Output('out'))
end

function cg_tex1Dproj_2:get_type(port)

	local type_samp = self.in_samp.get_output().get_type()
	local type_s = self.in_s.get_output().get_type()
	if ((type_samp == 'sampler1D')
	and (type_s == 'float2')) then
		return 'float4'
	end
	if ((type_samp == 'sampler1D')
	and (type_s == 'float3')) then
		return 'float4'
	end
	if ((type_samp == 'isampler1D')
	and (type_s == 'float2')) then
		return 'int4'
	end
	if ((type_samp == 'usampler1D')
	and (type_s == 'float2')) then
		return 'uint4'
	end
	return nil
end

function cg_tex1Dproj_2:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_tex1Dproj_2:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_samp = 'r' .. self.in_samp.get_output().hex()
	local in_s = 'r' .. self.in_s.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = tex1Dproj( ' .. in_samp.. ', ' .. in_s.. ' );\n')
end

function cg_tex1Dproj_2:get_tip(out)
	out.write( 'tex1Dproj - performs a texture lookup with projection in a given sampler. May perform a shadow comparison if argument for shadow comparison is provided. ' )
end

-- #################################################### --
-- tex1Dproj( samp, s, texelOff )
-- #################################################### --
local cg_tex1Dproj_3 = class(Node)
function cg_tex1Dproj_3:get_help(out)
	out.write( '\n\nNAME\ntex1Dproj - performs a texture lookup with projection in a given sampler. May perform a shadow\ncomparison if argument for shadow comparison is provided.\n\n\nSYNOPSIS\nfloat4 tex1Dproj(sampler1D samp, float2 s)\nfloat4 tex1Dproj(sampler1D samp, float2 s, int texelOff)\nfloat4 tex1Dproj(sampler1D samp, float3 s)\nfloat4 tex1Dproj(sampler1D samp, float3 s, int texelOff)\nint4 tex1Dproj(isampler1D samp, float2 s)\nint4 tex1Dproj(isampler1D samp, float2 s, int texelOff)\nuint4 tex1Dproj(usampler1D samp, float2 s)\nuint4 tex1Dproj(usampler1D samp, float2 s, int texelOff)\n\n\nPARAMETERS\nsamp Sampler to lookup.\ns Coordinates to perform the lookup. The value used in the projection should be passed as the last\ncomponent of the coordinate vector. The value used in the shadow comparison, if present, should\nbe passed as the next-to-last component of the coordinate vector.\ntexelOff Offset to be added to obtain the final texel.\n\n\nDESCRIPTION\nPerforms a texture lookup in sampler samp using coordinates s, the coordinates used in the lookup are first\nprojected, that is, divided by the last component of the coordinate vector and them used in the lookup. If an\nextra coordinate is present it is used to perform a shadow comparison, the value used in the shadow\ncomparison is always the next-to-last component in the coordinate vector.\n\n\nPROFILE SUPPORT\ntex1Dproj is supported in all fragment profiles and all vertex profiles starting with vp40, variants with\nshadow comparison are only supported in fp40 and newer profiles, variants with texel offsets are only\nsupported in gp4 and newer profiles.\n\n\nSEE ALSO\ntex1D, tex1DARRAYproj\n' )
end

function cg_tex1Dproj_3:new()
	Node.new(self)
	self.name = 'tex1Dproj'
	self.in_samp = self.add_port(Input('samp'))
	self.in_s = self.add_port(Input('s'))
	self.in_texelOff = self.add_port(Input('texelOff'))
	self.out = self.add_port(Output('out'))
end

function cg_tex1Dproj_3:get_type(port)

	local type_samp = self.in_samp.get_output().get_type()
	local type_s = self.in_s.get_output().get_type()
	local type_texelOff = self.in_texelOff.get_output().get_type()
	if ((type_samp == 'sampler1D')
	and (type_s == 'float2')
	and (type_texelOff == 'int')) then
		return 'float4'
	end
	if ((type_samp == 'sampler1D')
	and (type_s == 'float3')
	and (type_texelOff == 'int')) then
		return 'float4'
	end
	if ((type_samp == 'isampler1D')
	and (type_s == 'float2')
	and (type_texelOff == 'int')) then
		return 'int4'
	end
	if ((type_samp == 'usampler1D')
	and (type_s == 'float2')
	and (type_texelOff == 'int')) then
		return 'uint4'
	end
	return nil
end

function cg_tex1Dproj_3:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_tex1Dproj_3:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_samp = 'r' .. self.in_samp.get_output().hex()
	local in_s = 'r' .. self.in_s.get_output().hex()
	local in_texelOff = 'r' .. self.in_texelOff.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = tex1Dproj( ' .. in_samp.. ', ' .. in_s.. ', ' .. in_texelOff.. ' );\n')
end

function cg_tex1Dproj_3:get_tip(out)
	out.write( 'tex1Dproj - performs a texture lookup with projection in a given sampler. May perform a shadow comparison if argument for shadow comparison is provided. ' )
end

-- #################################################### --
-- tex1Dsize( samp, lod )
-- #################################################### --
local cg_tex1Dsize_2 = class(Node)
function cg_tex1Dsize_2:get_help(out)
	out.write( '\n\nNAME\ntex1Dsize - returns the size of a given texture image for a given level of detail.\n\n\nSYNOPSIS\nint3 tex1Dsize(sampler1D samp, int lod)\nint3 tex1Dsize(isampler1D samp, int lod)\nint3 tex1Dsize(usampler1D samp, int lod)\n\n\nPARAMETERS\nsamp Sampler to be queried for size.\nlod Level of detail to obtain size.\n\n\nDESCRIPTION\nGiven a sampler and a level of detail the size of the corresponding texture image is returned as the result of\nthe operation.\n\n\nPROFILE SUPPORT\ntex1Dsize is only supported in gp4 and newer profiles.\n\n\nSEE ALSO\ntex1D, tex1DARRAYsize.de Sh\n\$1\n' )
end

function cg_tex1Dsize_2:new()
	Node.new(self)
	self.name = 'tex1Dsize'
	self.in_samp = self.add_port(Input('samp'))
	self.in_lod = self.add_port(Input('lod'))
	self.out = self.add_port(Output('out'))
end

function cg_tex1Dsize_2:get_type(port)

	local type_samp = self.in_samp.get_output().get_type()
	local type_lod = self.in_lod.get_output().get_type()
	if ((type_samp == 'sampler1D')
	and (type_lod == 'int')) then
		return 'int3'
	end
	if ((type_samp == 'isampler1D')
	and (type_lod == 'int')) then
		return 'int3'
	end
	if ((type_samp == 'usampler1D')
	and (type_lod == 'int')) then
		return 'int3'
	end
	return nil
end

function cg_tex1Dsize_2:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_tex1Dsize_2:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_samp = 'r' .. self.in_samp.get_output().hex()
	local in_lod = 'r' .. self.in_lod.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = tex1Dsize( ' .. in_samp.. ', ' .. in_lod.. ' );\n')
end

function cg_tex1Dsize_2:get_tip(out)
	out.write( 'tex1Dsize - returns the size of a given texture image for a given level of detail. ' )
end

-- #################################################### --
-- tex2D( samp, s )
-- #################################################### --
local cg_tex2D_2 = class(Node)
function cg_tex2D_2:get_help(out)
	out.write( '\n\nNAME\ntex2D - performs a texture lookup in a given 2D sampler and, in some cases, a shadow comparison. May\nalso use pre computed derivatives if those are provided.\n\n\nSYNOPSIS\nfloat4 tex2D(sampler2D samp, float2 s)\nfloat4 tex2D(sampler2D samp, float2 s, int texelOff)\nfloat4 tex2D(sampler2D samp, float3 s)\nfloat4 tex2D(sampler2D samp, float3 s, int texelOff)\nfloat4 tex2D(sampler2D samp, float2 s, float2 dx, float2 dy)\nfloat4 tex2D(sampler2D samp, float2 s, float2 dx, float2 dy, int texelOff)\nfloat4 tex2D(sampler2D samp, float3 s, float2 dx, float2 dy)\nfloat4 tex2D(sampler2D samp, float3 s, float2 dx, float2 dy, int texelOff)\nint4 tex2D(isampler2D samp, float2 s)\nint4 tex2D(isampler2D samp, float2 s, int texelOff)\nint4 tex2D(isampler2D samp, float2 s, float2 dx, float2 dy)\nint4 tex2D(isampler2D samp, float2 s, float2 dx, float2 dy, int texelOff)\nuint4 tex2D(usampler2D samp, float2 s)\nuint4 tex2D(usampler2D samp, float2 s, int texelOff)\nuint4 tex2D(usampler2D samp, float2 s, float2 dx, float2 dy)\nuint4 tex2D(usampler2D samp, float2 s, float2 dx, float2 dy,\nint texelOff)\n\n\nPARAMETERS\nsamp Sampler to lookup.\ns Coordinates to perform the lookup. If an extra coordinate compared to the texture dimensionality\nis present it is used to perform a shadow comparison. The value used in the shadow comparison is\nalways the last component of the coordinate vector.\ndx Pre computed derivative along the x axis.\ndy Pre computed derivative along the y axis.\ntexelOff Offset to be added to obtain the final texel.\n\n\nDESCRIPTION\nPerforms a texture lookup in sampler samp using coordinates s, may use and derivatives dx and dy, also\nmay perform shadow comparison and use texel offset texelOff to compute final texel.\n\n\nPROFILE SUPPORT\ntex2D is supported in all fragment profiles and all vertex profiles starting with vp40, variants with shadow\ncomparison are only supported in fp40 and newer profiles, variants with texel offsets are only supported in\ngp4 and newer profiles. Variants with integer textures are also only supported in gp4 and newer profiles.\n\n\nSEE ALSO\ntex2Dbias, tex2Dlod, tex2Dproj\n' )
end

function cg_tex2D_2:new()
	Node.new(self)
	self.name = 'tex2D'
	self.in_samp = self.add_port(Input('samp'))
	self.in_s = self.add_port(Input('s'))
	self.out = self.add_port(Output('out'))
end

function cg_tex2D_2:get_type(port)

	local type_samp = self.in_samp.get_output().get_type()
	local type_s = self.in_s.get_output().get_type()
	if ((type_samp == 'sampler2D')
	and (type_s == 'float2')) then
		return 'float4'
	end
	if ((type_samp == 'sampler2D')
	and (type_s == 'float3')) then
		return 'float4'
	end
	if ((type_samp == 'isampler2D')
	and (type_s == 'float2')) then
		return 'int4'
	end
	if ((type_samp == 'usampler2D')
	and (type_s == 'float2')) then
		return 'uint4'
	end
	return nil
end

function cg_tex2D_2:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_tex2D_2:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_samp = 'r' .. self.in_samp.get_output().hex()
	local in_s = 'r' .. self.in_s.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = tex2D( ' .. in_samp.. ', ' .. in_s.. ' );\n')
end

function cg_tex2D_2:get_tip(out)
	out.write( 'tex2D - performs a texture lookup in a given 2D sampler and, in some cases, a shadow comparison. May also use pre computed derivatives if those are provided. ' )
end

-- #################################################### --
-- tex2D( samp, s, texelOff )
-- #################################################### --
local cg_tex2D_3 = class(Node)
function cg_tex2D_3:get_help(out)
	out.write( '\n\nNAME\ntex2D - performs a texture lookup in a given 2D sampler and, in some cases, a shadow comparison. May\nalso use pre computed derivatives if those are provided.\n\n\nSYNOPSIS\nfloat4 tex2D(sampler2D samp, float2 s)\nfloat4 tex2D(sampler2D samp, float2 s, int texelOff)\nfloat4 tex2D(sampler2D samp, float3 s)\nfloat4 tex2D(sampler2D samp, float3 s, int texelOff)\nfloat4 tex2D(sampler2D samp, float2 s, float2 dx, float2 dy)\nfloat4 tex2D(sampler2D samp, float2 s, float2 dx, float2 dy, int texelOff)\nfloat4 tex2D(sampler2D samp, float3 s, float2 dx, float2 dy)\nfloat4 tex2D(sampler2D samp, float3 s, float2 dx, float2 dy, int texelOff)\nint4 tex2D(isampler2D samp, float2 s)\nint4 tex2D(isampler2D samp, float2 s, int texelOff)\nint4 tex2D(isampler2D samp, float2 s, float2 dx, float2 dy)\nint4 tex2D(isampler2D samp, float2 s, float2 dx, float2 dy, int texelOff)\nuint4 tex2D(usampler2D samp, float2 s)\nuint4 tex2D(usampler2D samp, float2 s, int texelOff)\nuint4 tex2D(usampler2D samp, float2 s, float2 dx, float2 dy)\nuint4 tex2D(usampler2D samp, float2 s, float2 dx, float2 dy,\nint texelOff)\n\n\nPARAMETERS\nsamp Sampler to lookup.\ns Coordinates to perform the lookup. If an extra coordinate compared to the texture dimensionality\nis present it is used to perform a shadow comparison. The value used in the shadow comparison is\nalways the last component of the coordinate vector.\ndx Pre computed derivative along the x axis.\ndy Pre computed derivative along the y axis.\ntexelOff Offset to be added to obtain the final texel.\n\n\nDESCRIPTION\nPerforms a texture lookup in sampler samp using coordinates s, may use and derivatives dx and dy, also\nmay perform shadow comparison and use texel offset texelOff to compute final texel.\n\n\nPROFILE SUPPORT\ntex2D is supported in all fragment profiles and all vertex profiles starting with vp40, variants with shadow\ncomparison are only supported in fp40 and newer profiles, variants with texel offsets are only supported in\ngp4 and newer profiles. Variants with integer textures are also only supported in gp4 and newer profiles.\n\n\nSEE ALSO\ntex2Dbias, tex2Dlod, tex2Dproj\n' )
end

function cg_tex2D_3:new()
	Node.new(self)
	self.name = 'tex2D'
	self.in_samp = self.add_port(Input('samp'))
	self.in_s = self.add_port(Input('s'))
	self.in_texelOff = self.add_port(Input('texelOff'))
	self.out = self.add_port(Output('out'))
end

function cg_tex2D_3:get_type(port)

	local type_samp = self.in_samp.get_output().get_type()
	local type_s = self.in_s.get_output().get_type()
	local type_texelOff = self.in_texelOff.get_output().get_type()
	if ((type_samp == 'sampler2D')
	and (type_s == 'float2')
	and (type_texelOff == 'int')) then
		return 'float4'
	end
	if ((type_samp == 'sampler2D')
	and (type_s == 'float3')
	and (type_texelOff == 'int')) then
		return 'float4'
	end
	if ((type_samp == 'isampler2D')
	and (type_s == 'float2')
	and (type_texelOff == 'int')) then
		return 'int4'
	end
	if ((type_samp == 'usampler2D')
	and (type_s == 'float2')
	and (type_texelOff == 'int')) then
		return 'uint4'
	end
	return nil
end

function cg_tex2D_3:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_tex2D_3:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_samp = 'r' .. self.in_samp.get_output().hex()
	local in_s = 'r' .. self.in_s.get_output().hex()
	local in_texelOff = 'r' .. self.in_texelOff.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = tex2D( ' .. in_samp.. ', ' .. in_s.. ', ' .. in_texelOff.. ' );\n')
end

function cg_tex2D_3:get_tip(out)
	out.write( 'tex2D - performs a texture lookup in a given 2D sampler and, in some cases, a shadow comparison. May also use pre computed derivatives if those are provided. ' )
end

-- #################################################### --
-- tex2D( samp, s, dx, dy )
-- #################################################### --
local cg_tex2D_4 = class(Node)
function cg_tex2D_4:get_help(out)
	out.write( '\n\nNAME\ntex2D - performs a texture lookup in a given 2D sampler and, in some cases, a shadow comparison. May\nalso use pre computed derivatives if those are provided.\n\n\nSYNOPSIS\nfloat4 tex2D(sampler2D samp, float2 s)\nfloat4 tex2D(sampler2D samp, float2 s, int texelOff)\nfloat4 tex2D(sampler2D samp, float3 s)\nfloat4 tex2D(sampler2D samp, float3 s, int texelOff)\nfloat4 tex2D(sampler2D samp, float2 s, float2 dx, float2 dy)\nfloat4 tex2D(sampler2D samp, float2 s, float2 dx, float2 dy, int texelOff)\nfloat4 tex2D(sampler2D samp, float3 s, float2 dx, float2 dy)\nfloat4 tex2D(sampler2D samp, float3 s, float2 dx, float2 dy, int texelOff)\nint4 tex2D(isampler2D samp, float2 s)\nint4 tex2D(isampler2D samp, float2 s, int texelOff)\nint4 tex2D(isampler2D samp, float2 s, float2 dx, float2 dy)\nint4 tex2D(isampler2D samp, float2 s, float2 dx, float2 dy, int texelOff)\nuint4 tex2D(usampler2D samp, float2 s)\nuint4 tex2D(usampler2D samp, float2 s, int texelOff)\nuint4 tex2D(usampler2D samp, float2 s, float2 dx, float2 dy)\nuint4 tex2D(usampler2D samp, float2 s, float2 dx, float2 dy,\nint texelOff)\n\n\nPARAMETERS\nsamp Sampler to lookup.\ns Coordinates to perform the lookup. If an extra coordinate compared to the texture dimensionality\nis present it is used to perform a shadow comparison. The value used in the shadow comparison is\nalways the last component of the coordinate vector.\ndx Pre computed derivative along the x axis.\ndy Pre computed derivative along the y axis.\ntexelOff Offset to be added to obtain the final texel.\n\n\nDESCRIPTION\nPerforms a texture lookup in sampler samp using coordinates s, may use and derivatives dx and dy, also\nmay perform shadow comparison and use texel offset texelOff to compute final texel.\n\n\nPROFILE SUPPORT\ntex2D is supported in all fragment profiles and all vertex profiles starting with vp40, variants with shadow\ncomparison are only supported in fp40 and newer profiles, variants with texel offsets are only supported in\ngp4 and newer profiles. Variants with integer textures are also only supported in gp4 and newer profiles.\n\n\nSEE ALSO\ntex2Dbias, tex2Dlod, tex2Dproj\n' )
end

function cg_tex2D_4:new()
	Node.new(self)
	self.name = 'tex2D'
	self.in_samp = self.add_port(Input('samp'))
	self.in_s = self.add_port(Input('s'))
	self.in_dx = self.add_port(Input('dx'))
	self.in_dy = self.add_port(Input('dy'))
	self.out = self.add_port(Output('out'))
end

function cg_tex2D_4:get_type(port)

	local type_samp = self.in_samp.get_output().get_type()
	local type_s = self.in_s.get_output().get_type()
	local type_dx = self.in_dx.get_output().get_type()
	local type_dy = self.in_dy.get_output().get_type()
	if ((type_samp == 'sampler2D')
	and (type_s == 'float2')
	and (type_dx == 'float2')
	and (type_dy == 'float2')) then
		return 'float4'
	end
	if ((type_samp == 'sampler2D')
	and (type_s == 'float3')
	and (type_dx == 'float2')
	and (type_dy == 'float2')) then
		return 'float4'
	end
	if ((type_samp == 'isampler2D')
	and (type_s == 'float2')
	and (type_dx == 'float2')
	and (type_dy == 'float2')) then
		return 'int4'
	end
	if ((type_samp == 'usampler2D')
	and (type_s == 'float2')
	and (type_dx == 'float2')
	and (type_dy == 'float2')) then
		return 'uint4'
	end
	return nil
end

function cg_tex2D_4:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_tex2D_4:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_samp = 'r' .. self.in_samp.get_output().hex()
	local in_s = 'r' .. self.in_s.get_output().hex()
	local in_dx = 'r' .. self.in_dx.get_output().hex()
	local in_dy = 'r' .. self.in_dy.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = tex2D( ' .. in_samp.. ', ' .. in_s.. ', ' .. in_dx.. ', ' .. in_dy.. ' );\n')
end

function cg_tex2D_4:get_tip(out)
	out.write( 'tex2D - performs a texture lookup in a given 2D sampler and, in some cases, a shadow comparison. May also use pre computed derivatives if those are provided. ' )
end

-- #################################################### --
-- tex2D( samp, s, dx, dy, texelOff )
-- #################################################### --
local cg_tex2D_5 = class(Node)
function cg_tex2D_5:get_help(out)
	out.write( '\n\nNAME\ntex2D - performs a texture lookup in a given 2D sampler and, in some cases, a shadow comparison. May\nalso use pre computed derivatives if those are provided.\n\n\nSYNOPSIS\nfloat4 tex2D(sampler2D samp, float2 s)\nfloat4 tex2D(sampler2D samp, float2 s, int texelOff)\nfloat4 tex2D(sampler2D samp, float3 s)\nfloat4 tex2D(sampler2D samp, float3 s, int texelOff)\nfloat4 tex2D(sampler2D samp, float2 s, float2 dx, float2 dy)\nfloat4 tex2D(sampler2D samp, float2 s, float2 dx, float2 dy, int texelOff)\nfloat4 tex2D(sampler2D samp, float3 s, float2 dx, float2 dy)\nfloat4 tex2D(sampler2D samp, float3 s, float2 dx, float2 dy, int texelOff)\nint4 tex2D(isampler2D samp, float2 s)\nint4 tex2D(isampler2D samp, float2 s, int texelOff)\nint4 tex2D(isampler2D samp, float2 s, float2 dx, float2 dy)\nint4 tex2D(isampler2D samp, float2 s, float2 dx, float2 dy, int texelOff)\nuint4 tex2D(usampler2D samp, float2 s)\nuint4 tex2D(usampler2D samp, float2 s, int texelOff)\nuint4 tex2D(usampler2D samp, float2 s, float2 dx, float2 dy)\nuint4 tex2D(usampler2D samp, float2 s, float2 dx, float2 dy,\nint texelOff)\n\n\nPARAMETERS\nsamp Sampler to lookup.\ns Coordinates to perform the lookup. If an extra coordinate compared to the texture dimensionality\nis present it is used to perform a shadow comparison. The value used in the shadow comparison is\nalways the last component of the coordinate vector.\ndx Pre computed derivative along the x axis.\ndy Pre computed derivative along the y axis.\ntexelOff Offset to be added to obtain the final texel.\n\n\nDESCRIPTION\nPerforms a texture lookup in sampler samp using coordinates s, may use and derivatives dx and dy, also\nmay perform shadow comparison and use texel offset texelOff to compute final texel.\n\n\nPROFILE SUPPORT\ntex2D is supported in all fragment profiles and all vertex profiles starting with vp40, variants with shadow\ncomparison are only supported in fp40 and newer profiles, variants with texel offsets are only supported in\ngp4 and newer profiles. Variants with integer textures are also only supported in gp4 and newer profiles.\n\n\nSEE ALSO\ntex2Dbias, tex2Dlod, tex2Dproj\n' )
end

function cg_tex2D_5:new()
	Node.new(self)
	self.name = 'tex2D'
	self.in_samp = self.add_port(Input('samp'))
	self.in_s = self.add_port(Input('s'))
	self.in_dx = self.add_port(Input('dx'))
	self.in_dy = self.add_port(Input('dy'))
	self.in_texelOff = self.add_port(Input('texelOff'))
	self.out = self.add_port(Output('out'))
end

function cg_tex2D_5:get_type(port)

	local type_samp = self.in_samp.get_output().get_type()
	local type_s = self.in_s.get_output().get_type()
	local type_dx = self.in_dx.get_output().get_type()
	local type_dy = self.in_dy.get_output().get_type()
	local type_texelOff = self.in_texelOff.get_output().get_type()
	if ((type_samp == 'sampler2D')
	and (type_s == 'float2')
	and (type_dx == 'float2')
	and (type_dy == 'float2')
	and (type_texelOff == 'int')) then
		return 'float4'
	end
	if ((type_samp == 'sampler2D')
	and (type_s == 'float3')
	and (type_dx == 'float2')
	and (type_dy == 'float2')
	and (type_texelOff == 'int')) then
		return 'float4'
	end
	if ((type_samp == 'isampler2D')
	and (type_s == 'float2')
	and (type_dx == 'float2')
	and (type_dy == 'float2')
	and (type_texelOff == 'int')) then
		return 'int4'
	end
	if ((type_samp == 'usampler2D')
	and (type_s == 'float2')
	and (type_dx == 'float2')
	and (type_dy == 'float2')
	and (type_texelOff == 'int')) then
		return 'uint4'
	end
	return nil
end

function cg_tex2D_5:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_tex2D_5:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_samp = 'r' .. self.in_samp.get_output().hex()
	local in_s = 'r' .. self.in_s.get_output().hex()
	local in_dx = 'r' .. self.in_dx.get_output().hex()
	local in_dy = 'r' .. self.in_dy.get_output().hex()
	local in_texelOff = 'r' .. self.in_texelOff.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = tex2D( ' .. in_samp.. ', ' .. in_s.. ', ' .. in_dx.. ', ' .. in_dy.. ', ' .. in_texelOff.. ' );\n')
end

function cg_tex2D_5:get_tip(out)
	out.write( 'tex2D - performs a texture lookup in a given 2D sampler and, in some cases, a shadow comparison. May also use pre computed derivatives if those are provided. ' )
end

-- #################################################### --
-- tex2DARRAY( samp, s )
-- #################################################### --
local cg_tex2DARRAY_2 = class(Node)
function cg_tex2DARRAY_2:get_help(out)
	out.write( '\n\nNAME\ntex2DARRAY - performs a texture lookup in a given sampler array may use pre computed derivatives and,\nin some cases, perform a shadow comparison.\n\n\nSYNOPSIS\nfloat4 tex2DARRAY(sampler2DARRAY samp, float3 s)\nfloat4 tex2DARRAY(sampler2DARRAY samp, float3 s, int texelOff)\nfloat4 tex2DARRAY(sampler2DARRAY samp, float4 s)\nfloat4 tex2DARRAY(sampler2DARRAY samp, float4 s, int texelOff)\nfloat4 tex2DARRAY(sampler2DARRAY samp, float3 s, float dx, float dy)\nfloat4 tex2DARRAY(sampler2DARRAY samp, float3 s, float dx, float dy,\nint texelOff)\nfloat4 tex2DARRAY(sampler2DARRAY samp, float4 s, float dx, float dy)\nfloat4 tex2DARRAY(sampler2DARRAY samp, float4 s, float dx, float dy,\nint texelOff)\nint4 tex2DARRAY(isampler2DARRAY samp, float3 s)\nint4 tex2DARRAY(isampler2DARRAY samp, float3 s, int texelOff)\nint4 tex2DARRAY(isampler2DARRAY samp, float3 s, float dx, float dy)\nint4 tex2DARRAY(isampler2DARRAY samp, float3 s, float dx, float dy,\nint texelOff)\nuint4 tex2DARRAY(usampler2DARRAY samp, float3 s)\nuint4 tex2DARRAY(usampler2DARRAY samp, float3 s, int texelOff)\nuint4 tex2DARRAY(usampler2DARRAY samp, float3 s, float dx, float dy)\nuint4 tex2DARRAY(usampler2DARRAY samp, float3 s, float dx, float dy,\nint texelOff)\n\n\nPARAMETERS\nsamp Sampler array to look up.\ns Coordinates to perform the lookup. The value used to select the layer is passed immediatelly after\nthe regular coordinates, if an extra coordinate is present it is used to perform a shadow\ncomparison.\ndx Pre computed derivative along the x axis.\ndy Pre computed derivative along the y axis.\ntexelOff Offset to be added to obtain the final texel.\n\n\nDESCRIPTION\nPerforms a texture lookup in sampler samp using coordinates s, the texture to be sampled is selected from\nthe layer specified in the coordinates. Also may use the derivatives dx and dy, the lookup may involve a\nshadow comparison and use texel offset texelOff to compute the final texel.\n\n\nPROFILE SUPPORT\ntex2DARRAY is only supported in gp4 and newer profiles.\n\n\nSEE ALSO\ntex2DARRAYbias, tex2DARRAYlod\n' )
end

function cg_tex2DARRAY_2:new()
	Node.new(self)
	self.name = 'tex2DARRAY'
	self.in_samp = self.add_port(Input('samp'))
	self.in_s = self.add_port(Input('s'))
	self.out = self.add_port(Output('out'))
end

function cg_tex2DARRAY_2:get_type(port)

	local type_samp = self.in_samp.get_output().get_type()
	local type_s = self.in_s.get_output().get_type()
	if ((type_samp == 'sampler2DARRAY')
	and (type_s == 'float3')) then
		return 'float4'
	end
	if ((type_samp == 'sampler2DARRAY')
	and (type_s == 'float4')) then
		return 'float4'
	end
	if ((type_samp == 'isampler2DARRAY')
	and (type_s == 'float3')) then
		return 'int4'
	end
	if ((type_samp == 'usampler2DARRAY')
	and (type_s == 'float3')) then
		return 'uint4'
	end
	return nil
end

function cg_tex2DARRAY_2:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_tex2DARRAY_2:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_samp = 'r' .. self.in_samp.get_output().hex()
	local in_s = 'r' .. self.in_s.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = tex2DARRAY( ' .. in_samp.. ', ' .. in_s.. ' );\n')
end

function cg_tex2DARRAY_2:get_tip(out)
	out.write( 'tex2DARRAY - performs a texture lookup in a given sampler array may use pre computed derivatives and, in some cases, perform a shadow comparison. ' )
end

-- #################################################### --
-- tex2DARRAY( samp, s, texelOff )
-- #################################################### --
local cg_tex2DARRAY_3 = class(Node)
function cg_tex2DARRAY_3:get_help(out)
	out.write( '\n\nNAME\ntex2DARRAY - performs a texture lookup in a given sampler array may use pre computed derivatives and,\nin some cases, perform a shadow comparison.\n\n\nSYNOPSIS\nfloat4 tex2DARRAY(sampler2DARRAY samp, float3 s)\nfloat4 tex2DARRAY(sampler2DARRAY samp, float3 s, int texelOff)\nfloat4 tex2DARRAY(sampler2DARRAY samp, float4 s)\nfloat4 tex2DARRAY(sampler2DARRAY samp, float4 s, int texelOff)\nfloat4 tex2DARRAY(sampler2DARRAY samp, float3 s, float dx, float dy)\nfloat4 tex2DARRAY(sampler2DARRAY samp, float3 s, float dx, float dy,\nint texelOff)\nfloat4 tex2DARRAY(sampler2DARRAY samp, float4 s, float dx, float dy)\nfloat4 tex2DARRAY(sampler2DARRAY samp, float4 s, float dx, float dy,\nint texelOff)\nint4 tex2DARRAY(isampler2DARRAY samp, float3 s)\nint4 tex2DARRAY(isampler2DARRAY samp, float3 s, int texelOff)\nint4 tex2DARRAY(isampler2DARRAY samp, float3 s, float dx, float dy)\nint4 tex2DARRAY(isampler2DARRAY samp, float3 s, float dx, float dy,\nint texelOff)\nuint4 tex2DARRAY(usampler2DARRAY samp, float3 s)\nuint4 tex2DARRAY(usampler2DARRAY samp, float3 s, int texelOff)\nuint4 tex2DARRAY(usampler2DARRAY samp, float3 s, float dx, float dy)\nuint4 tex2DARRAY(usampler2DARRAY samp, float3 s, float dx, float dy,\nint texelOff)\n\n\nPARAMETERS\nsamp Sampler array to look up.\ns Coordinates to perform the lookup. The value used to select the layer is passed immediatelly after\nthe regular coordinates, if an extra coordinate is present it is used to perform a shadow\ncomparison.\ndx Pre computed derivative along the x axis.\ndy Pre computed derivative along the y axis.\ntexelOff Offset to be added to obtain the final texel.\n\n\nDESCRIPTION\nPerforms a texture lookup in sampler samp using coordinates s, the texture to be sampled is selected from\nthe layer specified in the coordinates. Also may use the derivatives dx and dy, the lookup may involve a\nshadow comparison and use texel offset texelOff to compute the final texel.\n\n\nPROFILE SUPPORT\ntex2DARRAY is only supported in gp4 and newer profiles.\n\n\nSEE ALSO\ntex2DARRAYbias, tex2DARRAYlod\n' )
end

function cg_tex2DARRAY_3:new()
	Node.new(self)
	self.name = 'tex2DARRAY'
	self.in_samp = self.add_port(Input('samp'))
	self.in_s = self.add_port(Input('s'))
	self.in_texelOff = self.add_port(Input('texelOff'))
	self.out = self.add_port(Output('out'))
end

function cg_tex2DARRAY_3:get_type(port)

	local type_samp = self.in_samp.get_output().get_type()
	local type_s = self.in_s.get_output().get_type()
	local type_texelOff = self.in_texelOff.get_output().get_type()
	if ((type_samp == 'sampler2DARRAY')
	and (type_s == 'float3')
	and (type_texelOff == 'int')) then
		return 'float4'
	end
	if ((type_samp == 'sampler2DARRAY')
	and (type_s == 'float4')
	and (type_texelOff == 'int')) then
		return 'float4'
	end
	if ((type_samp == 'isampler2DARRAY')
	and (type_s == 'float3')
	and (type_texelOff == 'int')) then
		return 'int4'
	end
	if ((type_samp == 'usampler2DARRAY')
	and (type_s == 'float3')
	and (type_texelOff == 'int')) then
		return 'uint4'
	end
	return nil
end

function cg_tex2DARRAY_3:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_tex2DARRAY_3:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_samp = 'r' .. self.in_samp.get_output().hex()
	local in_s = 'r' .. self.in_s.get_output().hex()
	local in_texelOff = 'r' .. self.in_texelOff.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = tex2DARRAY( ' .. in_samp.. ', ' .. in_s.. ', ' .. in_texelOff.. ' );\n')
end

function cg_tex2DARRAY_3:get_tip(out)
	out.write( 'tex2DARRAY - performs a texture lookup in a given sampler array may use pre computed derivatives and, in some cases, perform a shadow comparison. ' )
end

-- #################################################### --
-- tex2DARRAY( samp, s, dx, dy )
-- #################################################### --
local cg_tex2DARRAY_4 = class(Node)
function cg_tex2DARRAY_4:get_help(out)
	out.write( '\n\nNAME\ntex2DARRAY - performs a texture lookup in a given sampler array may use pre computed derivatives and,\nin some cases, perform a shadow comparison.\n\n\nSYNOPSIS\nfloat4 tex2DARRAY(sampler2DARRAY samp, float3 s)\nfloat4 tex2DARRAY(sampler2DARRAY samp, float3 s, int texelOff)\nfloat4 tex2DARRAY(sampler2DARRAY samp, float4 s)\nfloat4 tex2DARRAY(sampler2DARRAY samp, float4 s, int texelOff)\nfloat4 tex2DARRAY(sampler2DARRAY samp, float3 s, float dx, float dy)\nfloat4 tex2DARRAY(sampler2DARRAY samp, float3 s, float dx, float dy,\nint texelOff)\nfloat4 tex2DARRAY(sampler2DARRAY samp, float4 s, float dx, float dy)\nfloat4 tex2DARRAY(sampler2DARRAY samp, float4 s, float dx, float dy,\nint texelOff)\nint4 tex2DARRAY(isampler2DARRAY samp, float3 s)\nint4 tex2DARRAY(isampler2DARRAY samp, float3 s, int texelOff)\nint4 tex2DARRAY(isampler2DARRAY samp, float3 s, float dx, float dy)\nint4 tex2DARRAY(isampler2DARRAY samp, float3 s, float dx, float dy,\nint texelOff)\nuint4 tex2DARRAY(usampler2DARRAY samp, float3 s)\nuint4 tex2DARRAY(usampler2DARRAY samp, float3 s, int texelOff)\nuint4 tex2DARRAY(usampler2DARRAY samp, float3 s, float dx, float dy)\nuint4 tex2DARRAY(usampler2DARRAY samp, float3 s, float dx, float dy,\nint texelOff)\n\n\nPARAMETERS\nsamp Sampler array to look up.\ns Coordinates to perform the lookup. The value used to select the layer is passed immediatelly after\nthe regular coordinates, if an extra coordinate is present it is used to perform a shadow\ncomparison.\ndx Pre computed derivative along the x axis.\ndy Pre computed derivative along the y axis.\ntexelOff Offset to be added to obtain the final texel.\n\n\nDESCRIPTION\nPerforms a texture lookup in sampler samp using coordinates s, the texture to be sampled is selected from\nthe layer specified in the coordinates. Also may use the derivatives dx and dy, the lookup may involve a\nshadow comparison and use texel offset texelOff to compute the final texel.\n\n\nPROFILE SUPPORT\ntex2DARRAY is only supported in gp4 and newer profiles.\n\n\nSEE ALSO\ntex2DARRAYbias, tex2DARRAYlod\n' )
end

function cg_tex2DARRAY_4:new()
	Node.new(self)
	self.name = 'tex2DARRAY'
	self.in_samp = self.add_port(Input('samp'))
	self.in_s = self.add_port(Input('s'))
	self.in_dx = self.add_port(Input('dx'))
	self.in_dy = self.add_port(Input('dy'))
	self.out = self.add_port(Output('out'))
end

function cg_tex2DARRAY_4:get_type(port)

	local type_samp = self.in_samp.get_output().get_type()
	local type_s = self.in_s.get_output().get_type()
	local type_dx = self.in_dx.get_output().get_type()
	local type_dy = self.in_dy.get_output().get_type()
	if ((type_samp == 'sampler2DARRAY')
	and (type_s == 'float3')
	and (type_dx == 'float')
	and (type_dy == 'float')) then
		return 'float4'
	end
	if ((type_samp == 'sampler2DARRAY')
	and (type_s == 'float4')
	and (type_dx == 'float')
	and (type_dy == 'float')) then
		return 'float4'
	end
	if ((type_samp == 'isampler2DARRAY')
	and (type_s == 'float3')
	and (type_dx == 'float')
	and (type_dy == 'float')) then
		return 'int4'
	end
	if ((type_samp == 'usampler2DARRAY')
	and (type_s == 'float3')
	and (type_dx == 'float')
	and (type_dy == 'float')) then
		return 'uint4'
	end
	return nil
end

function cg_tex2DARRAY_4:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_tex2DARRAY_4:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_samp = 'r' .. self.in_samp.get_output().hex()
	local in_s = 'r' .. self.in_s.get_output().hex()
	local in_dx = 'r' .. self.in_dx.get_output().hex()
	local in_dy = 'r' .. self.in_dy.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = tex2DARRAY( ' .. in_samp.. ', ' .. in_s.. ', ' .. in_dx.. ', ' .. in_dy.. ' );\n')
end

function cg_tex2DARRAY_4:get_tip(out)
	out.write( 'tex2DARRAY - performs a texture lookup in a given sampler array may use pre computed derivatives and, in some cases, perform a shadow comparison. ' )
end

-- #################################################### --
-- tex2DARRAY( samp, s, dx, dy, texelOff )
-- #################################################### --
local cg_tex2DARRAY_5 = class(Node)
function cg_tex2DARRAY_5:get_help(out)
	out.write( '\n\nNAME\ntex2DARRAY - performs a texture lookup in a given sampler array may use pre computed derivatives and,\nin some cases, perform a shadow comparison.\n\n\nSYNOPSIS\nfloat4 tex2DARRAY(sampler2DARRAY samp, float3 s)\nfloat4 tex2DARRAY(sampler2DARRAY samp, float3 s, int texelOff)\nfloat4 tex2DARRAY(sampler2DARRAY samp, float4 s)\nfloat4 tex2DARRAY(sampler2DARRAY samp, float4 s, int texelOff)\nfloat4 tex2DARRAY(sampler2DARRAY samp, float3 s, float dx, float dy)\nfloat4 tex2DARRAY(sampler2DARRAY samp, float3 s, float dx, float dy,\nint texelOff)\nfloat4 tex2DARRAY(sampler2DARRAY samp, float4 s, float dx, float dy)\nfloat4 tex2DARRAY(sampler2DARRAY samp, float4 s, float dx, float dy,\nint texelOff)\nint4 tex2DARRAY(isampler2DARRAY samp, float3 s)\nint4 tex2DARRAY(isampler2DARRAY samp, float3 s, int texelOff)\nint4 tex2DARRAY(isampler2DARRAY samp, float3 s, float dx, float dy)\nint4 tex2DARRAY(isampler2DARRAY samp, float3 s, float dx, float dy,\nint texelOff)\nuint4 tex2DARRAY(usampler2DARRAY samp, float3 s)\nuint4 tex2DARRAY(usampler2DARRAY samp, float3 s, int texelOff)\nuint4 tex2DARRAY(usampler2DARRAY samp, float3 s, float dx, float dy)\nuint4 tex2DARRAY(usampler2DARRAY samp, float3 s, float dx, float dy,\nint texelOff)\n\n\nPARAMETERS\nsamp Sampler array to look up.\ns Coordinates to perform the lookup. The value used to select the layer is passed immediatelly after\nthe regular coordinates, if an extra coordinate is present it is used to perform a shadow\ncomparison.\ndx Pre computed derivative along the x axis.\ndy Pre computed derivative along the y axis.\ntexelOff Offset to be added to obtain the final texel.\n\n\nDESCRIPTION\nPerforms a texture lookup in sampler samp using coordinates s, the texture to be sampled is selected from\nthe layer specified in the coordinates. Also may use the derivatives dx and dy, the lookup may involve a\nshadow comparison and use texel offset texelOff to compute the final texel.\n\n\nPROFILE SUPPORT\ntex2DARRAY is only supported in gp4 and newer profiles.\n\n\nSEE ALSO\ntex2DARRAYbias, tex2DARRAYlod\n' )
end

function cg_tex2DARRAY_5:new()
	Node.new(self)
	self.name = 'tex2DARRAY'
	self.in_samp = self.add_port(Input('samp'))
	self.in_s = self.add_port(Input('s'))
	self.in_dx = self.add_port(Input('dx'))
	self.in_dy = self.add_port(Input('dy'))
	self.in_texelOff = self.add_port(Input('texelOff'))
	self.out = self.add_port(Output('out'))
end

function cg_tex2DARRAY_5:get_type(port)

	local type_samp = self.in_samp.get_output().get_type()
	local type_s = self.in_s.get_output().get_type()
	local type_dx = self.in_dx.get_output().get_type()
	local type_dy = self.in_dy.get_output().get_type()
	local type_texelOff = self.in_texelOff.get_output().get_type()
	if ((type_samp == 'sampler2DARRAY')
	and (type_s == 'float3')
	and (type_dx == 'float')
	and (type_dy == 'float')
	and (type_texelOff == 'int')) then
		return 'float4'
	end
	if ((type_samp == 'sampler2DARRAY')
	and (type_s == 'float4')
	and (type_dx == 'float')
	and (type_dy == 'float')
	and (type_texelOff == 'int')) then
		return 'float4'
	end
	if ((type_samp == 'isampler2DARRAY')
	and (type_s == 'float3')
	and (type_dx == 'float')
	and (type_dy == 'float')
	and (type_texelOff == 'int')) then
		return 'int4'
	end
	if ((type_samp == 'usampler2DARRAY')
	and (type_s == 'float3')
	and (type_dx == 'float')
	and (type_dy == 'float')
	and (type_texelOff == 'int')) then
		return 'uint4'
	end
	return nil
end

function cg_tex2DARRAY_5:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_tex2DARRAY_5:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_samp = 'r' .. self.in_samp.get_output().hex()
	local in_s = 'r' .. self.in_s.get_output().hex()
	local in_dx = 'r' .. self.in_dx.get_output().hex()
	local in_dy = 'r' .. self.in_dy.get_output().hex()
	local in_texelOff = 'r' .. self.in_texelOff.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = tex2DARRAY( ' .. in_samp.. ', ' .. in_s.. ', ' .. in_dx.. ', ' .. in_dy.. ', ' .. in_texelOff.. ' );\n')
end

function cg_tex2DARRAY_5:get_tip(out)
	out.write( 'tex2DARRAY - performs a texture lookup in a given sampler array may use pre computed derivatives and, in some cases, perform a shadow comparison. ' )
end

-- #################################################### --
-- tex2DARRAYbias( samp, s )
-- #################################################### --
local cg_tex2DARRAYbias_2 = class(Node)
function cg_tex2DARRAYbias_2:get_help(out)
	out.write( '\n\nNAME\ntex2DARRAYbias - performs a texture lookup with bias in a given sampler array.\n\n\nSYNOPSIS\nfloat4 tex2DARRAYbias(sampler2DARRAY samp, float4 s)\nfloat4 tex2DARRAYbias(sampler2DARRAY samp, float4 s, int texelOff)\nint4 tex2DARRAYbias(isampler2DARRAY samp, float4 s)\nint4 tex2DARRAYbias(isampler2DARRAY samp, float4 s, int texelOff)\nuint4 tex2DARRAYbias(usampler2DARRAY samp, float4 s)\nuint4 tex2DARRAYbias(usampler2DARRAY samp, float4 s, int texelOff)\n\n\nPARAMETERS\nsamp Sampler array to lookup.\ns Coordinates to perform the lookup. The value used to select the layer should be passed in the\nvector component right after the regular coordinates. The bias value should be passed as the last\ncomponent of the coordinate vector.\ntexelOff Offset to be added to obtain the final texel.\n\n\nDESCRIPTION\nPerforms a texture lookup with bias in sampler samp using coordinates s, the texture to be sampled is\nselected from the layer specified in the coordinates.\n\n\nPROFILE SUPPORT\ntex2DARRAYbias is only supported in gp4 and newer profiles.\n\n\nSEE ALSO\ntex2DARRAY, tex2DARRAYlod\n' )
end

function cg_tex2DARRAYbias_2:new()
	Node.new(self)
	self.name = 'tex2DARRAYbias'
	self.in_samp = self.add_port(Input('samp'))
	self.in_s = self.add_port(Input('s'))
	self.out = self.add_port(Output('out'))
end

function cg_tex2DARRAYbias_2:get_type(port)

	local type_samp = self.in_samp.get_output().get_type()
	local type_s = self.in_s.get_output().get_type()
	if ((type_samp == 'sampler2DARRAY')
	and (type_s == 'float4')) then
		return 'float4'
	end
	if ((type_samp == 'isampler2DARRAY')
	and (type_s == 'float4')) then
		return 'int4'
	end
	if ((type_samp == 'usampler2DARRAY')
	and (type_s == 'float4')) then
		return 'uint4'
	end
	return nil
end

function cg_tex2DARRAYbias_2:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_tex2DARRAYbias_2:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_samp = 'r' .. self.in_samp.get_output().hex()
	local in_s = 'r' .. self.in_s.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = tex2DARRAYbias( ' .. in_samp.. ', ' .. in_s.. ' );\n')
end

function cg_tex2DARRAYbias_2:get_tip(out)
	out.write( 'tex2DARRAYbias - performs a texture lookup with bias in a given sampler array. ' )
end

-- #################################################### --
-- tex2DARRAYbias( samp, s, texelOff )
-- #################################################### --
local cg_tex2DARRAYbias_3 = class(Node)
function cg_tex2DARRAYbias_3:get_help(out)
	out.write( '\n\nNAME\ntex2DARRAYbias - performs a texture lookup with bias in a given sampler array.\n\n\nSYNOPSIS\nfloat4 tex2DARRAYbias(sampler2DARRAY samp, float4 s)\nfloat4 tex2DARRAYbias(sampler2DARRAY samp, float4 s, int texelOff)\nint4 tex2DARRAYbias(isampler2DARRAY samp, float4 s)\nint4 tex2DARRAYbias(isampler2DARRAY samp, float4 s, int texelOff)\nuint4 tex2DARRAYbias(usampler2DARRAY samp, float4 s)\nuint4 tex2DARRAYbias(usampler2DARRAY samp, float4 s, int texelOff)\n\n\nPARAMETERS\nsamp Sampler array to lookup.\ns Coordinates to perform the lookup. The value used to select the layer should be passed in the\nvector component right after the regular coordinates. The bias value should be passed as the last\ncomponent of the coordinate vector.\ntexelOff Offset to be added to obtain the final texel.\n\n\nDESCRIPTION\nPerforms a texture lookup with bias in sampler samp using coordinates s, the texture to be sampled is\nselected from the layer specified in the coordinates.\n\n\nPROFILE SUPPORT\ntex2DARRAYbias is only supported in gp4 and newer profiles.\n\n\nSEE ALSO\ntex2DARRAY, tex2DARRAYlod\n' )
end

function cg_tex2DARRAYbias_3:new()
	Node.new(self)
	self.name = 'tex2DARRAYbias'
	self.in_samp = self.add_port(Input('samp'))
	self.in_s = self.add_port(Input('s'))
	self.in_texelOff = self.add_port(Input('texelOff'))
	self.out = self.add_port(Output('out'))
end

function cg_tex2DARRAYbias_3:get_type(port)

	local type_samp = self.in_samp.get_output().get_type()
	local type_s = self.in_s.get_output().get_type()
	local type_texelOff = self.in_texelOff.get_output().get_type()
	if ((type_samp == 'sampler2DARRAY')
	and (type_s == 'float4')
	and (type_texelOff == 'int')) then
		return 'float4'
	end
	if ((type_samp == 'isampler2DARRAY')
	and (type_s == 'float4')
	and (type_texelOff == 'int')) then
		return 'int4'
	end
	if ((type_samp == 'usampler2DARRAY')
	and (type_s == 'float4')
	and (type_texelOff == 'int')) then
		return 'uint4'
	end
	return nil
end

function cg_tex2DARRAYbias_3:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_tex2DARRAYbias_3:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_samp = 'r' .. self.in_samp.get_output().hex()
	local in_s = 'r' .. self.in_s.get_output().hex()
	local in_texelOff = 'r' .. self.in_texelOff.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = tex2DARRAYbias( ' .. in_samp.. ', ' .. in_s.. ', ' .. in_texelOff.. ' );\n')
end

function cg_tex2DARRAYbias_3:get_tip(out)
	out.write( 'tex2DARRAYbias - performs a texture lookup with bias in a given sampler array. ' )
end

-- #################################################### --
-- tex2DARRAYfetch( samp, s )
-- #################################################### --
local cg_tex2DARRAYfetch_2 = class(Node)
function cg_tex2DARRAYfetch_2:get_help(out)
	out.write( '\n\nNAME\ntex2DARRAYfetch - performs an unfiltered texture lookup in a given sampler array.\n\n\nSYNOPSIS\nfloat4 tex2DARRAYfetch(sampler2DARRAY samp, int4 s)\nfloat4 tex2DARRAYfetch(sampler2DARRAY samp, int4 s, int texelOff)\nint4 tex2DARRAYfetch(isampler2DARRAY samp, int4 s)\nint4 tex2DARRAYfetch(isampler2DARRAY samp, int4 s, int texelOff)\nuint4 tex2DARRAYfetch(usampler2DARRAY samp, int4 s)\nuint4 tex2DARRAYfetch(usampler2DARRAY samp, int4 s, int texelOff)\n\n\nPARAMETERS\nsamp Sampler array to lookup.\ns Coordinates to perform the lookup, the layer is selected by the component right after the regular\ncoordinates, the level of detail is provided by the last component of the coordinate vector.\ntexelOff Offset to be added to obtain the final texel.\n\n\nDESCRIPTION\nPerforms an unfiltered texture lookup in sampler array samp using coordinates s. The layer to be accessed is\nselected by the component right after the regular coordinates, the level of detail is provided by the last\ncomponent of the coordinate vector. May use texel offset texelOff to compute final texel.\n\n\nPROFILE SUPPORT\ntex2DARRAYfetch is only supported in gp4 and newer profiles.\n\n\nSEE ALSO\ntex2Dfetch.de Sh\n\$1\n' )
end

function cg_tex2DARRAYfetch_2:new()
	Node.new(self)
	self.name = 'tex2DARRAYfetch'
	self.in_samp = self.add_port(Input('samp'))
	self.in_s = self.add_port(Input('s'))
	self.out = self.add_port(Output('out'))
end

function cg_tex2DARRAYfetch_2:get_type(port)

	local type_samp = self.in_samp.get_output().get_type()
	local type_s = self.in_s.get_output().get_type()
	if ((type_samp == 'sampler2DARRAY')
	and (type_s == 'int4')) then
		return 'float4'
	end
	if ((type_samp == 'isampler2DARRAY')
	and (type_s == 'int4')) then
		return 'int4'
	end
	if ((type_samp == 'usampler2DARRAY')
	and (type_s == 'int4')) then
		return 'uint4'
	end
	return nil
end

function cg_tex2DARRAYfetch_2:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_tex2DARRAYfetch_2:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_samp = 'r' .. self.in_samp.get_output().hex()
	local in_s = 'r' .. self.in_s.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = tex2DARRAYfetch( ' .. in_samp.. ', ' .. in_s.. ' );\n')
end

function cg_tex2DARRAYfetch_2:get_tip(out)
	out.write( 'tex2DARRAYfetch - performs an unfiltered texture lookup in a given sampler array. ' )
end

-- #################################################### --
-- tex2DARRAYfetch( samp, s, texelOff )
-- #################################################### --
local cg_tex2DARRAYfetch_3 = class(Node)
function cg_tex2DARRAYfetch_3:get_help(out)
	out.write( '\n\nNAME\ntex2DARRAYfetch - performs an unfiltered texture lookup in a given sampler array.\n\n\nSYNOPSIS\nfloat4 tex2DARRAYfetch(sampler2DARRAY samp, int4 s)\nfloat4 tex2DARRAYfetch(sampler2DARRAY samp, int4 s, int texelOff)\nint4 tex2DARRAYfetch(isampler2DARRAY samp, int4 s)\nint4 tex2DARRAYfetch(isampler2DARRAY samp, int4 s, int texelOff)\nuint4 tex2DARRAYfetch(usampler2DARRAY samp, int4 s)\nuint4 tex2DARRAYfetch(usampler2DARRAY samp, int4 s, int texelOff)\n\n\nPARAMETERS\nsamp Sampler array to lookup.\ns Coordinates to perform the lookup, the layer is selected by the component right after the regular\ncoordinates, the level of detail is provided by the last component of the coordinate vector.\ntexelOff Offset to be added to obtain the final texel.\n\n\nDESCRIPTION\nPerforms an unfiltered texture lookup in sampler array samp using coordinates s. The layer to be accessed is\nselected by the component right after the regular coordinates, the level of detail is provided by the last\ncomponent of the coordinate vector. May use texel offset texelOff to compute final texel.\n\n\nPROFILE SUPPORT\ntex2DARRAYfetch is only supported in gp4 and newer profiles.\n\n\nSEE ALSO\ntex2Dfetch.de Sh\n\$1\n' )
end

function cg_tex2DARRAYfetch_3:new()
	Node.new(self)
	self.name = 'tex2DARRAYfetch'
	self.in_samp = self.add_port(Input('samp'))
	self.in_s = self.add_port(Input('s'))
	self.in_texelOff = self.add_port(Input('texelOff'))
	self.out = self.add_port(Output('out'))
end

function cg_tex2DARRAYfetch_3:get_type(port)

	local type_samp = self.in_samp.get_output().get_type()
	local type_s = self.in_s.get_output().get_type()
	local type_texelOff = self.in_texelOff.get_output().get_type()
	if ((type_samp == 'sampler2DARRAY')
	and (type_s == 'int4')
	and (type_texelOff == 'int')) then
		return 'float4'
	end
	if ((type_samp == 'isampler2DARRAY')
	and (type_s == 'int4')
	and (type_texelOff == 'int')) then
		return 'int4'
	end
	if ((type_samp == 'usampler2DARRAY')
	and (type_s == 'int4')
	and (type_texelOff == 'int')) then
		return 'uint4'
	end
	return nil
end

function cg_tex2DARRAYfetch_3:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_tex2DARRAYfetch_3:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_samp = 'r' .. self.in_samp.get_output().hex()
	local in_s = 'r' .. self.in_s.get_output().hex()
	local in_texelOff = 'r' .. self.in_texelOff.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = tex2DARRAYfetch( ' .. in_samp.. ', ' .. in_s.. ', ' .. in_texelOff.. ' );\n')
end

function cg_tex2DARRAYfetch_3:get_tip(out)
	out.write( 'tex2DARRAYfetch - performs an unfiltered texture lookup in a given sampler array. ' )
end

-- #################################################### --
-- tex2DARRAYlod( samp, s )
-- #################################################### --
local cg_tex2DARRAYlod_2 = class(Node)
function cg_tex2DARRAYlod_2:get_help(out)
	out.write( '\n\nNAME\ntex2DARRAYlod - performs a texture lookup with a specified level of detail in a given sampler array.\n\n\nSYNOPSIS\nfloat4 tex2DARRAYlod(sampler2DARRAY samp, float4 s)\nfloat4 tex2DARRAYlod(sampler2DARRAY samp, float4 s, int texelOff)\nint4 tex2DARRAYlod(isampler2DARRAY samp, float4 s)\nint4 tex2DARRAYlod(isampler2DARRAY samp, float4 s, int texelOff)\nuint4 tex2DARRAYlod(usampler2DARRAY samp, float4 s)\nuint4 tex2DARRAYlod(usampler2DARRAY samp, float4 s, int texelOff)\n\n\nPARAMETERS\nsamp Sampler array to lookup.\ns Coordinates to perform the lookup.The value used to select the layer should be passed in the\nvector component right after the regular coordinates. The level of detail value should be passed as\nthe last component of the coordinate vector.\ntexelOff Offset to be added to obtain the final texel.\n\n\nDESCRIPTION\nPerforms a texture lookup with a specified level of detail in sampler samp using coordinates s, the texture to\nbe sampled is selected from the layer specified in the coordinates.\n\n\nPROFILE SUPPORT\ntex2DARRAYlod is only supported in gp4 and newer profiles.\n\n\nSEE ALSO\ntex2DARRAY, tex2DARRAYbias.de Sh\n\$1\n' )
end

function cg_tex2DARRAYlod_2:new()
	Node.new(self)
	self.name = 'tex2DARRAYlod'
	self.in_samp = self.add_port(Input('samp'))
	self.in_s = self.add_port(Input('s'))
	self.out = self.add_port(Output('out'))
end

function cg_tex2DARRAYlod_2:get_type(port)

	local type_samp = self.in_samp.get_output().get_type()
	local type_s = self.in_s.get_output().get_type()
	if ((type_samp == 'sampler2DARRAY')
	and (type_s == 'float4')) then
		return 'float4'
	end
	if ((type_samp == 'isampler2DARRAY')
	and (type_s == 'float4')) then
		return 'int4'
	end
	if ((type_samp == 'usampler2DARRAY')
	and (type_s == 'float4')) then
		return 'uint4'
	end
	return nil
end

function cg_tex2DARRAYlod_2:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_tex2DARRAYlod_2:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_samp = 'r' .. self.in_samp.get_output().hex()
	local in_s = 'r' .. self.in_s.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = tex2DARRAYlod( ' .. in_samp.. ', ' .. in_s.. ' );\n')
end

function cg_tex2DARRAYlod_2:get_tip(out)
	out.write( 'tex2DARRAYlod - performs a texture lookup with a specified level of detail in a given sampler array. ' )
end

-- #################################################### --
-- tex2DARRAYlod( samp, s, texelOff )
-- #################################################### --
local cg_tex2DARRAYlod_3 = class(Node)
function cg_tex2DARRAYlod_3:get_help(out)
	out.write( '\n\nNAME\ntex2DARRAYlod - performs a texture lookup with a specified level of detail in a given sampler array.\n\n\nSYNOPSIS\nfloat4 tex2DARRAYlod(sampler2DARRAY samp, float4 s)\nfloat4 tex2DARRAYlod(sampler2DARRAY samp, float4 s, int texelOff)\nint4 tex2DARRAYlod(isampler2DARRAY samp, float4 s)\nint4 tex2DARRAYlod(isampler2DARRAY samp, float4 s, int texelOff)\nuint4 tex2DARRAYlod(usampler2DARRAY samp, float4 s)\nuint4 tex2DARRAYlod(usampler2DARRAY samp, float4 s, int texelOff)\n\n\nPARAMETERS\nsamp Sampler array to lookup.\ns Coordinates to perform the lookup.The value used to select the layer should be passed in the\nvector component right after the regular coordinates. The level of detail value should be passed as\nthe last component of the coordinate vector.\ntexelOff Offset to be added to obtain the final texel.\n\n\nDESCRIPTION\nPerforms a texture lookup with a specified level of detail in sampler samp using coordinates s, the texture to\nbe sampled is selected from the layer specified in the coordinates.\n\n\nPROFILE SUPPORT\ntex2DARRAYlod is only supported in gp4 and newer profiles.\n\n\nSEE ALSO\ntex2DARRAY, tex2DARRAYbias.de Sh\n\$1\n' )
end

function cg_tex2DARRAYlod_3:new()
	Node.new(self)
	self.name = 'tex2DARRAYlod'
	self.in_samp = self.add_port(Input('samp'))
	self.in_s = self.add_port(Input('s'))
	self.in_texelOff = self.add_port(Input('texelOff'))
	self.out = self.add_port(Output('out'))
end

function cg_tex2DARRAYlod_3:get_type(port)

	local type_samp = self.in_samp.get_output().get_type()
	local type_s = self.in_s.get_output().get_type()
	local type_texelOff = self.in_texelOff.get_output().get_type()
	if ((type_samp == 'sampler2DARRAY')
	and (type_s == 'float4')
	and (type_texelOff == 'int')) then
		return 'float4'
	end
	if ((type_samp == 'isampler2DARRAY')
	and (type_s == 'float4')
	and (type_texelOff == 'int')) then
		return 'int4'
	end
	if ((type_samp == 'usampler2DARRAY')
	and (type_s == 'float4')
	and (type_texelOff == 'int')) then
		return 'uint4'
	end
	return nil
end

function cg_tex2DARRAYlod_3:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_tex2DARRAYlod_3:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_samp = 'r' .. self.in_samp.get_output().hex()
	local in_s = 'r' .. self.in_s.get_output().hex()
	local in_texelOff = 'r' .. self.in_texelOff.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = tex2DARRAYlod( ' .. in_samp.. ', ' .. in_s.. ', ' .. in_texelOff.. ' );\n')
end

function cg_tex2DARRAYlod_3:get_tip(out)
	out.write( 'tex2DARRAYlod - performs a texture lookup with a specified level of detail in a given sampler array. ' )
end

-- #################################################### --
-- tex2DARRAYproj( samp, s )
-- #################################################### --
local cg_tex2DARRAYproj_2 = class(Node)
function cg_tex2DARRAYproj_2:get_help(out)
	out.write( '\n\nNAME\ntex2DARRAYproj - performs a texture lookup with projection in a given sampler array.\n\n\nSYNOPSIS\nfloat4 tex2DARRAYproj(sampler2DARRAY samp, float3 s)\nfloat4 tex2DARRAYproj(sampler2DARRAY samp, float3 s, int texelOff)\nint4 tex2DARRAYproj(isampler2DARRAY samp, float3 s)\nint4 tex2DARRAYproj(isampler2DARRAY samp, float3 s, int texelOff)\nuint4 tex2DARRAYproj(usampler2DARRAY samp, float3 s)\nuint4 tex2DARRAYproj(usampler2DARRAY samp, float3 s, int texelOff)\n\n\nPARAMETERS\nsamp Sampler array to lookup.\ns Coordinates to perform the lookup. The value used to select the layer should be passed as the\ncomponent right after the lookup coordinates. The value used in the projection should be passed\nas the last component of the coordinate vector.\ntexelOff Offset to be added to obtain the final texel.\n\n\nDESCRIPTION\nPerforms a texture lookup in sampler array samp using coordinates s, the layer used in the lookup is first\nselected using the coordinate component right after the regular coordinates. The coordinates used in the\nlookup are then projected, that is, divided by the last component of the coordinate vector and them used in\nthe lookup.\n\n\nPROFILE SUPPORT\ntex2DARRAYproj is only supported in gp4 and newer profiles.\n\n\nSEE ALSO\ntex2D, tex2Dproj\n' )
end

function cg_tex2DARRAYproj_2:new()
	Node.new(self)
	self.name = 'tex2DARRAYproj'
	self.in_samp = self.add_port(Input('samp'))
	self.in_s = self.add_port(Input('s'))
	self.out = self.add_port(Output('out'))
end

function cg_tex2DARRAYproj_2:get_type(port)

	local type_samp = self.in_samp.get_output().get_type()
	local type_s = self.in_s.get_output().get_type()
	if ((type_samp == 'sampler2DARRAY')
	and (type_s == 'float3')) then
		return 'float4'
	end
	if ((type_samp == 'isampler2DARRAY')
	and (type_s == 'float3')) then
		return 'int4'
	end
	if ((type_samp == 'usampler2DARRAY')
	and (type_s == 'float3')) then
		return 'uint4'
	end
	return nil
end

function cg_tex2DARRAYproj_2:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_tex2DARRAYproj_2:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_samp = 'r' .. self.in_samp.get_output().hex()
	local in_s = 'r' .. self.in_s.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = tex2DARRAYproj( ' .. in_samp.. ', ' .. in_s.. ' );\n')
end

function cg_tex2DARRAYproj_2:get_tip(out)
	out.write( 'tex2DARRAYproj - performs a texture lookup with projection in a given sampler array. ' )
end

-- #################################################### --
-- tex2DARRAYproj( samp, s, texelOff )
-- #################################################### --
local cg_tex2DARRAYproj_3 = class(Node)
function cg_tex2DARRAYproj_3:get_help(out)
	out.write( '\n\nNAME\ntex2DARRAYproj - performs a texture lookup with projection in a given sampler array.\n\n\nSYNOPSIS\nfloat4 tex2DARRAYproj(sampler2DARRAY samp, float3 s)\nfloat4 tex2DARRAYproj(sampler2DARRAY samp, float3 s, int texelOff)\nint4 tex2DARRAYproj(isampler2DARRAY samp, float3 s)\nint4 tex2DARRAYproj(isampler2DARRAY samp, float3 s, int texelOff)\nuint4 tex2DARRAYproj(usampler2DARRAY samp, float3 s)\nuint4 tex2DARRAYproj(usampler2DARRAY samp, float3 s, int texelOff)\n\n\nPARAMETERS\nsamp Sampler array to lookup.\ns Coordinates to perform the lookup. The value used to select the layer should be passed as the\ncomponent right after the lookup coordinates. The value used in the projection should be passed\nas the last component of the coordinate vector.\ntexelOff Offset to be added to obtain the final texel.\n\n\nDESCRIPTION\nPerforms a texture lookup in sampler array samp using coordinates s, the layer used in the lookup is first\nselected using the coordinate component right after the regular coordinates. The coordinates used in the\nlookup are then projected, that is, divided by the last component of the coordinate vector and them used in\nthe lookup.\n\n\nPROFILE SUPPORT\ntex2DARRAYproj is only supported in gp4 and newer profiles.\n\n\nSEE ALSO\ntex2D, tex2Dproj\n' )
end

function cg_tex2DARRAYproj_3:new()
	Node.new(self)
	self.name = 'tex2DARRAYproj'
	self.in_samp = self.add_port(Input('samp'))
	self.in_s = self.add_port(Input('s'))
	self.in_texelOff = self.add_port(Input('texelOff'))
	self.out = self.add_port(Output('out'))
end

function cg_tex2DARRAYproj_3:get_type(port)

	local type_samp = self.in_samp.get_output().get_type()
	local type_s = self.in_s.get_output().get_type()
	local type_texelOff = self.in_texelOff.get_output().get_type()
	if ((type_samp == 'sampler2DARRAY')
	and (type_s == 'float3')
	and (type_texelOff == 'int')) then
		return 'float4'
	end
	if ((type_samp == 'isampler2DARRAY')
	and (type_s == 'float3')
	and (type_texelOff == 'int')) then
		return 'int4'
	end
	if ((type_samp == 'usampler2DARRAY')
	and (type_s == 'float3')
	and (type_texelOff == 'int')) then
		return 'uint4'
	end
	return nil
end

function cg_tex2DARRAYproj_3:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_tex2DARRAYproj_3:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_samp = 'r' .. self.in_samp.get_output().hex()
	local in_s = 'r' .. self.in_s.get_output().hex()
	local in_texelOff = 'r' .. self.in_texelOff.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = tex2DARRAYproj( ' .. in_samp.. ', ' .. in_s.. ', ' .. in_texelOff.. ' );\n')
end

function cg_tex2DARRAYproj_3:get_tip(out)
	out.write( 'tex2DARRAYproj - performs a texture lookup with projection in a given sampler array. ' )
end

-- #################################################### --
-- tex2DARRAYsize( samp, lod )
-- #################################################### --
local cg_tex2DARRAYsize_2 = class(Node)
function cg_tex2DARRAYsize_2:get_help(out)
	out.write( '\n\nNAME\ntex2DARRAYsize - returns the size of a given texture array image for a given level of detail.\n\n\nSYNOPSIS\nint3 tex2DARRAYsize(sampler2DARRAY samp, int lod)\nint3 tex2DARRAYsize(isampler2DARRAY samp, int lod)\nint3 tex2DARRAYsize(usampler2DARRAY samp, int lod)\n\n\nPARAMETERS\nsamp Sampler to be queried for size.\nlod Level of detail to obtain size.\n\n\nDESCRIPTION\nGiven a sampler array and a level of detail the size of one element of the corresponding texture array for a\ngiven level of detail is returned as a result of the operation.\n\n\nPROFILE SUPPORT\ntex2DARRAYsize is only supported in gp4 and newer profiles.\n\n\nSEE ALSO\ntex2Dsize.de Sh\n\$1\n' )
end

function cg_tex2DARRAYsize_2:new()
	Node.new(self)
	self.name = 'tex2DARRAYsize'
	self.in_samp = self.add_port(Input('samp'))
	self.in_lod = self.add_port(Input('lod'))
	self.out = self.add_port(Output('out'))
end

function cg_tex2DARRAYsize_2:get_type(port)

	local type_samp = self.in_samp.get_output().get_type()
	local type_lod = self.in_lod.get_output().get_type()
	if ((type_samp == 'sampler2DARRAY')
	and (type_lod == 'int')) then
		return 'int3'
	end
	if ((type_samp == 'isampler2DARRAY')
	and (type_lod == 'int')) then
		return 'int3'
	end
	if ((type_samp == 'usampler2DARRAY')
	and (type_lod == 'int')) then
		return 'int3'
	end
	return nil
end

function cg_tex2DARRAYsize_2:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_tex2DARRAYsize_2:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_samp = 'r' .. self.in_samp.get_output().hex()
	local in_lod = 'r' .. self.in_lod.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = tex2DARRAYsize( ' .. in_samp.. ', ' .. in_lod.. ' );\n')
end

function cg_tex2DARRAYsize_2:get_tip(out)
	out.write( 'tex2DARRAYsize - returns the size of a given texture array image for a given level of detail. ' )
end

-- #################################################### --
-- tex2Dbias( samp, s )
-- #################################################### --
local cg_tex2Dbias_2 = class(Node)
function cg_tex2Dbias_2:get_help(out)
	out.write( '\n\nNAME\ntex2Dbias - performs a texture lookup with bias in a given sampler.\n\n\nSYNOPSIS\nfloat4 tex2Dbias(sampler2D samp, float4 s)\nfloat4 tex2Dbias(sampler2D samp, float4 s, int texelOff)\nint4 tex2Dbias(isampler2D samp, float4 s)\nint4 tex2Dbias(isampler2D samp, float4 s, int texelOff)\nuint4 tex2Dbias(usampler2D samp, float4 s)\nuint4 tex2Dbias(usampler2D samp, float4 s, int texelOff)\n\n\nPARAMETERS\nsamp Sampler to lookup.\ns Coordinates to perform the lookup. The bias value should be passed as the last component of the\ncoordinate vector.\ntexelOff Offset to be added to obtain the final texel.\n\n\nDESCRIPTION\nPerforms a texture lookup with bias in sampler samp using coordinates s.\n\n\nPROFILE SUPPORT\ntex2Dbias is supported in fragment profiles starting with fp30 and in vertex profiles starting with vp40.\nVariants with texelOff are only supported in gp4 and newer profiles. Variants with integer samplers are also\nonly suppported in gp4 and newer profiles.\n\n\nSEE ALSO\ntex2Dlod, tex2Dcmpbias.de Sh\n\$1\n' )
end

function cg_tex2Dbias_2:new()
	Node.new(self)
	self.name = 'tex2Dbias'
	self.in_samp = self.add_port(Input('samp'))
	self.in_s = self.add_port(Input('s'))
	self.out = self.add_port(Output('out'))
end

function cg_tex2Dbias_2:get_type(port)

	local type_samp = self.in_samp.get_output().get_type()
	local type_s = self.in_s.get_output().get_type()
	if ((type_samp == 'sampler2D')
	and (type_s == 'float4')) then
		return 'float4'
	end
	if ((type_samp == 'isampler2D')
	and (type_s == 'float4')) then
		return 'int4'
	end
	if ((type_samp == 'usampler2D')
	and (type_s == 'float4')) then
		return 'uint4'
	end
	return nil
end

function cg_tex2Dbias_2:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_tex2Dbias_2:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_samp = 'r' .. self.in_samp.get_output().hex()
	local in_s = 'r' .. self.in_s.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = tex2Dbias( ' .. in_samp.. ', ' .. in_s.. ' );\n')
end

function cg_tex2Dbias_2:get_tip(out)
	out.write( 'tex2Dbias - performs a texture lookup with bias in a given sampler. ' )
end

-- #################################################### --
-- tex2Dbias( samp, s, texelOff )
-- #################################################### --
local cg_tex2Dbias_3 = class(Node)
function cg_tex2Dbias_3:get_help(out)
	out.write( '\n\nNAME\ntex2Dbias - performs a texture lookup with bias in a given sampler.\n\n\nSYNOPSIS\nfloat4 tex2Dbias(sampler2D samp, float4 s)\nfloat4 tex2Dbias(sampler2D samp, float4 s, int texelOff)\nint4 tex2Dbias(isampler2D samp, float4 s)\nint4 tex2Dbias(isampler2D samp, float4 s, int texelOff)\nuint4 tex2Dbias(usampler2D samp, float4 s)\nuint4 tex2Dbias(usampler2D samp, float4 s, int texelOff)\n\n\nPARAMETERS\nsamp Sampler to lookup.\ns Coordinates to perform the lookup. The bias value should be passed as the last component of the\ncoordinate vector.\ntexelOff Offset to be added to obtain the final texel.\n\n\nDESCRIPTION\nPerforms a texture lookup with bias in sampler samp using coordinates s.\n\n\nPROFILE SUPPORT\ntex2Dbias is supported in fragment profiles starting with fp30 and in vertex profiles starting with vp40.\nVariants with texelOff are only supported in gp4 and newer profiles. Variants with integer samplers are also\nonly suppported in gp4 and newer profiles.\n\n\nSEE ALSO\ntex2Dlod, tex2Dcmpbias.de Sh\n\$1\n' )
end

function cg_tex2Dbias_3:new()
	Node.new(self)
	self.name = 'tex2Dbias'
	self.in_samp = self.add_port(Input('samp'))
	self.in_s = self.add_port(Input('s'))
	self.in_texelOff = self.add_port(Input('texelOff'))
	self.out = self.add_port(Output('out'))
end

function cg_tex2Dbias_3:get_type(port)

	local type_samp = self.in_samp.get_output().get_type()
	local type_s = self.in_s.get_output().get_type()
	local type_texelOff = self.in_texelOff.get_output().get_type()
	if ((type_samp == 'sampler2D')
	and (type_s == 'float4')
	and (type_texelOff == 'int')) then
		return 'float4'
	end
	if ((type_samp == 'isampler2D')
	and (type_s == 'float4')
	and (type_texelOff == 'int')) then
		return 'int4'
	end
	if ((type_samp == 'usampler2D')
	and (type_s == 'float4')
	and (type_texelOff == 'int')) then
		return 'uint4'
	end
	return nil
end

function cg_tex2Dbias_3:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_tex2Dbias_3:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_samp = 'r' .. self.in_samp.get_output().hex()
	local in_s = 'r' .. self.in_s.get_output().hex()
	local in_texelOff = 'r' .. self.in_texelOff.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = tex2Dbias( ' .. in_samp.. ', ' .. in_s.. ', ' .. in_texelOff.. ' );\n')
end

function cg_tex2Dbias_3:get_tip(out)
	out.write( 'tex2Dbias - performs a texture lookup with bias in a given sampler. ' )
end

-- #################################################### --
-- tex2Dcmpbias( samp, s )
-- #################################################### --
local cg_tex2Dcmpbias_2 = class(Node)
function cg_tex2Dcmpbias_2:get_help(out)
	out.write( '\n\nNAME\ntex2Dcmpbias - performs a texture lookup with bias and shadow compare in a given sampler.\n\n\nSYNOPSIS\nfloat4 tex2Dcmpbias(sampler2D samp, float4 s)\nfloat4 tex2Dcmpbias(sampler2D samp, float4 s, int texelOff)\n\n\nPARAMETERS\nsamp Sampler to lookup.\ns Coordinates to perform the lookup. The value used in the shadow comparison should be passed\nright after the normal coordinates. The bias value should be passed as the last component of the\ncoordinate vector.\ntexelOff Offset to be added to obtain the final texel.\n\n\nDESCRIPTION\nPerforms a texture lookup with shadow compare and bias in sampler samp using coordinates s.\n\n\nPROFILE SUPPORT\ntex2Dcmpbias is supported in fragment profiles starting with fp40 and in vertex profiles starting with vp40.\nVariants with texelOff are only supported in gp4 and newer profiles.\n\n\nSEE ALSO\ntex2Dcmplod, tex2Dbias.de Sh\n\$1\n' )
end

function cg_tex2Dcmpbias_2:new()
	Node.new(self)
	self.name = 'tex2Dcmpbias'
	self.in_samp = self.add_port(Input('samp'))
	self.in_s = self.add_port(Input('s'))
	self.out = self.add_port(Output('out'))
end

function cg_tex2Dcmpbias_2:get_type(port)

	local type_samp = self.in_samp.get_output().get_type()
	local type_s = self.in_s.get_output().get_type()
	if ((type_samp == 'sampler2D')
	and (type_s == 'float4')) then
		return 'float4'
	end
	return nil
end

function cg_tex2Dcmpbias_2:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_tex2Dcmpbias_2:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_samp = 'r' .. self.in_samp.get_output().hex()
	local in_s = 'r' .. self.in_s.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = tex2Dcmpbias( ' .. in_samp.. ', ' .. in_s.. ' );\n')
end

function cg_tex2Dcmpbias_2:get_tip(out)
	out.write( 'tex2Dcmpbias - performs a texture lookup with bias and shadow compare in a given sampler. ' )
end

-- #################################################### --
-- tex2Dcmpbias( samp, s, texelOff )
-- #################################################### --
local cg_tex2Dcmpbias_3 = class(Node)
function cg_tex2Dcmpbias_3:get_help(out)
	out.write( '\n\nNAME\ntex2Dcmpbias - performs a texture lookup with bias and shadow compare in a given sampler.\n\n\nSYNOPSIS\nfloat4 tex2Dcmpbias(sampler2D samp, float4 s)\nfloat4 tex2Dcmpbias(sampler2D samp, float4 s, int texelOff)\n\n\nPARAMETERS\nsamp Sampler to lookup.\ns Coordinates to perform the lookup. The value used in the shadow comparison should be passed\nright after the normal coordinates. The bias value should be passed as the last component of the\ncoordinate vector.\ntexelOff Offset to be added to obtain the final texel.\n\n\nDESCRIPTION\nPerforms a texture lookup with shadow compare and bias in sampler samp using coordinates s.\n\n\nPROFILE SUPPORT\ntex2Dcmpbias is supported in fragment profiles starting with fp40 and in vertex profiles starting with vp40.\nVariants with texelOff are only supported in gp4 and newer profiles.\n\n\nSEE ALSO\ntex2Dcmplod, tex2Dbias.de Sh\n\$1\n' )
end

function cg_tex2Dcmpbias_3:new()
	Node.new(self)
	self.name = 'tex2Dcmpbias'
	self.in_samp = self.add_port(Input('samp'))
	self.in_s = self.add_port(Input('s'))
	self.in_texelOff = self.add_port(Input('texelOff'))
	self.out = self.add_port(Output('out'))
end

function cg_tex2Dcmpbias_3:get_type(port)

	local type_samp = self.in_samp.get_output().get_type()
	local type_s = self.in_s.get_output().get_type()
	local type_texelOff = self.in_texelOff.get_output().get_type()
	if ((type_samp == 'sampler2D')
	and (type_s == 'float4')
	and (type_texelOff == 'int')) then
		return 'float4'
	end
	return nil
end

function cg_tex2Dcmpbias_3:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_tex2Dcmpbias_3:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_samp = 'r' .. self.in_samp.get_output().hex()
	local in_s = 'r' .. self.in_s.get_output().hex()
	local in_texelOff = 'r' .. self.in_texelOff.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = tex2Dcmpbias( ' .. in_samp.. ', ' .. in_s.. ', ' .. in_texelOff.. ' );\n')
end

function cg_tex2Dcmpbias_3:get_tip(out)
	out.write( 'tex2Dcmpbias - performs a texture lookup with bias and shadow compare in a given sampler. ' )
end

-- #################################################### --
-- tex2Dcmplod( samp, s )
-- #################################################### --
local cg_tex2Dcmplod_2 = class(Node)
function cg_tex2Dcmplod_2:get_help(out)
	out.write( '\n\nNAME\ntex2Dcmplod - performs a texture lookup with a specified level of detail and a shadow compare in a given\nsampler.\n\n\nSYNOPSIS\nfloat4 tex2Dcmplod(sampler2D samp, float4 s)\nfloat4 tex2Dcmplod(sampler2D samp, float4 s, int texelOff)\n\n\nPARAMETERS\nsamp Sampler to lookup.\ns Coordinates to perform the lookup. The value used in the shadow comparison should be passed\nright after the normal coordinates. The level of detail corresponds to the last component of the\ncoordinate vector.\ntexelOff Offset to be added to obtain the final texel.\n\n\nDESCRIPTION\nPerforms a texture lookup with shadow compare and a specified level of detail in sampler samp using\ncoordinates s.\n\n\nPROFILE SUPPORT\ntex2Dcmplod is supported in fragment profiles starting with fp40 and in vertex profiles starting with vp40.\nVariants with texelOff are only supported in gp4 and newer profiles.\n\n\nSEE ALSO\ntex2Dlod, tex2Dcmpbias\n' )
end

function cg_tex2Dcmplod_2:new()
	Node.new(self)
	self.name = 'tex2Dcmplod'
	self.in_samp = self.add_port(Input('samp'))
	self.in_s = self.add_port(Input('s'))
	self.out = self.add_port(Output('out'))
end

function cg_tex2Dcmplod_2:get_type(port)

	local type_samp = self.in_samp.get_output().get_type()
	local type_s = self.in_s.get_output().get_type()
	if ((type_samp == 'sampler2D')
	and (type_s == 'float4')) then
		return 'float4'
	end
	return nil
end

function cg_tex2Dcmplod_2:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_tex2Dcmplod_2:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_samp = 'r' .. self.in_samp.get_output().hex()
	local in_s = 'r' .. self.in_s.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = tex2Dcmplod( ' .. in_samp.. ', ' .. in_s.. ' );\n')
end

function cg_tex2Dcmplod_2:get_tip(out)
	out.write( 'tex2Dcmplod - performs a texture lookup with a specified level of detail and a shadow compare in a given sampler. ' )
end

-- #################################################### --
-- tex2Dcmplod( samp, s, texelOff )
-- #################################################### --
local cg_tex2Dcmplod_3 = class(Node)
function cg_tex2Dcmplod_3:get_help(out)
	out.write( '\n\nNAME\ntex2Dcmplod - performs a texture lookup with a specified level of detail and a shadow compare in a given\nsampler.\n\n\nSYNOPSIS\nfloat4 tex2Dcmplod(sampler2D samp, float4 s)\nfloat4 tex2Dcmplod(sampler2D samp, float4 s, int texelOff)\n\n\nPARAMETERS\nsamp Sampler to lookup.\ns Coordinates to perform the lookup. The value used in the shadow comparison should be passed\nright after the normal coordinates. The level of detail corresponds to the last component of the\ncoordinate vector.\ntexelOff Offset to be added to obtain the final texel.\n\n\nDESCRIPTION\nPerforms a texture lookup with shadow compare and a specified level of detail in sampler samp using\ncoordinates s.\n\n\nPROFILE SUPPORT\ntex2Dcmplod is supported in fragment profiles starting with fp40 and in vertex profiles starting with vp40.\nVariants with texelOff are only supported in gp4 and newer profiles.\n\n\nSEE ALSO\ntex2Dlod, tex2Dcmpbias\n' )
end

function cg_tex2Dcmplod_3:new()
	Node.new(self)
	self.name = 'tex2Dcmplod'
	self.in_samp = self.add_port(Input('samp'))
	self.in_s = self.add_port(Input('s'))
	self.in_texelOff = self.add_port(Input('texelOff'))
	self.out = self.add_port(Output('out'))
end

function cg_tex2Dcmplod_3:get_type(port)

	local type_samp = self.in_samp.get_output().get_type()
	local type_s = self.in_s.get_output().get_type()
	local type_texelOff = self.in_texelOff.get_output().get_type()
	if ((type_samp == 'sampler2D')
	and (type_s == 'float4')
	and (type_texelOff == 'int')) then
		return 'float4'
	end
	return nil
end

function cg_tex2Dcmplod_3:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_tex2Dcmplod_3:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_samp = 'r' .. self.in_samp.get_output().hex()
	local in_s = 'r' .. self.in_s.get_output().hex()
	local in_texelOff = 'r' .. self.in_texelOff.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = tex2Dcmplod( ' .. in_samp.. ', ' .. in_s.. ', ' .. in_texelOff.. ' );\n')
end

function cg_tex2Dcmplod_3:get_tip(out)
	out.write( 'tex2Dcmplod - performs a texture lookup with a specified level of detail and a shadow compare in a given sampler. ' )
end

-- #################################################### --
-- tex2Dfetch( samp, s )
-- #################################################### --
local cg_tex2Dfetch_2 = class(Node)
function cg_tex2Dfetch_2:get_help(out)
	out.write( '\n\nNAME\ntex2Dfetch - performs an unfiltered texture lookup in a given sampler.\n\n\nSYNOPSIS\nfloat4 tex2Dfetch(sampler2D samp, int4 s)\nfloat4 tex2Dfetch(sampler2D samp, int4 s, int texelOff)\nint4 tex2Dfetch(isampler2D samp, int4 s)\nint4 tex2Dfetch(isampler2D samp, int4 s, int texelOff)\nuint4 tex2Dfetch(usampler2D samp, int4 s)\nuint4 tex2Dfetch(usampler2D samp, int4 s, int texelOff)\n\n\nPARAMETERS\nsamp Sampler to lookup.\ns Coordinates to perform the lookup. The level of detail is stored in the last component of the\ncoordinate vector.\ntexelOff Offset to be added to obtain the final texel.\n\n\nDESCRIPTION\nPerforms an unfiltered texture lookup in sampler samp using coordinates s. The level of detail is provided\nby the last component of the coordinate vector. May use texel offset texelOff to compute final texel.\n\n\nPROFILE SUPPORT\ntex2Dfetch is only supported in gp4 and newer profiles.\n\n\nSEE ALSO\ntex2D, tex2DARRAYfetch.de Sh\n\$1\n' )
end

function cg_tex2Dfetch_2:new()
	Node.new(self)
	self.name = 'tex2Dfetch'
	self.in_samp = self.add_port(Input('samp'))
	self.in_s = self.add_port(Input('s'))
	self.out = self.add_port(Output('out'))
end

function cg_tex2Dfetch_2:get_type(port)

	local type_samp = self.in_samp.get_output().get_type()
	local type_s = self.in_s.get_output().get_type()
	if ((type_samp == 'sampler2D')
	and (type_s == 'int4')) then
		return 'float4'
	end
	if ((type_samp == 'isampler2D')
	and (type_s == 'int4')) then
		return 'int4'
	end
	if ((type_samp == 'usampler2D')
	and (type_s == 'int4')) then
		return 'uint4'
	end
	return nil
end

function cg_tex2Dfetch_2:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_tex2Dfetch_2:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_samp = 'r' .. self.in_samp.get_output().hex()
	local in_s = 'r' .. self.in_s.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = tex2Dfetch( ' .. in_samp.. ', ' .. in_s.. ' );\n')
end

function cg_tex2Dfetch_2:get_tip(out)
	out.write( 'tex2Dfetch - performs an unfiltered texture lookup in a given sampler. ' )
end

-- #################################################### --
-- tex2Dfetch( samp, s, texelOff )
-- #################################################### --
local cg_tex2Dfetch_3 = class(Node)
function cg_tex2Dfetch_3:get_help(out)
	out.write( '\n\nNAME\ntex2Dfetch - performs an unfiltered texture lookup in a given sampler.\n\n\nSYNOPSIS\nfloat4 tex2Dfetch(sampler2D samp, int4 s)\nfloat4 tex2Dfetch(sampler2D samp, int4 s, int texelOff)\nint4 tex2Dfetch(isampler2D samp, int4 s)\nint4 tex2Dfetch(isampler2D samp, int4 s, int texelOff)\nuint4 tex2Dfetch(usampler2D samp, int4 s)\nuint4 tex2Dfetch(usampler2D samp, int4 s, int texelOff)\n\n\nPARAMETERS\nsamp Sampler to lookup.\ns Coordinates to perform the lookup. The level of detail is stored in the last component of the\ncoordinate vector.\ntexelOff Offset to be added to obtain the final texel.\n\n\nDESCRIPTION\nPerforms an unfiltered texture lookup in sampler samp using coordinates s. The level of detail is provided\nby the last component of the coordinate vector. May use texel offset texelOff to compute final texel.\n\n\nPROFILE SUPPORT\ntex2Dfetch is only supported in gp4 and newer profiles.\n\n\nSEE ALSO\ntex2D, tex2DARRAYfetch.de Sh\n\$1\n' )
end

function cg_tex2Dfetch_3:new()
	Node.new(self)
	self.name = 'tex2Dfetch'
	self.in_samp = self.add_port(Input('samp'))
	self.in_s = self.add_port(Input('s'))
	self.in_texelOff = self.add_port(Input('texelOff'))
	self.out = self.add_port(Output('out'))
end

function cg_tex2Dfetch_3:get_type(port)

	local type_samp = self.in_samp.get_output().get_type()
	local type_s = self.in_s.get_output().get_type()
	local type_texelOff = self.in_texelOff.get_output().get_type()
	if ((type_samp == 'sampler2D')
	and (type_s == 'int4')
	and (type_texelOff == 'int')) then
		return 'float4'
	end
	if ((type_samp == 'isampler2D')
	and (type_s == 'int4')
	and (type_texelOff == 'int')) then
		return 'int4'
	end
	if ((type_samp == 'usampler2D')
	and (type_s == 'int4')
	and (type_texelOff == 'int')) then
		return 'uint4'
	end
	return nil
end

function cg_tex2Dfetch_3:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_tex2Dfetch_3:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_samp = 'r' .. self.in_samp.get_output().hex()
	local in_s = 'r' .. self.in_s.get_output().hex()
	local in_texelOff = 'r' .. self.in_texelOff.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = tex2Dfetch( ' .. in_samp.. ', ' .. in_s.. ', ' .. in_texelOff.. ' );\n')
end

function cg_tex2Dfetch_3:get_tip(out)
	out.write( 'tex2Dfetch - performs an unfiltered texture lookup in a given sampler. ' )
end

-- #################################################### --
-- tex2Dlod( samp, s )
-- #################################################### --
local cg_tex2Dlod_2 = class(Node)
function cg_tex2Dlod_2:get_help(out)
	out.write( '\n\nNAME\ntex2Dlod - performs a texture lookup with a specified level of detail in a given sampler.\n\n\nSYNOPSIS\nfloat4 tex2Dlod(sampler2D samp, float4 s)\nfloat4 tex2Dlod(sampler2D samp, float4 s, int texelOff)\nint4 tex2Dlod(isampler2D samp, float4 s)\nint4 tex2Dlod(isampler2D samp, float4 s, int texelOff)\nuint4 tex2Dlod(usampler2D samp, float4 s)\nuint4 tex2Dlod(usampler2D samp, float4 s, int texelOff)\n\n\nPARAMETERS\nsamp Sampler to lookup.\ns Coordinates to perform the lookup. The level of detail should be passed as the last component of\nthe coordinate vector.\ntexelOff Offset to be added to obtain the final texel.\n\n\nDESCRIPTION\nPerforms a texture lookup with a specified level of detail in sampler samp using coordinates s.\n\n\nPROFILE SUPPORT\ntex2Dlod is supported in fragment profiles starting with fp40 and in vertex profiles starting with vp40.\nVariants with texelOff are only supported in gp4 and newer profiles. Variants with integer samplers are also\nonly suppported in gp4 and newer profiles.\n\n\nSEE ALSO\ntex2Dbias, tex2Dcmplod.de Sh\n\$1\n' )
end

function cg_tex2Dlod_2:new()
	Node.new(self)
	self.name = 'tex2Dlod'
	self.in_samp = self.add_port(Input('samp'))
	self.in_s = self.add_port(Input('s'))
	self.out = self.add_port(Output('out'))
end

function cg_tex2Dlod_2:get_type(port)

	local type_samp = self.in_samp.get_output().get_type()
	local type_s = self.in_s.get_output().get_type()
	if ((type_samp == 'sampler2D')
	and (type_s == 'float4')) then
		return 'float4'
	end
	if ((type_samp == 'isampler2D')
	and (type_s == 'float4')) then
		return 'int4'
	end
	if ((type_samp == 'usampler2D')
	and (type_s == 'float4')) then
		return 'uint4'
	end
	return nil
end

function cg_tex2Dlod_2:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_tex2Dlod_2:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_samp = 'r' .. self.in_samp.get_output().hex()
	local in_s = 'r' .. self.in_s.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = tex2Dlod( ' .. in_samp.. ', ' .. in_s.. ' );\n')
end

function cg_tex2Dlod_2:get_tip(out)
	out.write( 'tex2Dlod - performs a texture lookup with a specified level of detail in a given sampler. ' )
end

-- #################################################### --
-- tex2Dlod( samp, s, texelOff )
-- #################################################### --
local cg_tex2Dlod_3 = class(Node)
function cg_tex2Dlod_3:get_help(out)
	out.write( '\n\nNAME\ntex2Dlod - performs a texture lookup with a specified level of detail in a given sampler.\n\n\nSYNOPSIS\nfloat4 tex2Dlod(sampler2D samp, float4 s)\nfloat4 tex2Dlod(sampler2D samp, float4 s, int texelOff)\nint4 tex2Dlod(isampler2D samp, float4 s)\nint4 tex2Dlod(isampler2D samp, float4 s, int texelOff)\nuint4 tex2Dlod(usampler2D samp, float4 s)\nuint4 tex2Dlod(usampler2D samp, float4 s, int texelOff)\n\n\nPARAMETERS\nsamp Sampler to lookup.\ns Coordinates to perform the lookup. The level of detail should be passed as the last component of\nthe coordinate vector.\ntexelOff Offset to be added to obtain the final texel.\n\n\nDESCRIPTION\nPerforms a texture lookup with a specified level of detail in sampler samp using coordinates s.\n\n\nPROFILE SUPPORT\ntex2Dlod is supported in fragment profiles starting with fp40 and in vertex profiles starting with vp40.\nVariants with texelOff are only supported in gp4 and newer profiles. Variants with integer samplers are also\nonly suppported in gp4 and newer profiles.\n\n\nSEE ALSO\ntex2Dbias, tex2Dcmplod.de Sh\n\$1\n' )
end

function cg_tex2Dlod_3:new()
	Node.new(self)
	self.name = 'tex2Dlod'
	self.in_samp = self.add_port(Input('samp'))
	self.in_s = self.add_port(Input('s'))
	self.in_texelOff = self.add_port(Input('texelOff'))
	self.out = self.add_port(Output('out'))
end

function cg_tex2Dlod_3:get_type(port)

	local type_samp = self.in_samp.get_output().get_type()
	local type_s = self.in_s.get_output().get_type()
	local type_texelOff = self.in_texelOff.get_output().get_type()
	if ((type_samp == 'sampler2D')
	and (type_s == 'float4')
	and (type_texelOff == 'int')) then
		return 'float4'
	end
	if ((type_samp == 'isampler2D')
	and (type_s == 'float4')
	and (type_texelOff == 'int')) then
		return 'int4'
	end
	if ((type_samp == 'usampler2D')
	and (type_s == 'float4')
	and (type_texelOff == 'int')) then
		return 'uint4'
	end
	return nil
end

function cg_tex2Dlod_3:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_tex2Dlod_3:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_samp = 'r' .. self.in_samp.get_output().hex()
	local in_s = 'r' .. self.in_s.get_output().hex()
	local in_texelOff = 'r' .. self.in_texelOff.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = tex2Dlod( ' .. in_samp.. ', ' .. in_s.. ', ' .. in_texelOff.. ' );\n')
end

function cg_tex2Dlod_3:get_tip(out)
	out.write( 'tex2Dlod - performs a texture lookup with a specified level of detail in a given sampler. ' )
end

-- #################################################### --
-- tex2Dproj( samp, s )
-- #################################################### --
local cg_tex2Dproj_2 = class(Node)
function cg_tex2Dproj_2:get_help(out)
	out.write( '\n\nNAME\ntex2Dproj - performs a texture lookup with projection in a given sampler. May perform a shadow\ncomparison if argument for shadow comparison is provided.\n\n\nSYNOPSIS\nfloat4 tex2Dproj(sampler2D samp, float3 s)\nfloat4 tex2Dproj(sampler2D samp, float3 s, int texelOff)\nfloat4 tex2Dproj(sampler2D samp, float4 s)\nfloat4 tex2Dproj(sampler2D samp, float4 s, int texelOff)\nint4 tex2Dproj(isampler2D samp, float3 s)\nint4 tex2Dproj(isampler2D samp, float3 s, int texelOff)\nuint4 tex2Dproj(usampler2D samp, float3 s)\nuint4 tex2Dproj(usampler2D samp, float3 s, int texelOff)\n\n\nPARAMETERS\nsamp Sampler to lookup.\ns Coordinates to perform the lookup. The value used in the projection should be passed as the last\ncomponent of the coordinate vector. The value used in the shadow comparison, if present, should\nbe passed as the next-to-last component of the coordinate vector.\ntexelOff Offset to be added to obtain the final texel.\n\n\nDESCRIPTION\nPerforms a texture lookup in sampler samp using coordinates s, the coordinates used in the lookup are first\nprojected, that is, divided by the last component of the coordinate vector and them used in the lookup. If an\nextra coordinate is present it is used to perform a shadow comparison, the value used in the shadow\ncomparison is always the next-to-last component in the coordinate vector.\n\n\nPROFILE SUPPORT\ntex2Dproj is supported in all fragment profiles and all vertex profiles starting with vp40, variants with\nshadow comparison are only supported in fp40 and newer profiles, variants with texel offsets are only\nsupported in gp4 and newer profiles.\n\n\nSEE ALSO\ntex2D, tex2DARRAYproj\n' )
end

function cg_tex2Dproj_2:new()
	Node.new(self)
	self.name = 'tex2Dproj'
	self.in_samp = self.add_port(Input('samp'))
	self.in_s = self.add_port(Input('s'))
	self.out = self.add_port(Output('out'))
end

function cg_tex2Dproj_2:get_type(port)

	local type_samp = self.in_samp.get_output().get_type()
	local type_s = self.in_s.get_output().get_type()
	if ((type_samp == 'sampler2D')
	and (type_s == 'float3')) then
		return 'float4'
	end
	if ((type_samp == 'sampler2D')
	and (type_s == 'float4')) then
		return 'float4'
	end
	if ((type_samp == 'isampler2D')
	and (type_s == 'float3')) then
		return 'int4'
	end
	if ((type_samp == 'usampler2D')
	and (type_s == 'float3')) then
		return 'uint4'
	end
	return nil
end

function cg_tex2Dproj_2:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_tex2Dproj_2:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_samp = 'r' .. self.in_samp.get_output().hex()
	local in_s = 'r' .. self.in_s.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = tex2Dproj( ' .. in_samp.. ', ' .. in_s.. ' );\n')
end

function cg_tex2Dproj_2:get_tip(out)
	out.write( 'tex2Dproj - performs a texture lookup with projection in a given sampler. May perform a shadow comparison if argument for shadow comparison is provided. ' )
end

-- #################################################### --
-- tex2Dproj( samp, s, texelOff )
-- #################################################### --
local cg_tex2Dproj_3 = class(Node)
function cg_tex2Dproj_3:get_help(out)
	out.write( '\n\nNAME\ntex2Dproj - performs a texture lookup with projection in a given sampler. May perform a shadow\ncomparison if argument for shadow comparison is provided.\n\n\nSYNOPSIS\nfloat4 tex2Dproj(sampler2D samp, float3 s)\nfloat4 tex2Dproj(sampler2D samp, float3 s, int texelOff)\nfloat4 tex2Dproj(sampler2D samp, float4 s)\nfloat4 tex2Dproj(sampler2D samp, float4 s, int texelOff)\nint4 tex2Dproj(isampler2D samp, float3 s)\nint4 tex2Dproj(isampler2D samp, float3 s, int texelOff)\nuint4 tex2Dproj(usampler2D samp, float3 s)\nuint4 tex2Dproj(usampler2D samp, float3 s, int texelOff)\n\n\nPARAMETERS\nsamp Sampler to lookup.\ns Coordinates to perform the lookup. The value used in the projection should be passed as the last\ncomponent of the coordinate vector. The value used in the shadow comparison, if present, should\nbe passed as the next-to-last component of the coordinate vector.\ntexelOff Offset to be added to obtain the final texel.\n\n\nDESCRIPTION\nPerforms a texture lookup in sampler samp using coordinates s, the coordinates used in the lookup are first\nprojected, that is, divided by the last component of the coordinate vector and them used in the lookup. If an\nextra coordinate is present it is used to perform a shadow comparison, the value used in the shadow\ncomparison is always the next-to-last component in the coordinate vector.\n\n\nPROFILE SUPPORT\ntex2Dproj is supported in all fragment profiles and all vertex profiles starting with vp40, variants with\nshadow comparison are only supported in fp40 and newer profiles, variants with texel offsets are only\nsupported in gp4 and newer profiles.\n\n\nSEE ALSO\ntex2D, tex2DARRAYproj\n' )
end

function cg_tex2Dproj_3:new()
	Node.new(self)
	self.name = 'tex2Dproj'
	self.in_samp = self.add_port(Input('samp'))
	self.in_s = self.add_port(Input('s'))
	self.in_texelOff = self.add_port(Input('texelOff'))
	self.out = self.add_port(Output('out'))
end

function cg_tex2Dproj_3:get_type(port)

	local type_samp = self.in_samp.get_output().get_type()
	local type_s = self.in_s.get_output().get_type()
	local type_texelOff = self.in_texelOff.get_output().get_type()
	if ((type_samp == 'sampler2D')
	and (type_s == 'float3')
	and (type_texelOff == 'int')) then
		return 'float4'
	end
	if ((type_samp == 'sampler2D')
	and (type_s == 'float4')
	and (type_texelOff == 'int')) then
		return 'float4'
	end
	if ((type_samp == 'isampler2D')
	and (type_s == 'float3')
	and (type_texelOff == 'int')) then
		return 'int4'
	end
	if ((type_samp == 'usampler2D')
	and (type_s == 'float3')
	and (type_texelOff == 'int')) then
		return 'uint4'
	end
	return nil
end

function cg_tex2Dproj_3:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_tex2Dproj_3:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_samp = 'r' .. self.in_samp.get_output().hex()
	local in_s = 'r' .. self.in_s.get_output().hex()
	local in_texelOff = 'r' .. self.in_texelOff.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = tex2Dproj( ' .. in_samp.. ', ' .. in_s.. ', ' .. in_texelOff.. ' );\n')
end

function cg_tex2Dproj_3:get_tip(out)
	out.write( 'tex2Dproj - performs a texture lookup with projection in a given sampler. May perform a shadow comparison if argument for shadow comparison is provided. ' )
end

-- #################################################### --
-- tex2Dsize( samp, lod )
-- #################################################### --
local cg_tex2Dsize_2 = class(Node)
function cg_tex2Dsize_2:get_help(out)
	out.write( '\n\nNAME\ntex2Dsize - returns the size of a given texture image for a given level of detail.\n\n\nSYNOPSIS\nint3 tex2Dsize(sampler2D samp, int lod)\nint3 tex2Dsize(isampler2D samp, int lod)\nint3 tex2Dsize(usampler2D samp, int lod)\n\n\nPARAMETERS\nsamp Sampler to be queried for size.\nlod Level of detail to obtain size.\n\n\nDESCRIPTION\nGiven a sampler and a level of detail the size of the corresponding texture image is returned as the result of\nthe operation.\n\n\nPROFILE SUPPORT\ntex2Dsize is only supported in gp4 and newer profiles.\n\n\nSEE ALSO\ntex2D, tex2DARRAYsize.de Sh\n\$1\n' )
end

function cg_tex2Dsize_2:new()
	Node.new(self)
	self.name = 'tex2Dsize'
	self.in_samp = self.add_port(Input('samp'))
	self.in_lod = self.add_port(Input('lod'))
	self.out = self.add_port(Output('out'))
end

function cg_tex2Dsize_2:get_type(port)

	local type_samp = self.in_samp.get_output().get_type()
	local type_lod = self.in_lod.get_output().get_type()
	if ((type_samp == 'sampler2D')
	and (type_lod == 'int')) then
		return 'int3'
	end
	if ((type_samp == 'isampler2D')
	and (type_lod == 'int')) then
		return 'int3'
	end
	if ((type_samp == 'usampler2D')
	and (type_lod == 'int')) then
		return 'int3'
	end
	return nil
end

function cg_tex2Dsize_2:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_tex2Dsize_2:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_samp = 'r' .. self.in_samp.get_output().hex()
	local in_lod = 'r' .. self.in_lod.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = tex2Dsize( ' .. in_samp.. ', ' .. in_lod.. ' );\n')
end

function cg_tex2Dsize_2:get_tip(out)
	out.write( 'tex2Dsize - returns the size of a given texture image for a given level of detail. ' )
end

-- #################################################### --
-- tex3D( samp, s )
-- #################################################### --
local cg_tex3D_2 = class(Node)
function cg_tex3D_2:get_help(out)
	out.write( '\n\nNAME\ntex3D - performs a texture lookup in a given 3D sampler. May also use pre computed derivatives if those\nare provided.\n\n\nSYNOPSIS\nfloat4 tex3D(sampler3D samp, float3 s)\nfloat4 tex3D(sampler3D samp, float3 s, int texelOff)\nfloat4 tex3D(sampler3D samp, float3 s, float3 dx, float3 dy)\nfloat4 tex3D(sampler3D samp, float3 s, float3 dx, float3 dy, int texelOff)\nint4 tex3D(isampler3D samp, float3 s)\nint4 tex3D(isampler3D samp, float3 s, int texelOff)\nint4 tex3D(isampler3D samp, float3 s, float3 dx, float3 dy)\nint4 tex3D(isampler3D samp, float3 s, float3 dx, float3 dy, int texelOff)\nuint4 tex3D(usampler3D samp, float3 s)\nuint4 tex3D(usampler3D samp, float3 s, int texelOff)\nuint4 tex3D(usampler3D samp, float3 s, float3 dx, float3 dy)\nuint4 tex3D(usampler3D samp, float3 s, float3 dx, float3 dy,\nint texelOff)\n\n\nPARAMETERS\nsamp Sampler to lookup.\ns Coordinates to perform the lookup.\ndx Pre computed derivative along the x axis.\ndy Pre computed derivative along the y axis.\ntexelOff Offset to be added to obtain the final texel.\n\n\nDESCRIPTION\nPerforms a texture lookup in sampler samp using coordinates s, may use and derivatives dx and dy, also\nmay use texel offset texelOff to compute final texel.\n\n\nPROFILE SUPPORT\ntex3D is supported in all fragment profiles and all vertex profiles starting with vp40, variants with texel\noffsets are only supported in gp4 and newer profiles. Variants with integer samplers are also only\nsuppported in gp4 and newer profiles.\n\n\nSEE ALSO\ntex3Dbias, tex3Dlod, tex3Dproj\n' )
end

function cg_tex3D_2:new()
	Node.new(self)
	self.name = 'tex3D'
	self.in_samp = self.add_port(Input('samp'))
	self.in_s = self.add_port(Input('s'))
	self.out = self.add_port(Output('out'))
end

function cg_tex3D_2:get_type(port)

	local type_samp = self.in_samp.get_output().get_type()
	local type_s = self.in_s.get_output().get_type()
	if ((type_samp == 'sampler3D')
	and (type_s == 'float3')) then
		return 'float4'
	end
	if ((type_samp == 'isampler3D')
	and (type_s == 'float3')) then
		return 'int4'
	end
	if ((type_samp == 'usampler3D')
	and (type_s == 'float3')) then
		return 'uint4'
	end
	return nil
end

function cg_tex3D_2:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_tex3D_2:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_samp = 'r' .. self.in_samp.get_output().hex()
	local in_s = 'r' .. self.in_s.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = tex3D( ' .. in_samp.. ', ' .. in_s.. ' );\n')
end

function cg_tex3D_2:get_tip(out)
	out.write( 'tex3D - performs a texture lookup in a given 3D sampler. May also use pre computed derivatives if those are provided. ' )
end

-- #################################################### --
-- tex3D( samp, s, texelOff )
-- #################################################### --
local cg_tex3D_3 = class(Node)
function cg_tex3D_3:get_help(out)
	out.write( '\n\nNAME\ntex3D - performs a texture lookup in a given 3D sampler. May also use pre computed derivatives if those\nare provided.\n\n\nSYNOPSIS\nfloat4 tex3D(sampler3D samp, float3 s)\nfloat4 tex3D(sampler3D samp, float3 s, int texelOff)\nfloat4 tex3D(sampler3D samp, float3 s, float3 dx, float3 dy)\nfloat4 tex3D(sampler3D samp, float3 s, float3 dx, float3 dy, int texelOff)\nint4 tex3D(isampler3D samp, float3 s)\nint4 tex3D(isampler3D samp, float3 s, int texelOff)\nint4 tex3D(isampler3D samp, float3 s, float3 dx, float3 dy)\nint4 tex3D(isampler3D samp, float3 s, float3 dx, float3 dy, int texelOff)\nuint4 tex3D(usampler3D samp, float3 s)\nuint4 tex3D(usampler3D samp, float3 s, int texelOff)\nuint4 tex3D(usampler3D samp, float3 s, float3 dx, float3 dy)\nuint4 tex3D(usampler3D samp, float3 s, float3 dx, float3 dy,\nint texelOff)\n\n\nPARAMETERS\nsamp Sampler to lookup.\ns Coordinates to perform the lookup.\ndx Pre computed derivative along the x axis.\ndy Pre computed derivative along the y axis.\ntexelOff Offset to be added to obtain the final texel.\n\n\nDESCRIPTION\nPerforms a texture lookup in sampler samp using coordinates s, may use and derivatives dx and dy, also\nmay use texel offset texelOff to compute final texel.\n\n\nPROFILE SUPPORT\ntex3D is supported in all fragment profiles and all vertex profiles starting with vp40, variants with texel\noffsets are only supported in gp4 and newer profiles. Variants with integer samplers are also only\nsuppported in gp4 and newer profiles.\n\n\nSEE ALSO\ntex3Dbias, tex3Dlod, tex3Dproj\n' )
end

function cg_tex3D_3:new()
	Node.new(self)
	self.name = 'tex3D'
	self.in_samp = self.add_port(Input('samp'))
	self.in_s = self.add_port(Input('s'))
	self.in_texelOff = self.add_port(Input('texelOff'))
	self.out = self.add_port(Output('out'))
end

function cg_tex3D_3:get_type(port)

	local type_samp = self.in_samp.get_output().get_type()
	local type_s = self.in_s.get_output().get_type()
	local type_texelOff = self.in_texelOff.get_output().get_type()
	if ((type_samp == 'sampler3D')
	and (type_s == 'float3')
	and (type_texelOff == 'int')) then
		return 'float4'
	end
	if ((type_samp == 'isampler3D')
	and (type_s == 'float3')
	and (type_texelOff == 'int')) then
		return 'int4'
	end
	if ((type_samp == 'usampler3D')
	and (type_s == 'float3')
	and (type_texelOff == 'int')) then
		return 'uint4'
	end
	return nil
end

function cg_tex3D_3:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_tex3D_3:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_samp = 'r' .. self.in_samp.get_output().hex()
	local in_s = 'r' .. self.in_s.get_output().hex()
	local in_texelOff = 'r' .. self.in_texelOff.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = tex3D( ' .. in_samp.. ', ' .. in_s.. ', ' .. in_texelOff.. ' );\n')
end

function cg_tex3D_3:get_tip(out)
	out.write( 'tex3D - performs a texture lookup in a given 3D sampler. May also use pre computed derivatives if those are provided. ' )
end

-- #################################################### --
-- tex3D( samp, s, dx, dy )
-- #################################################### --
local cg_tex3D_4 = class(Node)
function cg_tex3D_4:get_help(out)
	out.write( '\n\nNAME\ntex3D - performs a texture lookup in a given 3D sampler. May also use pre computed derivatives if those\nare provided.\n\n\nSYNOPSIS\nfloat4 tex3D(sampler3D samp, float3 s)\nfloat4 tex3D(sampler3D samp, float3 s, int texelOff)\nfloat4 tex3D(sampler3D samp, float3 s, float3 dx, float3 dy)\nfloat4 tex3D(sampler3D samp, float3 s, float3 dx, float3 dy, int texelOff)\nint4 tex3D(isampler3D samp, float3 s)\nint4 tex3D(isampler3D samp, float3 s, int texelOff)\nint4 tex3D(isampler3D samp, float3 s, float3 dx, float3 dy)\nint4 tex3D(isampler3D samp, float3 s, float3 dx, float3 dy, int texelOff)\nuint4 tex3D(usampler3D samp, float3 s)\nuint4 tex3D(usampler3D samp, float3 s, int texelOff)\nuint4 tex3D(usampler3D samp, float3 s, float3 dx, float3 dy)\nuint4 tex3D(usampler3D samp, float3 s, float3 dx, float3 dy,\nint texelOff)\n\n\nPARAMETERS\nsamp Sampler to lookup.\ns Coordinates to perform the lookup.\ndx Pre computed derivative along the x axis.\ndy Pre computed derivative along the y axis.\ntexelOff Offset to be added to obtain the final texel.\n\n\nDESCRIPTION\nPerforms a texture lookup in sampler samp using coordinates s, may use and derivatives dx and dy, also\nmay use texel offset texelOff to compute final texel.\n\n\nPROFILE SUPPORT\ntex3D is supported in all fragment profiles and all vertex profiles starting with vp40, variants with texel\noffsets are only supported in gp4 and newer profiles. Variants with integer samplers are also only\nsuppported in gp4 and newer profiles.\n\n\nSEE ALSO\ntex3Dbias, tex3Dlod, tex3Dproj\n' )
end

function cg_tex3D_4:new()
	Node.new(self)
	self.name = 'tex3D'
	self.in_samp = self.add_port(Input('samp'))
	self.in_s = self.add_port(Input('s'))
	self.in_dx = self.add_port(Input('dx'))
	self.in_dy = self.add_port(Input('dy'))
	self.out = self.add_port(Output('out'))
end

function cg_tex3D_4:get_type(port)

	local type_samp = self.in_samp.get_output().get_type()
	local type_s = self.in_s.get_output().get_type()
	local type_dx = self.in_dx.get_output().get_type()
	local type_dy = self.in_dy.get_output().get_type()
	if ((type_samp == 'sampler3D')
	and (type_s == 'float3')
	and (type_dx == 'float3')
	and (type_dy == 'float3')) then
		return 'float4'
	end
	if ((type_samp == 'isampler3D')
	and (type_s == 'float3')
	and (type_dx == 'float3')
	and (type_dy == 'float3')) then
		return 'int4'
	end
	if ((type_samp == 'usampler3D')
	and (type_s == 'float3')
	and (type_dx == 'float3')
	and (type_dy == 'float3')) then
		return 'uint4'
	end
	return nil
end

function cg_tex3D_4:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_tex3D_4:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_samp = 'r' .. self.in_samp.get_output().hex()
	local in_s = 'r' .. self.in_s.get_output().hex()
	local in_dx = 'r' .. self.in_dx.get_output().hex()
	local in_dy = 'r' .. self.in_dy.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = tex3D( ' .. in_samp.. ', ' .. in_s.. ', ' .. in_dx.. ', ' .. in_dy.. ' );\n')
end

function cg_tex3D_4:get_tip(out)
	out.write( 'tex3D - performs a texture lookup in a given 3D sampler. May also use pre computed derivatives if those are provided. ' )
end

-- #################################################### --
-- tex3D( samp, s, dx, dy, texelOff )
-- #################################################### --
local cg_tex3D_5 = class(Node)
function cg_tex3D_5:get_help(out)
	out.write( '\n\nNAME\ntex3D - performs a texture lookup in a given 3D sampler. May also use pre computed derivatives if those\nare provided.\n\n\nSYNOPSIS\nfloat4 tex3D(sampler3D samp, float3 s)\nfloat4 tex3D(sampler3D samp, float3 s, int texelOff)\nfloat4 tex3D(sampler3D samp, float3 s, float3 dx, float3 dy)\nfloat4 tex3D(sampler3D samp, float3 s, float3 dx, float3 dy, int texelOff)\nint4 tex3D(isampler3D samp, float3 s)\nint4 tex3D(isampler3D samp, float3 s, int texelOff)\nint4 tex3D(isampler3D samp, float3 s, float3 dx, float3 dy)\nint4 tex3D(isampler3D samp, float3 s, float3 dx, float3 dy, int texelOff)\nuint4 tex3D(usampler3D samp, float3 s)\nuint4 tex3D(usampler3D samp, float3 s, int texelOff)\nuint4 tex3D(usampler3D samp, float3 s, float3 dx, float3 dy)\nuint4 tex3D(usampler3D samp, float3 s, float3 dx, float3 dy,\nint texelOff)\n\n\nPARAMETERS\nsamp Sampler to lookup.\ns Coordinates to perform the lookup.\ndx Pre computed derivative along the x axis.\ndy Pre computed derivative along the y axis.\ntexelOff Offset to be added to obtain the final texel.\n\n\nDESCRIPTION\nPerforms a texture lookup in sampler samp using coordinates s, may use and derivatives dx and dy, also\nmay use texel offset texelOff to compute final texel.\n\n\nPROFILE SUPPORT\ntex3D is supported in all fragment profiles and all vertex profiles starting with vp40, variants with texel\noffsets are only supported in gp4 and newer profiles. Variants with integer samplers are also only\nsuppported in gp4 and newer profiles.\n\n\nSEE ALSO\ntex3Dbias, tex3Dlod, tex3Dproj\n' )
end

function cg_tex3D_5:new()
	Node.new(self)
	self.name = 'tex3D'
	self.in_samp = self.add_port(Input('samp'))
	self.in_s = self.add_port(Input('s'))
	self.in_dx = self.add_port(Input('dx'))
	self.in_dy = self.add_port(Input('dy'))
	self.in_texelOff = self.add_port(Input('texelOff'))
	self.out = self.add_port(Output('out'))
end

function cg_tex3D_5:get_type(port)

	local type_samp = self.in_samp.get_output().get_type()
	local type_s = self.in_s.get_output().get_type()
	local type_dx = self.in_dx.get_output().get_type()
	local type_dy = self.in_dy.get_output().get_type()
	local type_texelOff = self.in_texelOff.get_output().get_type()
	if ((type_samp == 'sampler3D')
	and (type_s == 'float3')
	and (type_dx == 'float3')
	and (type_dy == 'float3')
	and (type_texelOff == 'int')) then
		return 'float4'
	end
	if ((type_samp == 'isampler3D')
	and (type_s == 'float3')
	and (type_dx == 'float3')
	and (type_dy == 'float3')
	and (type_texelOff == 'int')) then
		return 'int4'
	end
	if ((type_samp == 'usampler3D')
	and (type_s == 'float3')
	and (type_dx == 'float3')
	and (type_dy == 'float3')
	and (type_texelOff == 'int')) then
		return 'uint4'
	end
	return nil
end

function cg_tex3D_5:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_tex3D_5:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_samp = 'r' .. self.in_samp.get_output().hex()
	local in_s = 'r' .. self.in_s.get_output().hex()
	local in_dx = 'r' .. self.in_dx.get_output().hex()
	local in_dy = 'r' .. self.in_dy.get_output().hex()
	local in_texelOff = 'r' .. self.in_texelOff.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = tex3D( ' .. in_samp.. ', ' .. in_s.. ', ' .. in_dx.. ', ' .. in_dy.. ', ' .. in_texelOff.. ' );\n')
end

function cg_tex3D_5:get_tip(out)
	out.write( 'tex3D - performs a texture lookup in a given 3D sampler. May also use pre computed derivatives if those are provided. ' )
end

-- #################################################### --
-- tex3Dbias( samp, s )
-- #################################################### --
local cg_tex3Dbias_2 = class(Node)
function cg_tex3Dbias_2:get_help(out)
	out.write( '\n\nNAME\ntex3Dbias - performs a texture lookup with bias in a given sampler.\n\n\nSYNOPSIS\nfloat4 tex3Dbias(sampler3D samp, float4 s)\nfloat4 tex3Dbias(sampler3D samp, float4 s, int texelOff)\nint4 tex3Dbias(isampler3D samp, float4 s)\nint4 tex3Dbias(isampler3D samp, float4 s, int texelOff)\nuint4 tex3Dbias(usampler3D samp, float4 s)\nuint4 tex3Dbias(usampler3D samp, float4 s, int texelOff)\n\n\nPARAMETERS\nsamp Sampler to lookup.\ns Coordinates to perform the lookup. The bias value should be passed as the last component of the\ncoordinate vector.\ntexelOff Offset to be added to obtain the final texel.\n\n\nDESCRIPTION\nPerforms a texture lookup with bias in sampler samp using coordinates s.\n\n\nPROFILE SUPPORT\ntex3Dbias is supported in fragment profiles starting with fp30 and in vertex profiles starting with vp40.\nVariants with texelOff are only supported in gp4 and newer profiles. Variants with integer samplers are also\nonly suppported in gp4 and newer profiles.\n\n\nSEE ALSO\ntex3Dlod.de Sh\n\$1\n' )
end

function cg_tex3Dbias_2:new()
	Node.new(self)
	self.name = 'tex3Dbias'
	self.in_samp = self.add_port(Input('samp'))
	self.in_s = self.add_port(Input('s'))
	self.out = self.add_port(Output('out'))
end

function cg_tex3Dbias_2:get_type(port)

	local type_samp = self.in_samp.get_output().get_type()
	local type_s = self.in_s.get_output().get_type()
	if ((type_samp == 'sampler3D')
	and (type_s == 'float4')) then
		return 'float4'
	end
	if ((type_samp == 'isampler3D')
	and (type_s == 'float4')) then
		return 'int4'
	end
	if ((type_samp == 'usampler3D')
	and (type_s == 'float4')) then
		return 'uint4'
	end
	return nil
end

function cg_tex3Dbias_2:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_tex3Dbias_2:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_samp = 'r' .. self.in_samp.get_output().hex()
	local in_s = 'r' .. self.in_s.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = tex3Dbias( ' .. in_samp.. ', ' .. in_s.. ' );\n')
end

function cg_tex3Dbias_2:get_tip(out)
	out.write( 'tex3Dbias - performs a texture lookup with bias in a given sampler. ' )
end

-- #################################################### --
-- tex3Dbias( samp, s, texelOff )
-- #################################################### --
local cg_tex3Dbias_3 = class(Node)
function cg_tex3Dbias_3:get_help(out)
	out.write( '\n\nNAME\ntex3Dbias - performs a texture lookup with bias in a given sampler.\n\n\nSYNOPSIS\nfloat4 tex3Dbias(sampler3D samp, float4 s)\nfloat4 tex3Dbias(sampler3D samp, float4 s, int texelOff)\nint4 tex3Dbias(isampler3D samp, float4 s)\nint4 tex3Dbias(isampler3D samp, float4 s, int texelOff)\nuint4 tex3Dbias(usampler3D samp, float4 s)\nuint4 tex3Dbias(usampler3D samp, float4 s, int texelOff)\n\n\nPARAMETERS\nsamp Sampler to lookup.\ns Coordinates to perform the lookup. The bias value should be passed as the last component of the\ncoordinate vector.\ntexelOff Offset to be added to obtain the final texel.\n\n\nDESCRIPTION\nPerforms a texture lookup with bias in sampler samp using coordinates s.\n\n\nPROFILE SUPPORT\ntex3Dbias is supported in fragment profiles starting with fp30 and in vertex profiles starting with vp40.\nVariants with texelOff are only supported in gp4 and newer profiles. Variants with integer samplers are also\nonly suppported in gp4 and newer profiles.\n\n\nSEE ALSO\ntex3Dlod.de Sh\n\$1\n' )
end

function cg_tex3Dbias_3:new()
	Node.new(self)
	self.name = 'tex3Dbias'
	self.in_samp = self.add_port(Input('samp'))
	self.in_s = self.add_port(Input('s'))
	self.in_texelOff = self.add_port(Input('texelOff'))
	self.out = self.add_port(Output('out'))
end

function cg_tex3Dbias_3:get_type(port)

	local type_samp = self.in_samp.get_output().get_type()
	local type_s = self.in_s.get_output().get_type()
	local type_texelOff = self.in_texelOff.get_output().get_type()
	if ((type_samp == 'sampler3D')
	and (type_s == 'float4')
	and (type_texelOff == 'int')) then
		return 'float4'
	end
	if ((type_samp == 'isampler3D')
	and (type_s == 'float4')
	and (type_texelOff == 'int')) then
		return 'int4'
	end
	if ((type_samp == 'usampler3D')
	and (type_s == 'float4')
	and (type_texelOff == 'int')) then
		return 'uint4'
	end
	return nil
end

function cg_tex3Dbias_3:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_tex3Dbias_3:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_samp = 'r' .. self.in_samp.get_output().hex()
	local in_s = 'r' .. self.in_s.get_output().hex()
	local in_texelOff = 'r' .. self.in_texelOff.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = tex3Dbias( ' .. in_samp.. ', ' .. in_s.. ', ' .. in_texelOff.. ' );\n')
end

function cg_tex3Dbias_3:get_tip(out)
	out.write( 'tex3Dbias - performs a texture lookup with bias in a given sampler. ' )
end

-- #################################################### --
-- tex3Dfetch( samp, s )
-- #################################################### --
local cg_tex3Dfetch_2 = class(Node)
function cg_tex3Dfetch_2:get_help(out)
	out.write( '\n\nNAME\ntex3Dfetch - performs an unfiltered texture lookup in a given sampler.\n\n\nSYNOPSIS\nfloat4 tex3Dfetch(sampler3D samp, int4 s)\nfloat4 tex3Dfetch(sampler3D samp, int4 s, int texelOff)\nint4 tex3Dfetch(isampler3D samp, int4 s)\nint4 tex3Dfetch(isampler3D samp, int4 s, int texelOff)\nuint4 tex3Dfetch(usampler3D samp, int4 s)\nuint4 tex3Dfetch(usampler3D samp, int4 s, int texelOff)\n\n\nPARAMETERS\nsamp Sampler to lookup.\ns Coordinates to perform the lookup. The level of detail is stored in the last component of the\ncoordinate vector.\ntexelOff Offset to be added to obtain the final texel.\n\n\nDESCRIPTION\nPerforms an unfiltered texture lookup in sampler samp using coordinates s. The level of detail is provided\nby the last component of the coordinate vector. May use texel offset texelOff to compute final texel.\n\n\nPROFILE SUPPORT\ntex3Dfetch is only supported in gp4 and newer profiles.\n\n\nSEE ALSO\ntex3D.de Sh\n\$1\n' )
end

function cg_tex3Dfetch_2:new()
	Node.new(self)
	self.name = 'tex3Dfetch'
	self.in_samp = self.add_port(Input('samp'))
	self.in_s = self.add_port(Input('s'))
	self.out = self.add_port(Output('out'))
end

function cg_tex3Dfetch_2:get_type(port)

	local type_samp = self.in_samp.get_output().get_type()
	local type_s = self.in_s.get_output().get_type()
	if ((type_samp == 'sampler3D')
	and (type_s == 'int4')) then
		return 'float4'
	end
	if ((type_samp == 'isampler3D')
	and (type_s == 'int4')) then
		return 'int4'
	end
	if ((type_samp == 'usampler3D')
	and (type_s == 'int4')) then
		return 'uint4'
	end
	return nil
end

function cg_tex3Dfetch_2:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_tex3Dfetch_2:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_samp = 'r' .. self.in_samp.get_output().hex()
	local in_s = 'r' .. self.in_s.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = tex3Dfetch( ' .. in_samp.. ', ' .. in_s.. ' );\n')
end

function cg_tex3Dfetch_2:get_tip(out)
	out.write( 'tex3Dfetch - performs an unfiltered texture lookup in a given sampler. ' )
end

-- #################################################### --
-- tex3Dfetch( samp, s, texelOff )
-- #################################################### --
local cg_tex3Dfetch_3 = class(Node)
function cg_tex3Dfetch_3:get_help(out)
	out.write( '\n\nNAME\ntex3Dfetch - performs an unfiltered texture lookup in a given sampler.\n\n\nSYNOPSIS\nfloat4 tex3Dfetch(sampler3D samp, int4 s)\nfloat4 tex3Dfetch(sampler3D samp, int4 s, int texelOff)\nint4 tex3Dfetch(isampler3D samp, int4 s)\nint4 tex3Dfetch(isampler3D samp, int4 s, int texelOff)\nuint4 tex3Dfetch(usampler3D samp, int4 s)\nuint4 tex3Dfetch(usampler3D samp, int4 s, int texelOff)\n\n\nPARAMETERS\nsamp Sampler to lookup.\ns Coordinates to perform the lookup. The level of detail is stored in the last component of the\ncoordinate vector.\ntexelOff Offset to be added to obtain the final texel.\n\n\nDESCRIPTION\nPerforms an unfiltered texture lookup in sampler samp using coordinates s. The level of detail is provided\nby the last component of the coordinate vector. May use texel offset texelOff to compute final texel.\n\n\nPROFILE SUPPORT\ntex3Dfetch is only supported in gp4 and newer profiles.\n\n\nSEE ALSO\ntex3D.de Sh\n\$1\n' )
end

function cg_tex3Dfetch_3:new()
	Node.new(self)
	self.name = 'tex3Dfetch'
	self.in_samp = self.add_port(Input('samp'))
	self.in_s = self.add_port(Input('s'))
	self.in_texelOff = self.add_port(Input('texelOff'))
	self.out = self.add_port(Output('out'))
end

function cg_tex3Dfetch_3:get_type(port)

	local type_samp = self.in_samp.get_output().get_type()
	local type_s = self.in_s.get_output().get_type()
	local type_texelOff = self.in_texelOff.get_output().get_type()
	if ((type_samp == 'sampler3D')
	and (type_s == 'int4')
	and (type_texelOff == 'int')) then
		return 'float4'
	end
	if ((type_samp == 'isampler3D')
	and (type_s == 'int4')
	and (type_texelOff == 'int')) then
		return 'int4'
	end
	if ((type_samp == 'usampler3D')
	and (type_s == 'int4')
	and (type_texelOff == 'int')) then
		return 'uint4'
	end
	return nil
end

function cg_tex3Dfetch_3:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_tex3Dfetch_3:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_samp = 'r' .. self.in_samp.get_output().hex()
	local in_s = 'r' .. self.in_s.get_output().hex()
	local in_texelOff = 'r' .. self.in_texelOff.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = tex3Dfetch( ' .. in_samp.. ', ' .. in_s.. ', ' .. in_texelOff.. ' );\n')
end

function cg_tex3Dfetch_3:get_tip(out)
	out.write( 'tex3Dfetch - performs an unfiltered texture lookup in a given sampler. ' )
end

-- #################################################### --
-- tex3Dlod( samp, s )
-- #################################################### --
local cg_tex3Dlod_2 = class(Node)
function cg_tex3Dlod_2:get_help(out)
	out.write( '\n\nNAME\ntex3Dlod - performs a texture lookup with a specified level of detail in a given sampler.\n\n\nSYNOPSIS\nfloat4 tex3Dlod(sampler3D samp, float4 s)\nfloat4 tex3Dlod(sampler3D samp, float4 s, int texelOff)\nint4 tex3Dlod(isampler3D samp, float4 s)\nint4 tex3Dlod(isampler3D samp, float4 s, int texelOff)\nuint4 tex3Dlod(usampler3D samp, float4 s)\nuint4 tex3Dlod(usampler3D samp, float4 s, int texelOff)\n\n\nPARAMETERS\nsamp Sampler to lookup.\ns Coordinates to perform the lookup. The level of detail should be passed as the last component of\nthe coordinate vector.\ntexelOff Offset to be added to obtain the final texel.\n\n\nDESCRIPTION\nPerforms a texture lookup with a specified level of detail in sampler samp using coordinates s.\n\n\nPROFILE SUPPORT\ntex3Dlod is supported in fragment profiles starting with fp40 and in vertex profiles starting with vp40.\nVariants with texelOff are only supported in gp4 and newer profiles. Variants with integer samplers are also\nonly suppported in gp4 and newer profiles.\n\n\nSEE ALSO\ntex3Dbias.de Sh\n\$1\n' )
end

function cg_tex3Dlod_2:new()
	Node.new(self)
	self.name = 'tex3Dlod'
	self.in_samp = self.add_port(Input('samp'))
	self.in_s = self.add_port(Input('s'))
	self.out = self.add_port(Output('out'))
end

function cg_tex3Dlod_2:get_type(port)

	local type_samp = self.in_samp.get_output().get_type()
	local type_s = self.in_s.get_output().get_type()
	if ((type_samp == 'sampler3D')
	and (type_s == 'float4')) then
		return 'float4'
	end
	if ((type_samp == 'isampler3D')
	and (type_s == 'float4')) then
		return 'int4'
	end
	if ((type_samp == 'usampler3D')
	and (type_s == 'float4')) then
		return 'uint4'
	end
	return nil
end

function cg_tex3Dlod_2:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_tex3Dlod_2:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_samp = 'r' .. self.in_samp.get_output().hex()
	local in_s = 'r' .. self.in_s.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = tex3Dlod( ' .. in_samp.. ', ' .. in_s.. ' );\n')
end

function cg_tex3Dlod_2:get_tip(out)
	out.write( 'tex3Dlod - performs a texture lookup with a specified level of detail in a given sampler. ' )
end

-- #################################################### --
-- tex3Dlod( samp, s, texelOff )
-- #################################################### --
local cg_tex3Dlod_3 = class(Node)
function cg_tex3Dlod_3:get_help(out)
	out.write( '\n\nNAME\ntex3Dlod - performs a texture lookup with a specified level of detail in a given sampler.\n\n\nSYNOPSIS\nfloat4 tex3Dlod(sampler3D samp, float4 s)\nfloat4 tex3Dlod(sampler3D samp, float4 s, int texelOff)\nint4 tex3Dlod(isampler3D samp, float4 s)\nint4 tex3Dlod(isampler3D samp, float4 s, int texelOff)\nuint4 tex3Dlod(usampler3D samp, float4 s)\nuint4 tex3Dlod(usampler3D samp, float4 s, int texelOff)\n\n\nPARAMETERS\nsamp Sampler to lookup.\ns Coordinates to perform the lookup. The level of detail should be passed as the last component of\nthe coordinate vector.\ntexelOff Offset to be added to obtain the final texel.\n\n\nDESCRIPTION\nPerforms a texture lookup with a specified level of detail in sampler samp using coordinates s.\n\n\nPROFILE SUPPORT\ntex3Dlod is supported in fragment profiles starting with fp40 and in vertex profiles starting with vp40.\nVariants with texelOff are only supported in gp4 and newer profiles. Variants with integer samplers are also\nonly suppported in gp4 and newer profiles.\n\n\nSEE ALSO\ntex3Dbias.de Sh\n\$1\n' )
end

function cg_tex3Dlod_3:new()
	Node.new(self)
	self.name = 'tex3Dlod'
	self.in_samp = self.add_port(Input('samp'))
	self.in_s = self.add_port(Input('s'))
	self.in_texelOff = self.add_port(Input('texelOff'))
	self.out = self.add_port(Output('out'))
end

function cg_tex3Dlod_3:get_type(port)

	local type_samp = self.in_samp.get_output().get_type()
	local type_s = self.in_s.get_output().get_type()
	local type_texelOff = self.in_texelOff.get_output().get_type()
	if ((type_samp == 'sampler3D')
	and (type_s == 'float4')
	and (type_texelOff == 'int')) then
		return 'float4'
	end
	if ((type_samp == 'isampler3D')
	and (type_s == 'float4')
	and (type_texelOff == 'int')) then
		return 'int4'
	end
	if ((type_samp == 'usampler3D')
	and (type_s == 'float4')
	and (type_texelOff == 'int')) then
		return 'uint4'
	end
	return nil
end

function cg_tex3Dlod_3:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_tex3Dlod_3:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_samp = 'r' .. self.in_samp.get_output().hex()
	local in_s = 'r' .. self.in_s.get_output().hex()
	local in_texelOff = 'r' .. self.in_texelOff.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = tex3Dlod( ' .. in_samp.. ', ' .. in_s.. ', ' .. in_texelOff.. ' );\n')
end

function cg_tex3Dlod_3:get_tip(out)
	out.write( 'tex3Dlod - performs a texture lookup with a specified level of detail in a given sampler. ' )
end

-- #################################################### --
-- tex3Dproj( samp, s )
-- #################################################### --
local cg_tex3Dproj_2 = class(Node)
function cg_tex3Dproj_2:get_help(out)
	out.write( '\n\nNAME\ntex3Dproj - performs a texture lookup with projection in a given sampler. May perform a shadow\ncomparison if argument for shadow comparison is provided.\n\n\nSYNOPSIS\nfloat4 tex3Dproj(sampler3D samp, float4 s)\nfloat4 tex3Dproj(sampler3D samp, float4 s, int texelOff)\nint4 tex3Dproj(isampler3D samp, float4 s)\nint4 tex3Dproj(isampler3D samp, float4 s, int texelOff)\nuint4 tex3Dproj(usampler3D samp, float4 s)\nuint4 tex3Dproj(usampler3D samp, float4 s, int texelOff)\n\n\nPARAMETERS\nsamp Sampler to lookup.\ns Coordinates to perform the lookup. The value used in the projection should be passed as the last\ncomponent of the coordinate vector. The value used in the shadow comparison, if present, should\nbe passed as the next-to-last component of the coordinate vector.\ntexelOff Offset to be added to obtain the final texel.\n\n\nDESCRIPTION\nPerforms a texture lookup in sampler samp using coordinates s, the coordinates used in the lookup are first\nprojected, that is, divided by the last component of the coordinate vector and them used in the lookup. If an\nextra coordinate is present it is used to perform a shadow comparison, the value used in the shadow\ncomparison is always the next-to-last component in the coordinate vector.\n\n\nPROFILE SUPPORT\ntex3Dproj is supported in all fragment profiles and all vertex profiles starting with vp40, variants with\nshadow comparison are only supported in fp40 and newer profiles, variants with texel offsets are only\nsupported in gp4 and newer profiles.\n\n\nSEE ALSO\ntex3D\n' )
end

function cg_tex3Dproj_2:new()
	Node.new(self)
	self.name = 'tex3Dproj'
	self.in_samp = self.add_port(Input('samp'))
	self.in_s = self.add_port(Input('s'))
	self.out = self.add_port(Output('out'))
end

function cg_tex3Dproj_2:get_type(port)

	local type_samp = self.in_samp.get_output().get_type()
	local type_s = self.in_s.get_output().get_type()
	if ((type_samp == 'sampler3D')
	and (type_s == 'float4')) then
		return 'float4'
	end
	if ((type_samp == 'isampler3D')
	and (type_s == 'float4')) then
		return 'int4'
	end
	if ((type_samp == 'usampler3D')
	and (type_s == 'float4')) then
		return 'uint4'
	end
	return nil
end

function cg_tex3Dproj_2:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_tex3Dproj_2:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_samp = 'r' .. self.in_samp.get_output().hex()
	local in_s = 'r' .. self.in_s.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = tex3Dproj( ' .. in_samp.. ', ' .. in_s.. ' );\n')
end

function cg_tex3Dproj_2:get_tip(out)
	out.write( 'tex3Dproj - performs a texture lookup with projection in a given sampler. May perform a shadow comparison if argument for shadow comparison is provided. ' )
end

-- #################################################### --
-- tex3Dproj( samp, s, texelOff )
-- #################################################### --
local cg_tex3Dproj_3 = class(Node)
function cg_tex3Dproj_3:get_help(out)
	out.write( '\n\nNAME\ntex3Dproj - performs a texture lookup with projection in a given sampler. May perform a shadow\ncomparison if argument for shadow comparison is provided.\n\n\nSYNOPSIS\nfloat4 tex3Dproj(sampler3D samp, float4 s)\nfloat4 tex3Dproj(sampler3D samp, float4 s, int texelOff)\nint4 tex3Dproj(isampler3D samp, float4 s)\nint4 tex3Dproj(isampler3D samp, float4 s, int texelOff)\nuint4 tex3Dproj(usampler3D samp, float4 s)\nuint4 tex3Dproj(usampler3D samp, float4 s, int texelOff)\n\n\nPARAMETERS\nsamp Sampler to lookup.\ns Coordinates to perform the lookup. The value used in the projection should be passed as the last\ncomponent of the coordinate vector. The value used in the shadow comparison, if present, should\nbe passed as the next-to-last component of the coordinate vector.\ntexelOff Offset to be added to obtain the final texel.\n\n\nDESCRIPTION\nPerforms a texture lookup in sampler samp using coordinates s, the coordinates used in the lookup are first\nprojected, that is, divided by the last component of the coordinate vector and them used in the lookup. If an\nextra coordinate is present it is used to perform a shadow comparison, the value used in the shadow\ncomparison is always the next-to-last component in the coordinate vector.\n\n\nPROFILE SUPPORT\ntex3Dproj is supported in all fragment profiles and all vertex profiles starting with vp40, variants with\nshadow comparison are only supported in fp40 and newer profiles, variants with texel offsets are only\nsupported in gp4 and newer profiles.\n\n\nSEE ALSO\ntex3D\n' )
end

function cg_tex3Dproj_3:new()
	Node.new(self)
	self.name = 'tex3Dproj'
	self.in_samp = self.add_port(Input('samp'))
	self.in_s = self.add_port(Input('s'))
	self.in_texelOff = self.add_port(Input('texelOff'))
	self.out = self.add_port(Output('out'))
end

function cg_tex3Dproj_3:get_type(port)

	local type_samp = self.in_samp.get_output().get_type()
	local type_s = self.in_s.get_output().get_type()
	local type_texelOff = self.in_texelOff.get_output().get_type()
	if ((type_samp == 'sampler3D')
	and (type_s == 'float4')
	and (type_texelOff == 'int')) then
		return 'float4'
	end
	if ((type_samp == 'isampler3D')
	and (type_s == 'float4')
	and (type_texelOff == 'int')) then
		return 'int4'
	end
	if ((type_samp == 'usampler3D')
	and (type_s == 'float4')
	and (type_texelOff == 'int')) then
		return 'uint4'
	end
	return nil
end

function cg_tex3Dproj_3:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_tex3Dproj_3:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_samp = 'r' .. self.in_samp.get_output().hex()
	local in_s = 'r' .. self.in_s.get_output().hex()
	local in_texelOff = 'r' .. self.in_texelOff.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = tex3Dproj( ' .. in_samp.. ', ' .. in_s.. ', ' .. in_texelOff.. ' );\n')
end

function cg_tex3Dproj_3:get_tip(out)
	out.write( 'tex3Dproj - performs a texture lookup with projection in a given sampler. May perform a shadow comparison if argument for shadow comparison is provided. ' )
end

-- #################################################### --
-- tex3Dsize( samp, lod )
-- #################################################### --
local cg_tex3Dsize_2 = class(Node)
function cg_tex3Dsize_2:get_help(out)
	out.write( '\n\nNAME\ntex3Dsize - returns the size of a given texture image for a given level of detail.\n\n\nSYNOPSIS\nint3 tex3Dsize(sampler3D samp, int lod)\nint3 tex3Dsize(isampler3D samp, int lod)\nint3 tex3Dsize(usampler3D samp, int lod)\n\n\nPARAMETERS\nsamp Sampler to be queried for size.\nlod Level of detail to obtain size.\n\n\nDESCRIPTION\nGiven a sampler and a level of detail the size of the corresponding texture image is returned as the result of\nthe operation.\n\n\nPROFILE SUPPORT\ntex3Dsize is only supported in gp4 and newer profiles.\n\n\nSEE ALSO\ntex3D.de Sh\n\$1\n' )
end

function cg_tex3Dsize_2:new()
	Node.new(self)
	self.name = 'tex3Dsize'
	self.in_samp = self.add_port(Input('samp'))
	self.in_lod = self.add_port(Input('lod'))
	self.out = self.add_port(Output('out'))
end

function cg_tex3Dsize_2:get_type(port)

	local type_samp = self.in_samp.get_output().get_type()
	local type_lod = self.in_lod.get_output().get_type()
	if ((type_samp == 'sampler3D')
	and (type_lod == 'int')) then
		return 'int3'
	end
	if ((type_samp == 'isampler3D')
	and (type_lod == 'int')) then
		return 'int3'
	end
	if ((type_samp == 'usampler3D')
	and (type_lod == 'int')) then
		return 'int3'
	end
	return nil
end

function cg_tex3Dsize_2:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_tex3Dsize_2:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_samp = 'r' .. self.in_samp.get_output().hex()
	local in_lod = 'r' .. self.in_lod.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = tex3Dsize( ' .. in_samp.. ', ' .. in_lod.. ' );\n')
end

function cg_tex3Dsize_2:get_tip(out)
	out.write( 'tex3Dsize - returns the size of a given texture image for a given level of detail. ' )
end

-- #################################################### --
-- texBUF( samp, s )
-- #################################################### --
local cg_texBUF_2 = class(Node)
function cg_texBUF_2:get_help(out)
	out.write( '\n\nNAME\ntexBUF - performs an unfiltered texture lookup in a given texture buffer sampler.\n\n\nSYNOPSIS\nfloat4 texBUF(samplerBUF samp, int s)\nint4 texBUF(isamplerBUF samp, int s)\nuint4 texBUF(usamplerBUF samp, int s)\n\n\nPARAMETERS\nsamp Sampler to lookup.\ns Coordinates to perform the lookup.\n\n\nDESCRIPTION\nPerforms an unfiltered texture lookup in texture buffer sampler samp using coordinates s.\nTexture buffer samplers are created with the EXT_texture_buffer_object extension. See:\nhttp://developer.download.nvidia.com/opengl/specs/GL_EXT_texture_buffer_object.txt\nTexture buffer object samplers roughly correspond to the tbuffer functionality of DirectX 10.\n\n\nPROFILE SUPPORT\ntexBUF is supported in gp4vp, gp4gp, and gp4fp profiles.\n\n\nSEE ALSO\ntex1D, texBUFsize\n' )
end

function cg_texBUF_2:new()
	Node.new(self)
	self.name = 'texBUF'
	self.in_samp = self.add_port(Input('samp'))
	self.in_s = self.add_port(Input('s'))
	self.out = self.add_port(Output('out'))
end

function cg_texBUF_2:get_type(port)

	local type_samp = self.in_samp.get_output().get_type()
	local type_s = self.in_s.get_output().get_type()
	if ((type_samp == 'samplerBUF')
	and (type_s == 'int')) then
		return 'float4'
	end
	if ((type_samp == 'isamplerBUF')
	and (type_s == 'int')) then
		return 'int4'
	end
	if ((type_samp == 'usamplerBUF')
	and (type_s == 'int')) then
		return 'uint4'
	end
	return nil
end

function cg_texBUF_2:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_texBUF_2:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_samp = 'r' .. self.in_samp.get_output().hex()
	local in_s = 'r' .. self.in_s.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = texBUF( ' .. in_samp.. ', ' .. in_s.. ' );\n')
end

function cg_texBUF_2:get_tip(out)
	out.write( 'texBUF - performs an unfiltered texture lookup in a given texture buffer sampler. ' )
end

-- #################################################### --
-- texBUFsize( samp, lod )
-- #################################################### --
local cg_texBUFsize_2 = class(Node)
function cg_texBUFsize_2:get_help(out)
	out.write( '\n\nNAME\ntexBUFsize - returns the size of a given texture image for a given level of detail.\n\n\nSYNOPSIS\nint3 texBUFsize(samplerBUF samp, int lod)\nint3 texBUFsize(isamplerBUF samp, int lod)\nint3 texBUFsize(usamplerBUF samp, int lod)\n\n\nPARAMETERS\nsamp Sampler to be queried for size.\nlod Level of detail to obtain size.\n\n\nDESCRIPTION\nGiven a sampler and a level of detail the size (width in x, height in y, and depth in z) of the corresponding\ntexture buffer is returned as the result of the operation.\nBecause texture buffers lack mipmaps, the lod parameter is unused.\nTexture buffer samplers are created with the EXT_texture_buffer_object extension. See:\nhttp://developer.download.nvidia.com/opengl/specs/GL_EXT_texture_buffer_object.txt\nTexture buffer object samplers roughly correspond to the tbuffer functionality of DirectX 10.\n\n\nPROFILE SUPPORT\ntexBUF is supported in gp4vp, gp4gp, and gp4fp profiles.\n\n\nSEE ALSO\ntex1Dsize, texBUFsize\n' )
end

function cg_texBUFsize_2:new()
	Node.new(self)
	self.name = 'texBUFsize'
	self.in_samp = self.add_port(Input('samp'))
	self.in_lod = self.add_port(Input('lod'))
	self.out = self.add_port(Output('out'))
end

function cg_texBUFsize_2:get_type(port)

	local type_samp = self.in_samp.get_output().get_type()
	local type_lod = self.in_lod.get_output().get_type()
	if ((type_samp == 'samplerBUF')
	and (type_lod == 'int')) then
		return 'int3'
	end
	if ((type_samp == 'isamplerBUF')
	and (type_lod == 'int')) then
		return 'int3'
	end
	if ((type_samp == 'usamplerBUF')
	and (type_lod == 'int')) then
		return 'int3'
	end
	return nil
end

function cg_texBUFsize_2:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_texBUFsize_2:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_samp = 'r' .. self.in_samp.get_output().hex()
	local in_lod = 'r' .. self.in_lod.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = texBUFsize( ' .. in_samp.. ', ' .. in_lod.. ' );\n')
end

function cg_texBUFsize_2:get_tip(out)
	out.write( 'texBUFsize - returns the size of a given texture image for a given level of detail. ' )
end

-- #################################################### --
-- texCUBE( samp, s )
-- #################################################### --
local cg_texCUBE_2 = class(Node)
function cg_texCUBE_2:get_help(out)
	out.write( '\n\nNAME\ntexCUBE - performs a texture lookup in a given CUBE sampler and, in some cases, a shadow comparison.\nMay also use pre computed derivatives if those are provided.\n\n\nSYNOPSIS\nfloat4 texCUBE(samplerCUBE samp, float3 s)\nfloat4 texCUBE(samplerCUBE samp, float4 s)\nfloat4 texCUBE(samplerCUBE samp, float3 s, float3 dx, float3 dy)\nfloat4 texCUBE(samplerCUBE samp, float4 s, float3 dx, float3 dy)\nint4 texCUBE(isamplerCUBE samp, float3 s)\nint4 texCUBE(isamplerCUBE samp, float3 s, float3 dx, float3 dy)\nuint4 texCUBE(usamplerCUBE samp, float3 s)\nuint4 texCUBE(usamplerCUBE samp, float3 s, float3 dx, float3 dy)\n\n\nPARAMETERS\nsamp Sampler to lookup.\ns Coordinates to perform the lookup. If an extra coordinate compared to the texture dimensionality\nis present it is used to perform a shadow comparison. The value used in the shadow comparison is\nalways the last component of the coordinate vector.\ndx Pre computed derivative along the x axis.\ndy Pre computed derivative along the y axis.\n\n\nDESCRIPTION\nPerforms a texture lookup in sampler samp using coordinates s, may use and derivatives dx and dy, also\nmay perform shadow comparison.\n\n\nPROFILE SUPPORT\ntexCUBE is supported in all fragment profiles and all vertex profiles starting with vp40, variants with\nshadow comparison are only supported in gp4 and newer profiles. Variants with integer samplers are also\nonly suppported in gp4 and newer profiles.\n\n\nSEE ALSO\ntexCUBEbias, texCUBElod, texCUBEproj\n' )
end

function cg_texCUBE_2:new()
	Node.new(self)
	self.name = 'texCUBE'
	self.in_samp = self.add_port(Input('samp'))
	self.in_s = self.add_port(Input('s'))
	self.out = self.add_port(Output('out'))
end

function cg_texCUBE_2:get_type(port)

	local type_samp = self.in_samp.get_output().get_type()
	local type_s = self.in_s.get_output().get_type()
	if ((type_samp == 'samplerCUBE')
	and (type_s == 'float3')) then
		return 'float4'
	end
	if ((type_samp == 'samplerCUBE')
	and (type_s == 'float4')) then
		return 'float4'
	end
	if ((type_samp == 'isamplerCUBE')
	and (type_s == 'float3')) then
		return 'int4'
	end
	if ((type_samp == 'usamplerCUBE')
	and (type_s == 'float3')) then
		return 'uint4'
	end
	return nil
end

function cg_texCUBE_2:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_texCUBE_2:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_samp = 'r' .. self.in_samp.get_output().hex()
	local in_s = 'r' .. self.in_s.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = texCUBE( ' .. in_samp.. ', ' .. in_s.. ' );\n')
end

function cg_texCUBE_2:get_tip(out)
	out.write( 'texCUBE - performs a texture lookup in a given CUBE sampler and, in some cases, a shadow comparison. May also use pre computed derivatives if those are provided. ' )
end

-- #################################################### --
-- texCUBE( samp, s, dx, dy )
-- #################################################### --
local cg_texCUBE_4 = class(Node)
function cg_texCUBE_4:get_help(out)
	out.write( '\n\nNAME\ntexCUBE - performs a texture lookup in a given CUBE sampler and, in some cases, a shadow comparison.\nMay also use pre computed derivatives if those are provided.\n\n\nSYNOPSIS\nfloat4 texCUBE(samplerCUBE samp, float3 s)\nfloat4 texCUBE(samplerCUBE samp, float4 s)\nfloat4 texCUBE(samplerCUBE samp, float3 s, float3 dx, float3 dy)\nfloat4 texCUBE(samplerCUBE samp, float4 s, float3 dx, float3 dy)\nint4 texCUBE(isamplerCUBE samp, float3 s)\nint4 texCUBE(isamplerCUBE samp, float3 s, float3 dx, float3 dy)\nuint4 texCUBE(usamplerCUBE samp, float3 s)\nuint4 texCUBE(usamplerCUBE samp, float3 s, float3 dx, float3 dy)\n\n\nPARAMETERS\nsamp Sampler to lookup.\ns Coordinates to perform the lookup. If an extra coordinate compared to the texture dimensionality\nis present it is used to perform a shadow comparison. The value used in the shadow comparison is\nalways the last component of the coordinate vector.\ndx Pre computed derivative along the x axis.\ndy Pre computed derivative along the y axis.\n\n\nDESCRIPTION\nPerforms a texture lookup in sampler samp using coordinates s, may use and derivatives dx and dy, also\nmay perform shadow comparison.\n\n\nPROFILE SUPPORT\ntexCUBE is supported in all fragment profiles and all vertex profiles starting with vp40, variants with\nshadow comparison are only supported in gp4 and newer profiles. Variants with integer samplers are also\nonly suppported in gp4 and newer profiles.\n\n\nSEE ALSO\ntexCUBEbias, texCUBElod, texCUBEproj\n' )
end

function cg_texCUBE_4:new()
	Node.new(self)
	self.name = 'texCUBE'
	self.in_samp = self.add_port(Input('samp'))
	self.in_s = self.add_port(Input('s'))
	self.in_dx = self.add_port(Input('dx'))
	self.in_dy = self.add_port(Input('dy'))
	self.out = self.add_port(Output('out'))
end

function cg_texCUBE_4:get_type(port)

	local type_samp = self.in_samp.get_output().get_type()
	local type_s = self.in_s.get_output().get_type()
	local type_dx = self.in_dx.get_output().get_type()
	local type_dy = self.in_dy.get_output().get_type()
	if ((type_samp == 'samplerCUBE')
	and (type_s == 'float3')
	and (type_dx == 'float3')
	and (type_dy == 'float3')) then
		return 'float4'
	end
	if ((type_samp == 'samplerCUBE')
	and (type_s == 'float4')
	and (type_dx == 'float3')
	and (type_dy == 'float3')) then
		return 'float4'
	end
	if ((type_samp == 'isamplerCUBE')
	and (type_s == 'float3')
	and (type_dx == 'float3')
	and (type_dy == 'float3')) then
		return 'int4'
	end
	if ((type_samp == 'usamplerCUBE')
	and (type_s == 'float3')
	and (type_dx == 'float3')
	and (type_dy == 'float3')) then
		return 'uint4'
	end
	return nil
end

function cg_texCUBE_4:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_texCUBE_4:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_samp = 'r' .. self.in_samp.get_output().hex()
	local in_s = 'r' .. self.in_s.get_output().hex()
	local in_dx = 'r' .. self.in_dx.get_output().hex()
	local in_dy = 'r' .. self.in_dy.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = texCUBE( ' .. in_samp.. ', ' .. in_s.. ', ' .. in_dx.. ', ' .. in_dy.. ' );\n')
end

function cg_texCUBE_4:get_tip(out)
	out.write( 'texCUBE - performs a texture lookup in a given CUBE sampler and, in some cases, a shadow comparison. May also use pre computed derivatives if those are provided. ' )
end

-- #################################################### --
-- texCUBEARRAY( samp, s )
-- #################################################### --
local cg_texCUBEARRAY_2 = class(Node)
function cg_texCUBEARRAY_2:get_help(out)
	out.write( '\n\nNAME\ntexCUBEARRAY - performs a texture lookup in a given sampler array may use pre computed derivatives.\n\n\nSYNOPSIS\nfloat4 texCUBEARRAY(samplerCUBEARRAY samp, float4 s)\nfloat4 texCUBEARRAY(samplerCUBEARRAY samp, float4 s, float3 dx, float3 dy)\nint4 texCUBEARRAY(isamplerCUBEARRAY samp, float4 s)\nint4 texCUBEARRAY(isamplerCUBEARRAY samp, float4 s, float3 dx, float3 dy)\nuint4 texCUBEARRAY(usamplerCUBEARRAY samp, float4 s)\nuint4 texCUBEARRAY(usamplerCUBEARRAY samp, float4 s, float3 dx, float3 dy)\n\n\nPARAMETERS\nsamp Sampler array to look up.\ns Coordinates to perform the lookup. The value used to select the layer is passed immediatelly after\nthe regular coordinates.\ndx Pre computed derivative along the x axis.\ndy Pre computed derivative along the y axis.\ntexelOff Offset to be added to obtain the final texel.\n\n\nDESCRIPTION\nPerforms a texture lookup in sampler samp using coordinates s, the texture to be sampled is selected from\nthe layer specified in the coordinates. Also may use the derivatives dx and dy, the lookup may use texel\noffset texelOff to compute the final texel.\n\n\nPROFILE SUPPORT\ntexCUBEARRAY is only supported in gp4 and newer profiles.\n\n\nSEE ALSO\ntexCUBEARRAYbias, texCUBEARRAYlod\n' )
end

function cg_texCUBEARRAY_2:new()
	Node.new(self)
	self.name = 'texCUBEARRAY'
	self.in_samp = self.add_port(Input('samp'))
	self.in_s = self.add_port(Input('s'))
	self.out = self.add_port(Output('out'))
end

function cg_texCUBEARRAY_2:get_type(port)

	local type_samp = self.in_samp.get_output().get_type()
	local type_s = self.in_s.get_output().get_type()
	if ((type_samp == 'samplerCUBEARRAY')
	and (type_s == 'float4')) then
		return 'float4'
	end
	if ((type_samp == 'isamplerCUBEARRAY')
	and (type_s == 'float4')) then
		return 'int4'
	end
	if ((type_samp == 'usamplerCUBEARRAY')
	and (type_s == 'float4')) then
		return 'uint4'
	end
	return nil
end

function cg_texCUBEARRAY_2:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_texCUBEARRAY_2:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_samp = 'r' .. self.in_samp.get_output().hex()
	local in_s = 'r' .. self.in_s.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = texCUBEARRAY( ' .. in_samp.. ', ' .. in_s.. ' );\n')
end

function cg_texCUBEARRAY_2:get_tip(out)
	out.write( 'texCUBEARRAY - performs a texture lookup in a given sampler array may use pre computed derivatives. ' )
end

-- #################################################### --
-- texCUBEARRAY( samp, s, dx, dy )
-- #################################################### --
local cg_texCUBEARRAY_4 = class(Node)
function cg_texCUBEARRAY_4:get_help(out)
	out.write( '\n\nNAME\ntexCUBEARRAY - performs a texture lookup in a given sampler array may use pre computed derivatives.\n\n\nSYNOPSIS\nfloat4 texCUBEARRAY(samplerCUBEARRAY samp, float4 s)\nfloat4 texCUBEARRAY(samplerCUBEARRAY samp, float4 s, float3 dx, float3 dy)\nint4 texCUBEARRAY(isamplerCUBEARRAY samp, float4 s)\nint4 texCUBEARRAY(isamplerCUBEARRAY samp, float4 s, float3 dx, float3 dy)\nuint4 texCUBEARRAY(usamplerCUBEARRAY samp, float4 s)\nuint4 texCUBEARRAY(usamplerCUBEARRAY samp, float4 s, float3 dx, float3 dy)\n\n\nPARAMETERS\nsamp Sampler array to look up.\ns Coordinates to perform the lookup. The value used to select the layer is passed immediatelly after\nthe regular coordinates.\ndx Pre computed derivative along the x axis.\ndy Pre computed derivative along the y axis.\ntexelOff Offset to be added to obtain the final texel.\n\n\nDESCRIPTION\nPerforms a texture lookup in sampler samp using coordinates s, the texture to be sampled is selected from\nthe layer specified in the coordinates. Also may use the derivatives dx and dy, the lookup may use texel\noffset texelOff to compute the final texel.\n\n\nPROFILE SUPPORT\ntexCUBEARRAY is only supported in gp4 and newer profiles.\n\n\nSEE ALSO\ntexCUBEARRAYbias, texCUBEARRAYlod\n' )
end

function cg_texCUBEARRAY_4:new()
	Node.new(self)
	self.name = 'texCUBEARRAY'
	self.in_samp = self.add_port(Input('samp'))
	self.in_s = self.add_port(Input('s'))
	self.in_dx = self.add_port(Input('dx'))
	self.in_dy = self.add_port(Input('dy'))
	self.out = self.add_port(Output('out'))
end

function cg_texCUBEARRAY_4:get_type(port)

	local type_samp = self.in_samp.get_output().get_type()
	local type_s = self.in_s.get_output().get_type()
	local type_dx = self.in_dx.get_output().get_type()
	local type_dy = self.in_dy.get_output().get_type()
	if ((type_samp == 'samplerCUBEARRAY')
	and (type_s == 'float4')
	and (type_dx == 'float3')
	and (type_dy == 'float3')) then
		return 'float4'
	end
	if ((type_samp == 'isamplerCUBEARRAY')
	and (type_s == 'float4')
	and (type_dx == 'float3')
	and (type_dy == 'float3')) then
		return 'int4'
	end
	if ((type_samp == 'usamplerCUBEARRAY')
	and (type_s == 'float4')
	and (type_dx == 'float3')
	and (type_dy == 'float3')) then
		return 'uint4'
	end
	return nil
end

function cg_texCUBEARRAY_4:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_texCUBEARRAY_4:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_samp = 'r' .. self.in_samp.get_output().hex()
	local in_s = 'r' .. self.in_s.get_output().hex()
	local in_dx = 'r' .. self.in_dx.get_output().hex()
	local in_dy = 'r' .. self.in_dy.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = texCUBEARRAY( ' .. in_samp.. ', ' .. in_s.. ', ' .. in_dx.. ', ' .. in_dy.. ' );\n')
end

function cg_texCUBEARRAY_4:get_tip(out)
	out.write( 'texCUBEARRAY - performs a texture lookup in a given sampler array may use pre computed derivatives. ' )
end

-- #################################################### --
-- texCUBEARRAYsize( samp, lod )
-- #################################################### --
local cg_texCUBEARRAYsize_2 = class(Node)
function cg_texCUBEARRAYsize_2:get_help(out)
	out.write( '\n\nNAME\ntexCUBEARRAYsize - returns the size of a given texture array image for a given level of detail.\n\n\nSYNOPSIS\nint3 texCUBEARRAYsize(samplerCUBEARRAY samp, int lod)\nint3 texCUBEARRAYsize(isamplerCUBEARRAY samp, int lod)\nint3 texCUBEARRAYsize(usamplerCUBEARRAY samp, int lod)\n\n\nPARAMETERS\nsamp Sampler to be queried for size.\nlod Level of detail to obtain size.\n\n\nDESCRIPTION\nGiven a sampler array and a level of detail the size of one element of the corresponding texture array for a\ngiven level of detail is returned as a result of the operation.\n\n\nPROFILE SUPPORT\ntexCUBEARRAYsize is only supported in gp4 and newer profiles.\n\n\nSEE ALSO\ntexCUBEsize.de Sh\n\$1\n' )
end

function cg_texCUBEARRAYsize_2:new()
	Node.new(self)
	self.name = 'texCUBEARRAYsize'
	self.in_samp = self.add_port(Input('samp'))
	self.in_lod = self.add_port(Input('lod'))
	self.out = self.add_port(Output('out'))
end

function cg_texCUBEARRAYsize_2:get_type(port)

	local type_samp = self.in_samp.get_output().get_type()
	local type_lod = self.in_lod.get_output().get_type()
	if ((type_samp == 'samplerCUBEARRAY')
	and (type_lod == 'int')) then
		return 'int3'
	end
	if ((type_samp == 'isamplerCUBEARRAY')
	and (type_lod == 'int')) then
		return 'int3'
	end
	if ((type_samp == 'usamplerCUBEARRAY')
	and (type_lod == 'int')) then
		return 'int3'
	end
	return nil
end

function cg_texCUBEARRAYsize_2:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_texCUBEARRAYsize_2:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_samp = 'r' .. self.in_samp.get_output().hex()
	local in_lod = 'r' .. self.in_lod.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = texCUBEARRAYsize( ' .. in_samp.. ', ' .. in_lod.. ' );\n')
end

function cg_texCUBEARRAYsize_2:get_tip(out)
	out.write( 'texCUBEARRAYsize - returns the size of a given texture array image for a given level of detail. ' )
end

-- #################################################### --
-- texCUBEbias( samp, s )
-- #################################################### --
local cg_texCUBEbias_2 = class(Node)
function cg_texCUBEbias_2:get_help(out)
	out.write( '\n\nNAME\ntexCUBEbias - performs a texture lookup with bias in a given sampler.\n\n\nSYNOPSIS\nfloat4 texCUBEbias(samplerCUBE samp, float4 s)\nint4 texCUBEbias(isamplerCUBE samp, float4 s)\nuint4 texCUBEbias(usamplerCUBE samp, float4 s)\n\n\nPARAMETERS\nsamp Sampler to lookup.\ns Coordinates to perform the lookup. The bias value should be passed as the last component of the\ncoordinate vector.\ntexelOff Offset to be added to obtain the final texel.\n\n\nDESCRIPTION\nPerforms a texture lookup with bias in sampler samp using coordinates s.\n\n\nPROFILE SUPPORT\ntexCUBEbias is supported in fragment profiles starting with fp30 and in vertex profiles starting with vp40.\nVariants with integer samplers are only supported in gp4 and newer profiles.\n\n\nSEE ALSO\ntexCUBElod.de Sh\n\$1\n' )
end

function cg_texCUBEbias_2:new()
	Node.new(self)
	self.name = 'texCUBEbias'
	self.in_samp = self.add_port(Input('samp'))
	self.in_s = self.add_port(Input('s'))
	self.out = self.add_port(Output('out'))
end

function cg_texCUBEbias_2:get_type(port)

	local type_samp = self.in_samp.get_output().get_type()
	local type_s = self.in_s.get_output().get_type()
	if ((type_samp == 'samplerCUBE')
	and (type_s == 'float4')) then
		return 'float4'
	end
	if ((type_samp == 'isamplerCUBE')
	and (type_s == 'float4')) then
		return 'int4'
	end
	if ((type_samp == 'usamplerCUBE')
	and (type_s == 'float4')) then
		return 'uint4'
	end
	return nil
end

function cg_texCUBEbias_2:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_texCUBEbias_2:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_samp = 'r' .. self.in_samp.get_output().hex()
	local in_s = 'r' .. self.in_s.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = texCUBEbias( ' .. in_samp.. ', ' .. in_s.. ' );\n')
end

function cg_texCUBEbias_2:get_tip(out)
	out.write( 'texCUBEbias - performs a texture lookup with bias in a given sampler. ' )
end

-- #################################################### --
-- texCUBElod( samp, s )
-- #################################################### --
local cg_texCUBElod_2 = class(Node)
function cg_texCUBElod_2:get_help(out)
	out.write( '\n\nNAME\ntexCUBElod - performs a texture lookup with a specified level of detail in a given sampler.\n\n\nSYNOPSIS\nfloat4 texCUBElod(samplerCUBE samp, float4 s)\nint4 texCUBElod(isamplerCUBE samp, float4 s)\nuint4 texCUBElod(usamplerCUBE samp, float4 s)\n\n\nPARAMETERS\nsamp Sampler to lookup.\ns Coordinates to perform the lookup. The level of detail should be passed as the last component of\nthe coordinate vector.\n\n\nDESCRIPTION\nPerforms a texture lookup with a specified level of detail in sampler samp using coordinates s.\n\n\nPROFILE SUPPORT\ntexCUBElod is supported in fragment profiles starting with fp40 and in vertex profiles starting with vp40.\nVariants with integer samplers are only supported in gp4 and newer profiles.\n\n\nSEE ALSO\ntexCUBEbias.de Sh\n\$1\n' )
end

function cg_texCUBElod_2:new()
	Node.new(self)
	self.name = 'texCUBElod'
	self.in_samp = self.add_port(Input('samp'))
	self.in_s = self.add_port(Input('s'))
	self.out = self.add_port(Output('out'))
end

function cg_texCUBElod_2:get_type(port)

	local type_samp = self.in_samp.get_output().get_type()
	local type_s = self.in_s.get_output().get_type()
	if ((type_samp == 'samplerCUBE')
	and (type_s == 'float4')) then
		return 'float4'
	end
	if ((type_samp == 'isamplerCUBE')
	and (type_s == 'float4')) then
		return 'int4'
	end
	if ((type_samp == 'usamplerCUBE')
	and (type_s == 'float4')) then
		return 'uint4'
	end
	return nil
end

function cg_texCUBElod_2:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_texCUBElod_2:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_samp = 'r' .. self.in_samp.get_output().hex()
	local in_s = 'r' .. self.in_s.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = texCUBElod( ' .. in_samp.. ', ' .. in_s.. ' );\n')
end

function cg_texCUBElod_2:get_tip(out)
	out.write( 'texCUBElod - performs a texture lookup with a specified level of detail in a given sampler. ' )
end

-- #################################################### --
-- texCUBEproj( samp, s )
-- #################################################### --
local cg_texCUBEproj_2 = class(Node)
function cg_texCUBEproj_2:get_help(out)
	out.write( '\n\nNAME\ntexCUBEproj - performs a texture lookup with projection in a given sampler.\n\n\nSYNOPSIS\nfloat4 texCUBEproj(samplerCUBE samp, float4 s)\nint4 texCUBEproj(isamplerCUBE samp, float4 s)\nuint4 texCUBEproj(usamplerCUBE samp, float4 s)\n\n\nPARAMETERS\nsamp Sampler to lookup.\ns Coordinates to perform the lookup. The value used in the projection should be passed as the last\ncomponent of the coordinate vector.\ntexelOff Offset to be added to obtain the final texel.\n\n\nDESCRIPTION\nPerforms a texture lookup in sampler samp using coordinates s, the coordinates used in the lookup are first\nprojected, that is, divided by the last component of the coordinate vector and them used in the lookup.\n\n\nPROFILE SUPPORT\ntexCUBEproj is supported in all fragment profiles and all vertex profiles starting with vp40. Variants with\ninteger samplers are only supported in gp4 and newer profiles.\n\n\nSEE ALSO\ntexCUBE\n' )
end

function cg_texCUBEproj_2:new()
	Node.new(self)
	self.name = 'texCUBEproj'
	self.in_samp = self.add_port(Input('samp'))
	self.in_s = self.add_port(Input('s'))
	self.out = self.add_port(Output('out'))
end

function cg_texCUBEproj_2:get_type(port)

	local type_samp = self.in_samp.get_output().get_type()
	local type_s = self.in_s.get_output().get_type()
	if ((type_samp == 'samplerCUBE')
	and (type_s == 'float4')) then
		return 'float4'
	end
	if ((type_samp == 'isamplerCUBE')
	and (type_s == 'float4')) then
		return 'int4'
	end
	if ((type_samp == 'usamplerCUBE')
	and (type_s == 'float4')) then
		return 'uint4'
	end
	return nil
end

function cg_texCUBEproj_2:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_texCUBEproj_2:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_samp = 'r' .. self.in_samp.get_output().hex()
	local in_s = 'r' .. self.in_s.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = texCUBEproj( ' .. in_samp.. ', ' .. in_s.. ' );\n')
end

function cg_texCUBEproj_2:get_tip(out)
	out.write( 'texCUBEproj - performs a texture lookup with projection in a given sampler. ' )
end

-- #################################################### --
-- texCUBEsize( samp, lod )
-- #################################################### --
local cg_texCUBEsize_2 = class(Node)
function cg_texCUBEsize_2:get_help(out)
	out.write( '\n\nNAME\ntexCUBEsize - returns the size of a given texture image for a given level of detail.\n\n\nSYNOPSIS\nint3 texCUBEsize(samplerCUBE samp, int lod)\nint3 texCUBEsize(isamplerCUBE samp, int lod)\nint3 texCUBEsize(usamplerCUBE samp, int lod)\n\n\nPARAMETERS\nsamp Sampler to be queried for size.\nlod Level of detail to obtain size.\n\n\nDESCRIPTION\nGiven a sampler and a level of detail the size of the corresponding texture image is returned as the result of\nthe operation.\n\n\nPROFILE SUPPORT\ntexCUBEsize is only supported in gp4 and newer profiles.\n\n\nSEE ALSO\ntexCUBE\n' )
end

function cg_texCUBEsize_2:new()
	Node.new(self)
	self.name = 'texCUBEsize'
	self.in_samp = self.add_port(Input('samp'))
	self.in_lod = self.add_port(Input('lod'))
	self.out = self.add_port(Output('out'))
end

function cg_texCUBEsize_2:get_type(port)

	local type_samp = self.in_samp.get_output().get_type()
	local type_lod = self.in_lod.get_output().get_type()
	if ((type_samp == 'samplerCUBE')
	and (type_lod == 'int')) then
		return 'int3'
	end
	if ((type_samp == 'isamplerCUBE')
	and (type_lod == 'int')) then
		return 'int3'
	end
	if ((type_samp == 'usamplerCUBE')
	and (type_lod == 'int')) then
		return 'int3'
	end
	return nil
end

function cg_texCUBEsize_2:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_texCUBEsize_2:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_samp = 'r' .. self.in_samp.get_output().hex()
	local in_lod = 'r' .. self.in_lod.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = texCUBEsize( ' .. in_samp.. ', ' .. in_lod.. ' );\n')
end

function cg_texCUBEsize_2:get_tip(out)
	out.write( 'texCUBEsize - returns the size of a given texture image for a given level of detail. ' )
end

-- #################################################### --
-- texRECT( samp, s )
-- #################################################### --
local cg_texRECT_2 = class(Node)
function cg_texRECT_2:get_help(out)
	out.write( '\n\nNAME\ntexRECT - performs a texture lookup in a given RECT sampler and, in some cases, a shadow comparison.\nMay also use pre computed derivatives if those are provided.\n\n\nSYNOPSIS\nfloat4 texRECT(samplerRECT samp, float2 s)\nfloat4 texRECT(samplerRECT samp, float2 s, int texelOff)\nfloat4 texRECT(samplerRECT samp, float3 s)\nfloat4 texRECT(samplerRECT samp, float3 s, int texelOff)\nfloat4 texRECT(samplerRECT samp, float2 s, float2 dx, float2 dy)\nfloat4 texRECT(samplerRECT samp, float2 s, float2 dx, float2 dy, int texelOff)\nfloat4 texRECT(samplerRECT samp, float3 s, float2 dx, float2 dy)\nfloat4 texRECT(samplerRECT samp, float3 s, float2 dx, float2 dy, int texelOff)\nint4 texRECT(isamplerRECT samp, float2 s)\nint4 texRECT(isamplerRECT samp, float2 s, int texelOff)\nint4 texRECT(isamplerRECT samp, float2 s, float2 dx, float2 dy)\nint4 texRECT(isamplerRECT samp, float2 s, float2 dx, float2 dy, int texelOff)\nuint4 texRECT(usamplerRECT samp, float2 s)\nuint4 texRECT(usamplerRECT samp, float2 s, int texelOff)\nuint4 texRECT(usamplerRECT samp, float2 s, float2 dx, float2 dy)\nuint4 texRECT(usamplerRECT samp, float2 s, float2 dx, float2 dy,\nint texelOff)\n\n\nPARAMETERS\nsamp Sampler to lookup.\ns Coordinates to perform the lookup. If an extra coordinate compared to the texture dimensionality\nis present it is used to perform a shadow comparison. The value used in the shadow comparison is\nalways the last component of the coordinate vector.\ndx Pre computed derivative along the x axis.\ndy Pre computed derivative along the y axis.\ntexelOff Offset to be added to obtain the final texel.\n\n\nDESCRIPTION\nPerforms a texture lookup in sampler samp using coordinates s, may use and derivatives dx and dy, also\nmay perform shadow comparison and use texel offset texelOff to compute final texel.\n\n\nPROFILE SUPPORT\ntexRECT is supported in all fragment profiles and all vertex profiles starting with vp40, variants with\nshadow comparison are only supported in fp40 and newer profiles, variants with texel offsets are only\nsupported in gp4 and newer profiles. Variants with integer samplers are only supported in gp4 and newer\nprofiles.\n\n\nSEE ALSO\ntexRECTbias, texRECTlod, texRECTproj\n' )
end

function cg_texRECT_2:new()
	Node.new(self)
	self.name = 'texRECT'
	self.in_samp = self.add_port(Input('samp'))
	self.in_s = self.add_port(Input('s'))
	self.out = self.add_port(Output('out'))
end

function cg_texRECT_2:get_type(port)

	local type_samp = self.in_samp.get_output().get_type()
	local type_s = self.in_s.get_output().get_type()
	if ((type_samp == 'samplerRECT')
	and (type_s == 'float2')) then
		return 'float4'
	end
	if ((type_samp == 'samplerRECT')
	and (type_s == 'float3')) then
		return 'float4'
	end
	if ((type_samp == 'isamplerRECT')
	and (type_s == 'float2')) then
		return 'int4'
	end
	if ((type_samp == 'usamplerRECT')
	and (type_s == 'float2')) then
		return 'uint4'
	end
	return nil
end

function cg_texRECT_2:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_texRECT_2:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_samp = 'r' .. self.in_samp.get_output().hex()
	local in_s = 'r' .. self.in_s.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = texRECT( ' .. in_samp.. ', ' .. in_s.. ' );\n')
end

function cg_texRECT_2:get_tip(out)
	out.write( 'texRECT - performs a texture lookup in a given RECT sampler and, in some cases, a shadow comparison. May also use pre computed derivatives if those are provided. ' )
end

-- #################################################### --
-- texRECT( samp, s, texelOff )
-- #################################################### --
local cg_texRECT_3 = class(Node)
function cg_texRECT_3:get_help(out)
	out.write( '\n\nNAME\ntexRECT - performs a texture lookup in a given RECT sampler and, in some cases, a shadow comparison.\nMay also use pre computed derivatives if those are provided.\n\n\nSYNOPSIS\nfloat4 texRECT(samplerRECT samp, float2 s)\nfloat4 texRECT(samplerRECT samp, float2 s, int texelOff)\nfloat4 texRECT(samplerRECT samp, float3 s)\nfloat4 texRECT(samplerRECT samp, float3 s, int texelOff)\nfloat4 texRECT(samplerRECT samp, float2 s, float2 dx, float2 dy)\nfloat4 texRECT(samplerRECT samp, float2 s, float2 dx, float2 dy, int texelOff)\nfloat4 texRECT(samplerRECT samp, float3 s, float2 dx, float2 dy)\nfloat4 texRECT(samplerRECT samp, float3 s, float2 dx, float2 dy, int texelOff)\nint4 texRECT(isamplerRECT samp, float2 s)\nint4 texRECT(isamplerRECT samp, float2 s, int texelOff)\nint4 texRECT(isamplerRECT samp, float2 s, float2 dx, float2 dy)\nint4 texRECT(isamplerRECT samp, float2 s, float2 dx, float2 dy, int texelOff)\nuint4 texRECT(usamplerRECT samp, float2 s)\nuint4 texRECT(usamplerRECT samp, float2 s, int texelOff)\nuint4 texRECT(usamplerRECT samp, float2 s, float2 dx, float2 dy)\nuint4 texRECT(usamplerRECT samp, float2 s, float2 dx, float2 dy,\nint texelOff)\n\n\nPARAMETERS\nsamp Sampler to lookup.\ns Coordinates to perform the lookup. If an extra coordinate compared to the texture dimensionality\nis present it is used to perform a shadow comparison. The value used in the shadow comparison is\nalways the last component of the coordinate vector.\ndx Pre computed derivative along the x axis.\ndy Pre computed derivative along the y axis.\ntexelOff Offset to be added to obtain the final texel.\n\n\nDESCRIPTION\nPerforms a texture lookup in sampler samp using coordinates s, may use and derivatives dx and dy, also\nmay perform shadow comparison and use texel offset texelOff to compute final texel.\n\n\nPROFILE SUPPORT\ntexRECT is supported in all fragment profiles and all vertex profiles starting with vp40, variants with\nshadow comparison are only supported in fp40 and newer profiles, variants with texel offsets are only\nsupported in gp4 and newer profiles. Variants with integer samplers are only supported in gp4 and newer\nprofiles.\n\n\nSEE ALSO\ntexRECTbias, texRECTlod, texRECTproj\n' )
end

function cg_texRECT_3:new()
	Node.new(self)
	self.name = 'texRECT'
	self.in_samp = self.add_port(Input('samp'))
	self.in_s = self.add_port(Input('s'))
	self.in_texelOff = self.add_port(Input('texelOff'))
	self.out = self.add_port(Output('out'))
end

function cg_texRECT_3:get_type(port)

	local type_samp = self.in_samp.get_output().get_type()
	local type_s = self.in_s.get_output().get_type()
	local type_texelOff = self.in_texelOff.get_output().get_type()
	if ((type_samp == 'samplerRECT')
	and (type_s == 'float2')
	and (type_texelOff == 'int')) then
		return 'float4'
	end
	if ((type_samp == 'samplerRECT')
	and (type_s == 'float3')
	and (type_texelOff == 'int')) then
		return 'float4'
	end
	if ((type_samp == 'isamplerRECT')
	and (type_s == 'float2')
	and (type_texelOff == 'int')) then
		return 'int4'
	end
	if ((type_samp == 'usamplerRECT')
	and (type_s == 'float2')
	and (type_texelOff == 'int')) then
		return 'uint4'
	end
	return nil
end

function cg_texRECT_3:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_texRECT_3:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_samp = 'r' .. self.in_samp.get_output().hex()
	local in_s = 'r' .. self.in_s.get_output().hex()
	local in_texelOff = 'r' .. self.in_texelOff.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = texRECT( ' .. in_samp.. ', ' .. in_s.. ', ' .. in_texelOff.. ' );\n')
end

function cg_texRECT_3:get_tip(out)
	out.write( 'texRECT - performs a texture lookup in a given RECT sampler and, in some cases, a shadow comparison. May also use pre computed derivatives if those are provided. ' )
end

-- #################################################### --
-- texRECT( samp, s, dx, dy )
-- #################################################### --
local cg_texRECT_4 = class(Node)
function cg_texRECT_4:get_help(out)
	out.write( '\n\nNAME\ntexRECT - performs a texture lookup in a given RECT sampler and, in some cases, a shadow comparison.\nMay also use pre computed derivatives if those are provided.\n\n\nSYNOPSIS\nfloat4 texRECT(samplerRECT samp, float2 s)\nfloat4 texRECT(samplerRECT samp, float2 s, int texelOff)\nfloat4 texRECT(samplerRECT samp, float3 s)\nfloat4 texRECT(samplerRECT samp, float3 s, int texelOff)\nfloat4 texRECT(samplerRECT samp, float2 s, float2 dx, float2 dy)\nfloat4 texRECT(samplerRECT samp, float2 s, float2 dx, float2 dy, int texelOff)\nfloat4 texRECT(samplerRECT samp, float3 s, float2 dx, float2 dy)\nfloat4 texRECT(samplerRECT samp, float3 s, float2 dx, float2 dy, int texelOff)\nint4 texRECT(isamplerRECT samp, float2 s)\nint4 texRECT(isamplerRECT samp, float2 s, int texelOff)\nint4 texRECT(isamplerRECT samp, float2 s, float2 dx, float2 dy)\nint4 texRECT(isamplerRECT samp, float2 s, float2 dx, float2 dy, int texelOff)\nuint4 texRECT(usamplerRECT samp, float2 s)\nuint4 texRECT(usamplerRECT samp, float2 s, int texelOff)\nuint4 texRECT(usamplerRECT samp, float2 s, float2 dx, float2 dy)\nuint4 texRECT(usamplerRECT samp, float2 s, float2 dx, float2 dy,\nint texelOff)\n\n\nPARAMETERS\nsamp Sampler to lookup.\ns Coordinates to perform the lookup. If an extra coordinate compared to the texture dimensionality\nis present it is used to perform a shadow comparison. The value used in the shadow comparison is\nalways the last component of the coordinate vector.\ndx Pre computed derivative along the x axis.\ndy Pre computed derivative along the y axis.\ntexelOff Offset to be added to obtain the final texel.\n\n\nDESCRIPTION\nPerforms a texture lookup in sampler samp using coordinates s, may use and derivatives dx and dy, also\nmay perform shadow comparison and use texel offset texelOff to compute final texel.\n\n\nPROFILE SUPPORT\ntexRECT is supported in all fragment profiles and all vertex profiles starting with vp40, variants with\nshadow comparison are only supported in fp40 and newer profiles, variants with texel offsets are only\nsupported in gp4 and newer profiles. Variants with integer samplers are only supported in gp4 and newer\nprofiles.\n\n\nSEE ALSO\ntexRECTbias, texRECTlod, texRECTproj\n' )
end

function cg_texRECT_4:new()
	Node.new(self)
	self.name = 'texRECT'
	self.in_samp = self.add_port(Input('samp'))
	self.in_s = self.add_port(Input('s'))
	self.in_dx = self.add_port(Input('dx'))
	self.in_dy = self.add_port(Input('dy'))
	self.out = self.add_port(Output('out'))
end

function cg_texRECT_4:get_type(port)

	local type_samp = self.in_samp.get_output().get_type()
	local type_s = self.in_s.get_output().get_type()
	local type_dx = self.in_dx.get_output().get_type()
	local type_dy = self.in_dy.get_output().get_type()
	if ((type_samp == 'samplerRECT')
	and (type_s == 'float2')
	and (type_dx == 'float2')
	and (type_dy == 'float2')) then
		return 'float4'
	end
	if ((type_samp == 'samplerRECT')
	and (type_s == 'float3')
	and (type_dx == 'float2')
	and (type_dy == 'float2')) then
		return 'float4'
	end
	if ((type_samp == 'isamplerRECT')
	and (type_s == 'float2')
	and (type_dx == 'float2')
	and (type_dy == 'float2')) then
		return 'int4'
	end
	if ((type_samp == 'usamplerRECT')
	and (type_s == 'float2')
	and (type_dx == 'float2')
	and (type_dy == 'float2')) then
		return 'uint4'
	end
	return nil
end

function cg_texRECT_4:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_texRECT_4:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_samp = 'r' .. self.in_samp.get_output().hex()
	local in_s = 'r' .. self.in_s.get_output().hex()
	local in_dx = 'r' .. self.in_dx.get_output().hex()
	local in_dy = 'r' .. self.in_dy.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = texRECT( ' .. in_samp.. ', ' .. in_s.. ', ' .. in_dx.. ', ' .. in_dy.. ' );\n')
end

function cg_texRECT_4:get_tip(out)
	out.write( 'texRECT - performs a texture lookup in a given RECT sampler and, in some cases, a shadow comparison. May also use pre computed derivatives if those are provided. ' )
end

-- #################################################### --
-- texRECT( samp, s, dx, dy, texelOff )
-- #################################################### --
local cg_texRECT_5 = class(Node)
function cg_texRECT_5:get_help(out)
	out.write( '\n\nNAME\ntexRECT - performs a texture lookup in a given RECT sampler and, in some cases, a shadow comparison.\nMay also use pre computed derivatives if those are provided.\n\n\nSYNOPSIS\nfloat4 texRECT(samplerRECT samp, float2 s)\nfloat4 texRECT(samplerRECT samp, float2 s, int texelOff)\nfloat4 texRECT(samplerRECT samp, float3 s)\nfloat4 texRECT(samplerRECT samp, float3 s, int texelOff)\nfloat4 texRECT(samplerRECT samp, float2 s, float2 dx, float2 dy)\nfloat4 texRECT(samplerRECT samp, float2 s, float2 dx, float2 dy, int texelOff)\nfloat4 texRECT(samplerRECT samp, float3 s, float2 dx, float2 dy)\nfloat4 texRECT(samplerRECT samp, float3 s, float2 dx, float2 dy, int texelOff)\nint4 texRECT(isamplerRECT samp, float2 s)\nint4 texRECT(isamplerRECT samp, float2 s, int texelOff)\nint4 texRECT(isamplerRECT samp, float2 s, float2 dx, float2 dy)\nint4 texRECT(isamplerRECT samp, float2 s, float2 dx, float2 dy, int texelOff)\nuint4 texRECT(usamplerRECT samp, float2 s)\nuint4 texRECT(usamplerRECT samp, float2 s, int texelOff)\nuint4 texRECT(usamplerRECT samp, float2 s, float2 dx, float2 dy)\nuint4 texRECT(usamplerRECT samp, float2 s, float2 dx, float2 dy,\nint texelOff)\n\n\nPARAMETERS\nsamp Sampler to lookup.\ns Coordinates to perform the lookup. If an extra coordinate compared to the texture dimensionality\nis present it is used to perform a shadow comparison. The value used in the shadow comparison is\nalways the last component of the coordinate vector.\ndx Pre computed derivative along the x axis.\ndy Pre computed derivative along the y axis.\ntexelOff Offset to be added to obtain the final texel.\n\n\nDESCRIPTION\nPerforms a texture lookup in sampler samp using coordinates s, may use and derivatives dx and dy, also\nmay perform shadow comparison and use texel offset texelOff to compute final texel.\n\n\nPROFILE SUPPORT\ntexRECT is supported in all fragment profiles and all vertex profiles starting with vp40, variants with\nshadow comparison are only supported in fp40 and newer profiles, variants with texel offsets are only\nsupported in gp4 and newer profiles. Variants with integer samplers are only supported in gp4 and newer\nprofiles.\n\n\nSEE ALSO\ntexRECTbias, texRECTlod, texRECTproj\n' )
end

function cg_texRECT_5:new()
	Node.new(self)
	self.name = 'texRECT'
	self.in_samp = self.add_port(Input('samp'))
	self.in_s = self.add_port(Input('s'))
	self.in_dx = self.add_port(Input('dx'))
	self.in_dy = self.add_port(Input('dy'))
	self.in_texelOff = self.add_port(Input('texelOff'))
	self.out = self.add_port(Output('out'))
end

function cg_texRECT_5:get_type(port)

	local type_samp = self.in_samp.get_output().get_type()
	local type_s = self.in_s.get_output().get_type()
	local type_dx = self.in_dx.get_output().get_type()
	local type_dy = self.in_dy.get_output().get_type()
	local type_texelOff = self.in_texelOff.get_output().get_type()
	if ((type_samp == 'samplerRECT')
	and (type_s == 'float2')
	and (type_dx == 'float2')
	and (type_dy == 'float2')
	and (type_texelOff == 'int')) then
		return 'float4'
	end
	if ((type_samp == 'samplerRECT')
	and (type_s == 'float3')
	and (type_dx == 'float2')
	and (type_dy == 'float2')
	and (type_texelOff == 'int')) then
		return 'float4'
	end
	if ((type_samp == 'isamplerRECT')
	and (type_s == 'float2')
	and (type_dx == 'float2')
	and (type_dy == 'float2')
	and (type_texelOff == 'int')) then
		return 'int4'
	end
	if ((type_samp == 'usamplerRECT')
	and (type_s == 'float2')
	and (type_dx == 'float2')
	and (type_dy == 'float2')
	and (type_texelOff == 'int')) then
		return 'uint4'
	end
	return nil
end

function cg_texRECT_5:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_texRECT_5:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_samp = 'r' .. self.in_samp.get_output().hex()
	local in_s = 'r' .. self.in_s.get_output().hex()
	local in_dx = 'r' .. self.in_dx.get_output().hex()
	local in_dy = 'r' .. self.in_dy.get_output().hex()
	local in_texelOff = 'r' .. self.in_texelOff.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = texRECT( ' .. in_samp.. ', ' .. in_s.. ', ' .. in_dx.. ', ' .. in_dy.. ', ' .. in_texelOff.. ' );\n')
end

function cg_texRECT_5:get_tip(out)
	out.write( 'texRECT - performs a texture lookup in a given RECT sampler and, in some cases, a shadow comparison. May also use pre computed derivatives if those are provided. ' )
end

-- #################################################### --
-- texRECTbias( samp, s )
-- #################################################### --
local cg_texRECTbias_2 = class(Node)
function cg_texRECTbias_2:get_help(out)
	out.write( '\n\nNAME\ntexRECTbias - performs a texture lookup with bias in a given sampler.\n\n\nSYNOPSIS\nfloat4 texRECTbias(samplerRECT samp, float4 s)\nfloat4 texRECTbias(samplerRECT samp, float4 s, int2 texelOff)\nint4 texRECTbias(isamplerRECT samp, float4 s)\nint4 texRECTbias(isamplerRECT samp, float4 s, int2 texelOff)\nuint4 texRECTbias(usamplerRECT samp, float4 s)\nuint4 texRECTbias(usamplerRECT samp, float4 s, int2 texelOff)\n\n\nPARAMETERS\nsamp Sampler to lookup.\ns Coordinates to perform the lookup. The bias value should be passed as the last component of the\ncoordinate vector.\ntexelOff Offset to be added to obtain the final texel.\n\n\nDESCRIPTION\nPerforms a texture lookup with bias in sampler samp using coordinates s.\n\n\nPROFILE SUPPORT\ntexRECTbias is supported in fragment profiles starting with fp30 and in vertex profiles starting with vp40.\nVariants with texelOff are only supported in gp4 and newer profiles. Variants with integer samplers are also\nonly suppported in gp4 and newer profiles.\n\n\nSEE ALSO\ntexRECTlod.de Sh\n\$1\n' )
end

function cg_texRECTbias_2:new()
	Node.new(self)
	self.name = 'texRECTbias'
	self.in_samp = self.add_port(Input('samp'))
	self.in_s = self.add_port(Input('s'))
	self.out = self.add_port(Output('out'))
end

function cg_texRECTbias_2:get_type(port)

	local type_samp = self.in_samp.get_output().get_type()
	local type_s = self.in_s.get_output().get_type()
	if ((type_samp == 'samplerRECT')
	and (type_s == 'float4')) then
		return 'float4'
	end
	if ((type_samp == 'isamplerRECT')
	and (type_s == 'float4')) then
		return 'int4'
	end
	if ((type_samp == 'usamplerRECT')
	and (type_s == 'float4')) then
		return 'uint4'
	end
	return nil
end

function cg_texRECTbias_2:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_texRECTbias_2:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_samp = 'r' .. self.in_samp.get_output().hex()
	local in_s = 'r' .. self.in_s.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = texRECTbias( ' .. in_samp.. ', ' .. in_s.. ' );\n')
end

function cg_texRECTbias_2:get_tip(out)
	out.write( 'texRECTbias - performs a texture lookup with bias in a given sampler. ' )
end

-- #################################################### --
-- texRECTbias( samp, s, texelOff )
-- #################################################### --
local cg_texRECTbias_3 = class(Node)
function cg_texRECTbias_3:get_help(out)
	out.write( '\n\nNAME\ntexRECTbias - performs a texture lookup with bias in a given sampler.\n\n\nSYNOPSIS\nfloat4 texRECTbias(samplerRECT samp, float4 s)\nfloat4 texRECTbias(samplerRECT samp, float4 s, int2 texelOff)\nint4 texRECTbias(isamplerRECT samp, float4 s)\nint4 texRECTbias(isamplerRECT samp, float4 s, int2 texelOff)\nuint4 texRECTbias(usamplerRECT samp, float4 s)\nuint4 texRECTbias(usamplerRECT samp, float4 s, int2 texelOff)\n\n\nPARAMETERS\nsamp Sampler to lookup.\ns Coordinates to perform the lookup. The bias value should be passed as the last component of the\ncoordinate vector.\ntexelOff Offset to be added to obtain the final texel.\n\n\nDESCRIPTION\nPerforms a texture lookup with bias in sampler samp using coordinates s.\n\n\nPROFILE SUPPORT\ntexRECTbias is supported in fragment profiles starting with fp30 and in vertex profiles starting with vp40.\nVariants with texelOff are only supported in gp4 and newer profiles. Variants with integer samplers are also\nonly suppported in gp4 and newer profiles.\n\n\nSEE ALSO\ntexRECTlod.de Sh\n\$1\n' )
end

function cg_texRECTbias_3:new()
	Node.new(self)
	self.name = 'texRECTbias'
	self.in_samp = self.add_port(Input('samp'))
	self.in_s = self.add_port(Input('s'))
	self.in_texelOff = self.add_port(Input('texelOff'))
	self.out = self.add_port(Output('out'))
end

function cg_texRECTbias_3:get_type(port)

	local type_samp = self.in_samp.get_output().get_type()
	local type_s = self.in_s.get_output().get_type()
	local type_texelOff = self.in_texelOff.get_output().get_type()
	if ((type_samp == 'samplerRECT')
	and (type_s == 'float4')
	and (type_texelOff == 'int2')) then
		return 'float4'
	end
	if ((type_samp == 'isamplerRECT')
	and (type_s == 'float4')
	and (type_texelOff == 'int2')) then
		return 'int4'
	end
	if ((type_samp == 'usamplerRECT')
	and (type_s == 'float4')
	and (type_texelOff == 'int2')) then
		return 'uint4'
	end
	return nil
end

function cg_texRECTbias_3:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_texRECTbias_3:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_samp = 'r' .. self.in_samp.get_output().hex()
	local in_s = 'r' .. self.in_s.get_output().hex()
	local in_texelOff = 'r' .. self.in_texelOff.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = texRECTbias( ' .. in_samp.. ', ' .. in_s.. ', ' .. in_texelOff.. ' );\n')
end

function cg_texRECTbias_3:get_tip(out)
	out.write( 'texRECTbias - performs a texture lookup with bias in a given sampler. ' )
end

-- #################################################### --
-- texRECTfetch( samp, s )
-- #################################################### --
local cg_texRECTfetch_2 = class(Node)
function cg_texRECTfetch_2:get_help(out)
	out.write( '\n\nNAME\ntexRECTfetch - performs an unfiltered texture lookup in a given sampler.\n\n\nSYNOPSIS\nfloat4 texRECTfetch(samplerRECT samp, int4 s)\nfloat4 texRECTfetch(samplerRECT samp, int4 s, int2 texelOff)\nint4 texRECTfetch(isamplerRECT samp, int4 s)\nint4 texRECTfetch(isamplerRECT samp, int4 s, int2 texelOff)\nuint4 texRECTfetch(usamplerRECT samp, int4 s)\nuint4 texRECTfetch(usamplerRECT samp, int4 s, int2 texelOff)\n\n\nPARAMETERS\nsamp Sampler to lookup.\ns Coordinates to perform the lookup. The level of detail is stored in the last component of the\ncoordinate vector.\ntexelOff Offset to be added to obtain the final texel.\n\n\nDESCRIPTION\nPerforms an unfiltered texture lookup in sampler samp using coordinates s. The level of detail is provided\nby the last component of the coordinate vector. May use texel offset texelOff to compute final texel.\n\n\nPROFILE SUPPORT\ntexRECTfetch is only supported in gp4 and newer profiles.\n\n\nSEE ALSO\ntexRECT, texRECTARRAYfetch.de Sh\n\$1\n' )
end

function cg_texRECTfetch_2:new()
	Node.new(self)
	self.name = 'texRECTfetch'
	self.in_samp = self.add_port(Input('samp'))
	self.in_s = self.add_port(Input('s'))
	self.out = self.add_port(Output('out'))
end

function cg_texRECTfetch_2:get_type(port)

	local type_samp = self.in_samp.get_output().get_type()
	local type_s = self.in_s.get_output().get_type()
	if ((type_samp == 'samplerRECT')
	and (type_s == 'int4')) then
		return 'float4'
	end
	if ((type_samp == 'isamplerRECT')
	and (type_s == 'int4')) then
		return 'int4'
	end
	if ((type_samp == 'usamplerRECT')
	and (type_s == 'int4')) then
		return 'uint4'
	end
	return nil
end

function cg_texRECTfetch_2:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_texRECTfetch_2:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_samp = 'r' .. self.in_samp.get_output().hex()
	local in_s = 'r' .. self.in_s.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = texRECTfetch( ' .. in_samp.. ', ' .. in_s.. ' );\n')
end

function cg_texRECTfetch_2:get_tip(out)
	out.write( 'texRECTfetch - performs an unfiltered texture lookup in a given sampler. ' )
end

-- #################################################### --
-- texRECTfetch( samp, s, texelOff )
-- #################################################### --
local cg_texRECTfetch_3 = class(Node)
function cg_texRECTfetch_3:get_help(out)
	out.write( '\n\nNAME\ntexRECTfetch - performs an unfiltered texture lookup in a given sampler.\n\n\nSYNOPSIS\nfloat4 texRECTfetch(samplerRECT samp, int4 s)\nfloat4 texRECTfetch(samplerRECT samp, int4 s, int2 texelOff)\nint4 texRECTfetch(isamplerRECT samp, int4 s)\nint4 texRECTfetch(isamplerRECT samp, int4 s, int2 texelOff)\nuint4 texRECTfetch(usamplerRECT samp, int4 s)\nuint4 texRECTfetch(usamplerRECT samp, int4 s, int2 texelOff)\n\n\nPARAMETERS\nsamp Sampler to lookup.\ns Coordinates to perform the lookup. The level of detail is stored in the last component of the\ncoordinate vector.\ntexelOff Offset to be added to obtain the final texel.\n\n\nDESCRIPTION\nPerforms an unfiltered texture lookup in sampler samp using coordinates s. The level of detail is provided\nby the last component of the coordinate vector. May use texel offset texelOff to compute final texel.\n\n\nPROFILE SUPPORT\ntexRECTfetch is only supported in gp4 and newer profiles.\n\n\nSEE ALSO\ntexRECT, texRECTARRAYfetch.de Sh\n\$1\n' )
end

function cg_texRECTfetch_3:new()
	Node.new(self)
	self.name = 'texRECTfetch'
	self.in_samp = self.add_port(Input('samp'))
	self.in_s = self.add_port(Input('s'))
	self.in_texelOff = self.add_port(Input('texelOff'))
	self.out = self.add_port(Output('out'))
end

function cg_texRECTfetch_3:get_type(port)

	local type_samp = self.in_samp.get_output().get_type()
	local type_s = self.in_s.get_output().get_type()
	local type_texelOff = self.in_texelOff.get_output().get_type()
	if ((type_samp == 'samplerRECT')
	and (type_s == 'int4')
	and (type_texelOff == 'int2')) then
		return 'float4'
	end
	if ((type_samp == 'isamplerRECT')
	and (type_s == 'int4')
	and (type_texelOff == 'int2')) then
		return 'int4'
	end
	if ((type_samp == 'usamplerRECT')
	and (type_s == 'int4')
	and (type_texelOff == 'int2')) then
		return 'uint4'
	end
	return nil
end

function cg_texRECTfetch_3:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_texRECTfetch_3:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_samp = 'r' .. self.in_samp.get_output().hex()
	local in_s = 'r' .. self.in_s.get_output().hex()
	local in_texelOff = 'r' .. self.in_texelOff.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = texRECTfetch( ' .. in_samp.. ', ' .. in_s.. ', ' .. in_texelOff.. ' );\n')
end

function cg_texRECTfetch_3:get_tip(out)
	out.write( 'texRECTfetch - performs an unfiltered texture lookup in a given sampler. ' )
end

-- #################################################### --
-- texRECTlod( samp, s )
-- #################################################### --
local cg_texRECTlod_2 = class(Node)
function cg_texRECTlod_2:get_help(out)
	out.write( '\n\nNAME\ntexRECTlod - performs a texture lookup with a specified level of detail in a given sampler.\n\n\nSYNOPSIS\nfloat4 texRECTlod(samplerRECT samp, float4 s)\nfloat4 texRECTlod(samplerRECT samp, float4 s, int texelOff)\nint4 texRECTlod(isamplerRECT samp, float4 s)\nint4 texRECTlod(isamplerRECT samp, float4 s, int texelOff)\nuint4 texRECTlod(usamplerRECT samp, float4 s)\nuint4 texRECTlod(usamplerRECT samp, float4 s, int texelOff)\n\n\nPARAMETERS\nsamp Sampler to lookup.\ns Coordinates to perform the lookup. The level of detail should be passed as the last component of\nthe coordinate vector.\ntexelOff Offset to be added to obtain the final texel.\n\n\nDESCRIPTION\nPerforms a texture lookup with a specified level of detail in sampler samp using coordinates s.\n\n\nPROFILE SUPPORT\ntexRECTlod is supported in fragment profiles starting with fp40 and in vertex profiles starting with vp40.\nVariants with texelOff are only supported in gp4 and newer profiles. Variants with integer samplers are also\nonly suppported in gp4 and newer profiles.\n\n\nSEE ALSO\ntexRECTbias.de Sh\n\$1\n' )
end

function cg_texRECTlod_2:new()
	Node.new(self)
	self.name = 'texRECTlod'
	self.in_samp = self.add_port(Input('samp'))
	self.in_s = self.add_port(Input('s'))
	self.out = self.add_port(Output('out'))
end

function cg_texRECTlod_2:get_type(port)

	local type_samp = self.in_samp.get_output().get_type()
	local type_s = self.in_s.get_output().get_type()
	if ((type_samp == 'samplerRECT')
	and (type_s == 'float4')) then
		return 'float4'
	end
	if ((type_samp == 'isamplerRECT')
	and (type_s == 'float4')) then
		return 'int4'
	end
	if ((type_samp == 'usamplerRECT')
	and (type_s == 'float4')) then
		return 'uint4'
	end
	return nil
end

function cg_texRECTlod_2:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_texRECTlod_2:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_samp = 'r' .. self.in_samp.get_output().hex()
	local in_s = 'r' .. self.in_s.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = texRECTlod( ' .. in_samp.. ', ' .. in_s.. ' );\n')
end

function cg_texRECTlod_2:get_tip(out)
	out.write( 'texRECTlod - performs a texture lookup with a specified level of detail in a given sampler. ' )
end

-- #################################################### --
-- texRECTlod( samp, s, texelOff )
-- #################################################### --
local cg_texRECTlod_3 = class(Node)
function cg_texRECTlod_3:get_help(out)
	out.write( '\n\nNAME\ntexRECTlod - performs a texture lookup with a specified level of detail in a given sampler.\n\n\nSYNOPSIS\nfloat4 texRECTlod(samplerRECT samp, float4 s)\nfloat4 texRECTlod(samplerRECT samp, float4 s, int texelOff)\nint4 texRECTlod(isamplerRECT samp, float4 s)\nint4 texRECTlod(isamplerRECT samp, float4 s, int texelOff)\nuint4 texRECTlod(usamplerRECT samp, float4 s)\nuint4 texRECTlod(usamplerRECT samp, float4 s, int texelOff)\n\n\nPARAMETERS\nsamp Sampler to lookup.\ns Coordinates to perform the lookup. The level of detail should be passed as the last component of\nthe coordinate vector.\ntexelOff Offset to be added to obtain the final texel.\n\n\nDESCRIPTION\nPerforms a texture lookup with a specified level of detail in sampler samp using coordinates s.\n\n\nPROFILE SUPPORT\ntexRECTlod is supported in fragment profiles starting with fp40 and in vertex profiles starting with vp40.\nVariants with texelOff are only supported in gp4 and newer profiles. Variants with integer samplers are also\nonly suppported in gp4 and newer profiles.\n\n\nSEE ALSO\ntexRECTbias.de Sh\n\$1\n' )
end

function cg_texRECTlod_3:new()
	Node.new(self)
	self.name = 'texRECTlod'
	self.in_samp = self.add_port(Input('samp'))
	self.in_s = self.add_port(Input('s'))
	self.in_texelOff = self.add_port(Input('texelOff'))
	self.out = self.add_port(Output('out'))
end

function cg_texRECTlod_3:get_type(port)

	local type_samp = self.in_samp.get_output().get_type()
	local type_s = self.in_s.get_output().get_type()
	local type_texelOff = self.in_texelOff.get_output().get_type()
	if ((type_samp == 'samplerRECT')
	and (type_s == 'float4')
	and (type_texelOff == 'int')) then
		return 'float4'
	end
	if ((type_samp == 'isamplerRECT')
	and (type_s == 'float4')
	and (type_texelOff == 'int')) then
		return 'int4'
	end
	if ((type_samp == 'usamplerRECT')
	and (type_s == 'float4')
	and (type_texelOff == 'int')) then
		return 'uint4'
	end
	return nil
end

function cg_texRECTlod_3:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_texRECTlod_3:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_samp = 'r' .. self.in_samp.get_output().hex()
	local in_s = 'r' .. self.in_s.get_output().hex()
	local in_texelOff = 'r' .. self.in_texelOff.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = texRECTlod( ' .. in_samp.. ', ' .. in_s.. ', ' .. in_texelOff.. ' );\n')
end

function cg_texRECTlod_3:get_tip(out)
	out.write( 'texRECTlod - performs a texture lookup with a specified level of detail in a given sampler. ' )
end

-- #################################################### --
-- texRECTproj( samp, s )
-- #################################################### --
local cg_texRECTproj_2 = class(Node)
function cg_texRECTproj_2:get_help(out)
	out.write( '\n\nNAME\ntexRECTproj - performs a texture lookup with projection in a given sampler. May perform a shadow\ncomparison if argument for shadow comparison is provided.\n\n\nSYNOPSIS\nfloat4 texRECTproj(samplerRECT samp, float3 s)\nfloat4 texRECTproj(samplerRECT samp, float3 s, int texelOff)\nfloat4 texRECTproj(samplerRECT samp, float4 s)\nfloat4 texRECTproj(samplerRECT samp, float4 s, int texelOff)\nint4 texRECTproj(isamplerRECT samp, float3 s)\nint4 texRECTproj(isamplerRECT samp, float3 s, int texelOff)\nuint4 texRECTproj(usamplerRECT samp, float3 s)\nuint4 texRECTproj(usamplerRECT samp, float3 s, int texelOff)\n\n\nPARAMETERS\nsamp Sampler to lookup.\ns Coordinates to perform the lookup. The value used in the projection should be passed as the last\ncomponent of the coordinate vector. The value used in the shadow comparison, if present, should\nbe passed as the next-to-last component of the coordinate vector.\ntexelOff Offset to be added to obtain the final texel.\n\n\nDESCRIPTION\nPerforms a texture lookup in sampler samp using coordinates s, the coordinates used in the lookup are first\nprojected, that is, divided by the last component of the coordinate vector and them used in the lookup. If an\nextra coordinate is present it is used to perform a shadow comparison, the value used in the shadow\ncomparison is always the next-to-last component in the coordinate vector.\n\n\nPROFILE SUPPORT\ntexRECTproj is supported in all fragment profiles and all vertex profiles starting with vp40, variants with\nshadow comparison are only supported in fp40 and newer profiles, variants with texel offsets are only\nsupported in gp4 and newer profiles.\n\n\nSEE ALSO\ntexRECT\n' )
end

function cg_texRECTproj_2:new()
	Node.new(self)
	self.name = 'texRECTproj'
	self.in_samp = self.add_port(Input('samp'))
	self.in_s = self.add_port(Input('s'))
	self.out = self.add_port(Output('out'))
end

function cg_texRECTproj_2:get_type(port)

	local type_samp = self.in_samp.get_output().get_type()
	local type_s = self.in_s.get_output().get_type()
	if ((type_samp == 'samplerRECT')
	and (type_s == 'float3')) then
		return 'float4'
	end
	if ((type_samp == 'samplerRECT')
	and (type_s == 'float4')) then
		return 'float4'
	end
	if ((type_samp == 'isamplerRECT')
	and (type_s == 'float3')) then
		return 'int4'
	end
	if ((type_samp == 'usamplerRECT')
	and (type_s == 'float3')) then
		return 'uint4'
	end
	return nil
end

function cg_texRECTproj_2:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_texRECTproj_2:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_samp = 'r' .. self.in_samp.get_output().hex()
	local in_s = 'r' .. self.in_s.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = texRECTproj( ' .. in_samp.. ', ' .. in_s.. ' );\n')
end

function cg_texRECTproj_2:get_tip(out)
	out.write( 'texRECTproj - performs a texture lookup with projection in a given sampler. May perform a shadow comparison if argument for shadow comparison is provided. ' )
end

-- #################################################### --
-- texRECTproj( samp, s, texelOff )
-- #################################################### --
local cg_texRECTproj_3 = class(Node)
function cg_texRECTproj_3:get_help(out)
	out.write( '\n\nNAME\ntexRECTproj - performs a texture lookup with projection in a given sampler. May perform a shadow\ncomparison if argument for shadow comparison is provided.\n\n\nSYNOPSIS\nfloat4 texRECTproj(samplerRECT samp, float3 s)\nfloat4 texRECTproj(samplerRECT samp, float3 s, int texelOff)\nfloat4 texRECTproj(samplerRECT samp, float4 s)\nfloat4 texRECTproj(samplerRECT samp, float4 s, int texelOff)\nint4 texRECTproj(isamplerRECT samp, float3 s)\nint4 texRECTproj(isamplerRECT samp, float3 s, int texelOff)\nuint4 texRECTproj(usamplerRECT samp, float3 s)\nuint4 texRECTproj(usamplerRECT samp, float3 s, int texelOff)\n\n\nPARAMETERS\nsamp Sampler to lookup.\ns Coordinates to perform the lookup. The value used in the projection should be passed as the last\ncomponent of the coordinate vector. The value used in the shadow comparison, if present, should\nbe passed as the next-to-last component of the coordinate vector.\ntexelOff Offset to be added to obtain the final texel.\n\n\nDESCRIPTION\nPerforms a texture lookup in sampler samp using coordinates s, the coordinates used in the lookup are first\nprojected, that is, divided by the last component of the coordinate vector and them used in the lookup. If an\nextra coordinate is present it is used to perform a shadow comparison, the value used in the shadow\ncomparison is always the next-to-last component in the coordinate vector.\n\n\nPROFILE SUPPORT\ntexRECTproj is supported in all fragment profiles and all vertex profiles starting with vp40, variants with\nshadow comparison are only supported in fp40 and newer profiles, variants with texel offsets are only\nsupported in gp4 and newer profiles.\n\n\nSEE ALSO\ntexRECT\n' )
end

function cg_texRECTproj_3:new()
	Node.new(self)
	self.name = 'texRECTproj'
	self.in_samp = self.add_port(Input('samp'))
	self.in_s = self.add_port(Input('s'))
	self.in_texelOff = self.add_port(Input('texelOff'))
	self.out = self.add_port(Output('out'))
end

function cg_texRECTproj_3:get_type(port)

	local type_samp = self.in_samp.get_output().get_type()
	local type_s = self.in_s.get_output().get_type()
	local type_texelOff = self.in_texelOff.get_output().get_type()
	if ((type_samp == 'samplerRECT')
	and (type_s == 'float3')
	and (type_texelOff == 'int')) then
		return 'float4'
	end
	if ((type_samp == 'samplerRECT')
	and (type_s == 'float4')
	and (type_texelOff == 'int')) then
		return 'float4'
	end
	if ((type_samp == 'isamplerRECT')
	and (type_s == 'float3')
	and (type_texelOff == 'int')) then
		return 'int4'
	end
	if ((type_samp == 'usamplerRECT')
	and (type_s == 'float3')
	and (type_texelOff == 'int')) then
		return 'uint4'
	end
	return nil
end

function cg_texRECTproj_3:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_texRECTproj_3:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_samp = 'r' .. self.in_samp.get_output().hex()
	local in_s = 'r' .. self.in_s.get_output().hex()
	local in_texelOff = 'r' .. self.in_texelOff.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = texRECTproj( ' .. in_samp.. ', ' .. in_s.. ', ' .. in_texelOff.. ' );\n')
end

function cg_texRECTproj_3:get_tip(out)
	out.write( 'texRECTproj - performs a texture lookup with projection in a given sampler. May perform a shadow comparison if argument for shadow comparison is provided. ' )
end

-- #################################################### --
-- texRECTsize( samp, lod )
-- #################################################### --
local cg_texRECTsize_2 = class(Node)
function cg_texRECTsize_2:get_help(out)
	out.write( '\n\nNAME\ntexRECTsize - returns the size of a given texture image for a given level of detail.\n\n\nSYNOPSIS\nint3 texRECTsize(samplerRECT samp, int lod)\nint3 texRECTsize(isamplerRECT samp, int lod)\nint3 texRECTsize(usamplerRECT samp, int lod)\n\n\nPARAMETERS\nsamp Sampler to be queried for size.\nlod Level of detail to obtain size.\n\n\nDESCRIPTION\nGiven a sampler and a level of detail the size of the corresponding texture image is returned as the result of\nthe operation.\n\n\nPROFILE SUPPORT\ntexRECTsize is only supported in gp4 and newer profiles.\n\n\nSEE ALSO\ntexRECT.de Sh\n\$1\n' )
end

function cg_texRECTsize_2:new()
	Node.new(self)
	self.name = 'texRECTsize'
	self.in_samp = self.add_port(Input('samp'))
	self.in_lod = self.add_port(Input('lod'))
	self.out = self.add_port(Output('out'))
end

function cg_texRECTsize_2:get_type(port)

	local type_samp = self.in_samp.get_output().get_type()
	local type_lod = self.in_lod.get_output().get_type()
	if ((type_samp == 'samplerRECT')
	and (type_lod == 'int')) then
		return 'int3'
	end
	if ((type_samp == 'isamplerRECT')
	and (type_lod == 'int')) then
		return 'int3'
	end
	if ((type_samp == 'usamplerRECT')
	and (type_lod == 'int')) then
		return 'int3'
	end
	return nil
end

function cg_texRECTsize_2:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_texRECTsize_2:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_samp = 'r' .. self.in_samp.get_output().hex()
	local in_lod = 'r' .. self.in_lod.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = texRECTsize( ' .. in_samp.. ', ' .. in_lod.. ' );\n')
end

function cg_texRECTsize_2:get_tip(out)
	out.write( 'texRECTsize - returns the size of a given texture image for a given level of detail. ' )
end

-- #################################################### --
-- transpose( A )
-- #################################################### --
local cg_transpose_1 = class(Node)
function cg_transpose_1:get_help(out)
	out.write( '\n\nNAME\ntranspose - returns transpose matrix of a matrix\n\n\nSYNOPSIS\nfloat4x4 transpose(float4x4 A)\nfloat3x4 transpose(float4x3 A)\nfloat2x4 transpose(float4x2 A)\nfloat1x4 transpose(float4x1 A)\nfloat4x3 transpose(float3x4 A)\nfloat3x3 transpose(float3x3 A)\nfloat2x3 transpose(float3x2 A)\nfloat1x3 transpose(float3x1 A)\nfloat4x2 transpose(float2x4 A)\nfloat3x2 transpose(float2x3 A)\nfloat2x2 transpose(float2x2 A)\nfloat1x2 transpose(float2x1 A)\nfloat4x1 transpose(float1x4 A)\nfloat3x1 transpose(float1x3 A)\nfloat2x1 transpose(float1x2 A)\nfloat1x1 transpose(float1x1 A)\n\n\nPARAMETERS\nA Matrix to tranpose.\n\n\nDESCRIPTION\nReturns the transpose of the matrix A.\n\n\nREFERENCE IMPLEMENTATION\ntranspose for a float4x3 matrix can be implemented like this:\nfloat4x3 transpose(float3x4 A)\n{\nfloat4x3 C;\nC[0] = A._m00_m10_m20;\nC[1] = A._m01_m11_m21;\nC[2] = A._m02_m12_m22;\nC[3] = A._m03_m13_m23;\nreturn C;\n}\n\n\nPROFILE SUPPORT\ntranspose is supported in all profiles.\n\n\nSEE ALSO\ndeterminant, mul\n' )
end

function cg_transpose_1:new()
	Node.new(self)
	self.name = 'transpose'
	self.in_A = self.add_port(Input('A'))
	self.out = self.add_port(Output('out'))
end

function cg_transpose_1:get_type(port)

	local type_A = self.in_A.get_output().get_type()
	if ((type_A == 'float4x4')) then
		return 'float4x4'
	end
	if ((type_A == 'float4x3')) then
		return 'float3x4'
	end
	if ((type_A == 'float4x2')) then
		return 'float2x4'
	end
	if ((type_A == 'float4x1')) then
		return 'float1x4'
	end
	if ((type_A == 'float3x4')) then
		return 'float4x3'
	end
	if ((type_A == 'float3x3')) then
		return 'float3x3'
	end
	if ((type_A == 'float3x2')) then
		return 'float2x3'
	end
	if ((type_A == 'float3x1')) then
		return 'float1x3'
	end
	if ((type_A == 'float2x4')) then
		return 'float4x2'
	end
	if ((type_A == 'float2x3')) then
		return 'float3x2'
	end
	if ((type_A == 'float2x2')) then
		return 'float2x2'
	end
	if ((type_A == 'float2x1')) then
		return 'float1x2'
	end
	if ((type_A == 'float1x4')) then
		return 'float4x1'
	end
	if ((type_A == 'float1x3')) then
		return 'float3x1'
	end
	if ((type_A == 'float1x2')) then
		return 'float2x1'
	end
	if ((type_A == 'float1x1')) then
		return 'float1x1'
	end
	return nil
end

function cg_transpose_1:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_transpose_1:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_A = 'r' .. self.in_A.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = transpose( ' .. in_A.. ' );\n')
end

function cg_transpose_1:get_tip(out)
	out.write( 'transpose - returns transpose matrix of a matrix ' )
end

-- #################################################### --
-- trunc( x )
-- #################################################### --
local cg_trunc_1 = class(Node)
function cg_trunc_1:get_help(out)
	out.write( '\n\nNAME\ntrunc - returns largest integer not greater than a scalar or each vector component.\n\n\nSYNOPSIS\nfloat trunc(float x);\nfloat1 trunc(float1 x);\nfloat2 trunc(float2 x);\nfloat3 trunc(float3 x);\nfloat4 trunc(float4 x);\nhalf trunc(half x);\nhalf1 trunc(half1 x);\nhalf2 trunc(half2 x);\nhalf3 trunc(half3 x);\nhalf4 trunc(half4 x);\nfixed trunc(fixed x);\nfixed1 trunc(fixed1 x);\nfixed2 trunc(fixed2 x);\nfixed3 trunc(fixed3 x);\nfixed4 trunc(fixed4 x);\n\n\nPARAMETERS\nx Vector or scalar which to truncate.\n\n\nDESCRIPTION\nReturns the integral value nearest to but no larger in magnitude than x.\n\n\nREFERENCE IMPLEMENTATION\ntrunc for a float3 vector could be implemented like this.\nfloat3 trunc(float3 v)\n{\nfloat3 rv;\nint i;\nfor (i=0; i<3; i++) {\nfloat x = v[i];\nrv[i] = x < 0 ? -floor(-x) : floor(x);\n}\nreturn rv;\n}\n\n\nPROFILE SUPPORT\ntrunc is supported in all profiles except fp20.\n\n\nSEE ALSO\nceil, floor, round\n' )
end

function cg_trunc_1:new()
	Node.new(self)
	self.name = 'trunc'
	self.in_x = self.add_port(Input('x'))
	self.out = self.add_port(Output('out'))
end

function cg_trunc_1:get_type(port)

	local type_x = self.in_x.get_output().get_type()
	if ((type_x == 'float')) then
		return 'float'
	end
	if ((type_x == 'float1')) then
		return 'float1'
	end
	if ((type_x == 'float2')) then
		return 'float2'
	end
	if ((type_x == 'float3')) then
		return 'float3'
	end
	if ((type_x == 'float4')) then
		return 'float4'
	end
	if ((type_x == 'half')) then
		return 'half'
	end
	if ((type_x == 'half1')) then
		return 'half1'
	end
	if ((type_x == 'half2')) then
		return 'half2'
	end
	if ((type_x == 'half3')) then
		return 'half3'
	end
	if ((type_x == 'half4')) then
		return 'half4'
	end
	if ((type_x == 'fixed')) then
		return 'fixed'
	end
	if ((type_x == 'fixed1')) then
		return 'fixed1'
	end
	if ((type_x == 'fixed2')) then
		return 'fixed2'
	end
	if ((type_x == 'fixed3')) then
		return 'fixed3'
	end
	if ((type_x == 'fixed4')) then
		return 'fixed4'
	end
	return nil
end

function cg_trunc_1:config(props)
	Node.config(self, props)
	props.delete('Name')
end

function cg_trunc_1:gen_code(out, scratch)
	local out_type   = self.get_type()
	local d    = 'r' .. self.out.hex()
	local in_x = 'r' .. self.in_x.get_output().hex()

	out.write( '	' .. out_type .. ' ' .. d .. ' = trunc( ' .. in_x.. ' );\n')
end

function cg_trunc_1:get_tip(out)
	out.write( 'trunc - returns largest integer not greater than a scalar or each vector component. ' )
end



-- #################################################### --
register {
  __name = 'Cg [stdlib]',
  __prologue = '',
  __epilogue = '',
  ['abs( a )'] = cg_abs_1,
  ['acos( a )'] = cg_acos_1,
  ['all( a )'] = cg_all_1,
  ['any( a )'] = cg_any_1,
  ['asin( a )'] = cg_asin_1,
  ['atan( a )'] = cg_atan_1,
  ['atan2( y, x )'] = cg_atan2_2,
  ['ceil( a )'] = cg_ceil_1,
  ['clamp( x, a, b )'] = cg_clamp_3,
  ['cos( a )'] = cg_cos_1,
  ['cosh( a )'] = cg_cosh_1,
  ['cross( a, b )'] = cg_cross_2,
  ['ddx( a )'] = cg_ddx_1,
  ['ddy( a )'] = cg_ddy_1,
  ['degrees( a )'] = cg_degrees_1,
  ['determinant( A )'] = cg_determinant_1,
  ['dot( a, b )'] = cg_dot_2,
  ['exp( a )'] = cg_exp_1,
  ['exp2( a )'] = cg_exp2_1,
  ['faceforward( N, I, Ng )'] = cg_faceforward_3,
  ['floatToIntBits( x )'] = cg_floatToIntBits_1,
  ['floatToRawIntBits( x )'] = cg_floatToRawIntBits_1,
  ['floor( a )'] = cg_floor_1,
  ['fmod( x, y )'] = cg_fmod_2,
  ['frac( a )'] = cg_frac_1,
  ['frexp( x, e )'] = cg_frexp_2,
  ['fwidth( a )'] = cg_fwidth_1,
  ['intBitsToFloat( x )'] = cg_intBitsToFloat_1,
  ['isfinite( x )'] = cg_isfinite_1,
  ['isinf( x )'] = cg_isinf_1,
  ['isnan( x )'] = cg_isnan_1,
  ['ldexp( x, n )'] = cg_ldexp_2,
  ['length( v )'] = cg_length_1,
  ['lerp( a, b, w )'] = cg_lerp_3,
  ['log( a )'] = cg_log_1,
  ['log10( a )'] = cg_log10_1,
  ['log2( a )'] = cg_log2_1,
  ['max( a, b )'] = cg_max_2,
  ['min( a, b )'] = cg_min_2,
  ['mul( M, v )'] = cg_mul_2,
  ['normalize( a )'] = cg_normalize_1,
  ['pow( x, y )'] = cg_pow_2,
  ['radians( a )'] = cg_radians_1,
  ['reflect( i, n )'] = cg_reflect_2,
  ['refract( i, n, eta )'] = cg_refract_3,
  ['round( a )'] = cg_round_1,
  ['saturate( x )'] = cg_saturate_1,
  ['sin( a )'] = cg_sin_1,
  ['sinh( a )'] = cg_sinh_1,
  ['sqrt( a )'] = cg_sqrt_1,
  ['tan( a )'] = cg_tan_1,
  ['tanh( a )'] = cg_tanh_1,
  ['tex1D( samp, s )'] = cg_tex1D_2,
  ['tex1D( samp, s, texelOff )'] = cg_tex1D_3,
  ['tex1D( samp, s, dx, dy )'] = cg_tex1D_4,
  ['tex1D( samp, s, dx, dy, texelOff )'] = cg_tex1D_5,
  ['tex1DARRAY( samp, s )'] = cg_tex1DARRAY_2,
  ['tex1DARRAY( samp, s, texelOff )'] = cg_tex1DARRAY_3,
  ['tex1DARRAY( samp, s, dx, dy )'] = cg_tex1DARRAY_4,
  ['tex1DARRAY( samp, s, dx, dy, texelOff )'] = cg_tex1DARRAY_5,
  ['tex1DARRAYbias( samp, s )'] = cg_tex1DARRAYbias_2,
  ['tex1DARRAYbias( samp, s, texelOff )'] = cg_tex1DARRAYbias_3,
  ['tex1DARRAYcmpbias( samp, s )'] = cg_tex1DARRAYcmpbias_2,
  ['tex1DARRAYcmpbias( samp, s, texelOff )'] = cg_tex1DARRAYcmpbias_3,
  ['tex1DARRAYcmplod( samp, s )'] = cg_tex1DARRAYcmplod_2,
  ['tex1DARRAYcmplod( samp, s, texelOff )'] = cg_tex1DARRAYcmplod_3,
  ['tex1DARRAYfetch( samp, s )'] = cg_tex1DARRAYfetch_2,
  ['tex1DARRAYfetch( samp, s, texelOff )'] = cg_tex1DARRAYfetch_3,
  ['tex1DARRAYlod( samp, s )'] = cg_tex1DARRAYlod_2,
  ['tex1DARRAYlod( samp, s, texelOff )'] = cg_tex1DARRAYlod_3,
  ['tex1DARRAYproj( samp, s )'] = cg_tex1DARRAYproj_2,
  ['tex1DARRAYproj( samp, s, texelOff )'] = cg_tex1DARRAYproj_3,
  ['tex1DARRAYsize( samp, lod )'] = cg_tex1DARRAYsize_2,
  ['tex1Dbias( samp, s )'] = cg_tex1Dbias_2,
  ['tex1Dbias( samp, s, texelOff )'] = cg_tex1Dbias_3,
  ['tex1Dcmpbias( samp, s )'] = cg_tex1Dcmpbias_2,
  ['tex1Dcmpbias( samp, s, texelOff )'] = cg_tex1Dcmpbias_3,
  ['tex1Dcmplod( samp, s )'] = cg_tex1Dcmplod_2,
  ['tex1Dcmplod( samp, s, texelOff )'] = cg_tex1Dcmplod_3,
  ['tex1Dfetch( samp, s )'] = cg_tex1Dfetch_2,
  ['tex1Dfetch( samp, s, texelOff )'] = cg_tex1Dfetch_3,
  ['tex1Dlod( samp, s )'] = cg_tex1Dlod_2,
  ['tex1Dlod( samp, s, texelOff )'] = cg_tex1Dlod_3,
  ['tex1Dproj( samp, s )'] = cg_tex1Dproj_2,
  ['tex1Dproj( samp, s, texelOff )'] = cg_tex1Dproj_3,
  ['tex1Dsize( samp, lod )'] = cg_tex1Dsize_2,
  ['tex2D( samp, s )'] = cg_tex2D_2,
  ['tex2D( samp, s, texelOff )'] = cg_tex2D_3,
  ['tex2D( samp, s, dx, dy )'] = cg_tex2D_4,
  ['tex2D( samp, s, dx, dy, texelOff )'] = cg_tex2D_5,
  ['tex2DARRAY( samp, s )'] = cg_tex2DARRAY_2,
  ['tex2DARRAY( samp, s, texelOff )'] = cg_tex2DARRAY_3,
  ['tex2DARRAY( samp, s, dx, dy )'] = cg_tex2DARRAY_4,
  ['tex2DARRAY( samp, s, dx, dy, texelOff )'] = cg_tex2DARRAY_5,
  ['tex2DARRAYbias( samp, s )'] = cg_tex2DARRAYbias_2,
  ['tex2DARRAYbias( samp, s, texelOff )'] = cg_tex2DARRAYbias_3,
  ['tex2DARRAYfetch( samp, s )'] = cg_tex2DARRAYfetch_2,
  ['tex2DARRAYfetch( samp, s, texelOff )'] = cg_tex2DARRAYfetch_3,
  ['tex2DARRAYlod( samp, s )'] = cg_tex2DARRAYlod_2,
  ['tex2DARRAYlod( samp, s, texelOff )'] = cg_tex2DARRAYlod_3,
  ['tex2DARRAYproj( samp, s )'] = cg_tex2DARRAYproj_2,
  ['tex2DARRAYproj( samp, s, texelOff )'] = cg_tex2DARRAYproj_3,
  ['tex2DARRAYsize( samp, lod )'] = cg_tex2DARRAYsize_2,
  ['tex2Dbias( samp, s )'] = cg_tex2Dbias_2,
  ['tex2Dbias( samp, s, texelOff )'] = cg_tex2Dbias_3,
  ['tex2Dcmpbias( samp, s )'] = cg_tex2Dcmpbias_2,
  ['tex2Dcmpbias( samp, s, texelOff )'] = cg_tex2Dcmpbias_3,
  ['tex2Dcmplod( samp, s )'] = cg_tex2Dcmplod_2,
  ['tex2Dcmplod( samp, s, texelOff )'] = cg_tex2Dcmplod_3,
  ['tex2Dfetch( samp, s )'] = cg_tex2Dfetch_2,
  ['tex2Dfetch( samp, s, texelOff )'] = cg_tex2Dfetch_3,
  ['tex2Dlod( samp, s )'] = cg_tex2Dlod_2,
  ['tex2Dlod( samp, s, texelOff )'] = cg_tex2Dlod_3,
  ['tex2Dproj( samp, s )'] = cg_tex2Dproj_2,
  ['tex2Dproj( samp, s, texelOff )'] = cg_tex2Dproj_3,
  ['tex2Dsize( samp, lod )'] = cg_tex2Dsize_2,
  ['tex3D( samp, s )'] = cg_tex3D_2,
  ['tex3D( samp, s, texelOff )'] = cg_tex3D_3,
  ['tex3D( samp, s, dx, dy )'] = cg_tex3D_4,
  ['tex3D( samp, s, dx, dy, texelOff )'] = cg_tex3D_5,
  ['tex3Dbias( samp, s )'] = cg_tex3Dbias_2,
  ['tex3Dbias( samp, s, texelOff )'] = cg_tex3Dbias_3,
  ['tex3Dfetch( samp, s )'] = cg_tex3Dfetch_2,
  ['tex3Dfetch( samp, s, texelOff )'] = cg_tex3Dfetch_3,
  ['tex3Dlod( samp, s )'] = cg_tex3Dlod_2,
  ['tex3Dlod( samp, s, texelOff )'] = cg_tex3Dlod_3,
  ['tex3Dproj( samp, s )'] = cg_tex3Dproj_2,
  ['tex3Dproj( samp, s, texelOff )'] = cg_tex3Dproj_3,
  ['tex3Dsize( samp, lod )'] = cg_tex3Dsize_2,
  ['texBUF( samp, s )'] = cg_texBUF_2,
  ['texBUFsize( samp, lod )'] = cg_texBUFsize_2,
  ['texCUBE( samp, s )'] = cg_texCUBE_2,
  ['texCUBE( samp, s, dx, dy )'] = cg_texCUBE_4,
  ['texCUBEARRAY( samp, s )'] = cg_texCUBEARRAY_2,
  ['texCUBEARRAY( samp, s, dx, dy )'] = cg_texCUBEARRAY_4,
  ['texCUBEARRAYsize( samp, lod )'] = cg_texCUBEARRAYsize_2,
  ['texCUBEbias( samp, s )'] = cg_texCUBEbias_2,
  ['texCUBElod( samp, s )'] = cg_texCUBElod_2,
  ['texCUBEproj( samp, s )'] = cg_texCUBEproj_2,
  ['texCUBEsize( samp, lod )'] = cg_texCUBEsize_2,
  ['texRECT( samp, s )'] = cg_texRECT_2,
  ['texRECT( samp, s, texelOff )'] = cg_texRECT_3,
  ['texRECT( samp, s, dx, dy )'] = cg_texRECT_4,
  ['texRECT( samp, s, dx, dy, texelOff )'] = cg_texRECT_5,
  ['texRECTbias( samp, s )'] = cg_texRECTbias_2,
  ['texRECTbias( samp, s, texelOff )'] = cg_texRECTbias_3,
  ['texRECTfetch( samp, s )'] = cg_texRECTfetch_2,
  ['texRECTfetch( samp, s, texelOff )'] = cg_texRECTfetch_3,
  ['texRECTlod( samp, s )'] = cg_texRECTlod_2,
  ['texRECTlod( samp, s, texelOff )'] = cg_texRECTlod_3,
  ['texRECTproj( samp, s )'] = cg_texRECTproj_2,
  ['texRECTproj( samp, s, texelOff )'] = cg_texRECTproj_3,
  ['texRECTsize( samp, lod )'] = cg_texRECTsize_2,
  ['transpose( A )'] = cg_transpose_1,
  ['trunc( x )'] = cg_trunc_1,
}
