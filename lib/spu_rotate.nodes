-- #################################################### --

local si_rotqbi = class(Node)

function si_rotqbi:get_help(out)
  out.write[[ Rotate Quadword by Bits  

 rt = ra <^ (rb.b[3] & 0x07) ]]
end

function si_rotqbi:new()
  Node.new(self)
  self.ra = self.add_port(Input('ra'))
  self.rb = self.add_port(Input('rb'))
  self.rt = self.add_port(Output('rt'))
end

function si_rotqbi:config(props)
  Node.config(self, props)
  props.delete('Name')
end

function si_rotqbi:gen_code(out, scratch)
  local rt = 'r' .. self.rt.hex()
  local ra = 'r' .. self.ra.get_output().hex()
  local rb = 'r' .. self.rb.get_output().hex()
  out.write( '\t .reg ' .. rt .. '\n')
  out.write( '\t rotqbi ' .. rt .. ', ' .. ra .. ', ' .. rb .. '\n' )
end

function si_rotqbi:get_tip(out)
  out.write('Rotate Quadword by Bits ')
end

function si_rotqbi:get_type(port)
  return 'qword'
end

-- #################################################### --

local si_rotqbii = class(Node)

function si_rotqbii:get_help(out)
  out.write[[ Rotate Quadword by Bits Immediate  

 rt = ra <^ (u3 & 0x07) ]]
end

function si_rotqbii:new()
  Node.new(self)
  self.ra  = self.add_port(Input('ra'))
  self.rt  = self.add_port(Output('rt'))
  self.u3 = 0
end

function si_rotqbii:config(props)
  Node.config(self, props)
  props.delete('Name')
  props.text_input(
                    'u3',
                    function() return self.u3 end,
                    function(v) self.u3 = v end,
                    function(v) return math.evaluate(v) end
                  )
end

function si_rotqbii:gen_code(out, scratch)
  local rt  = 'r' .. self.rt.hex()
  local ra  = 'r' .. self.ra.get_output().hex()
  local u3 = math.evaluate(self.u3)
  out.write( '\t .reg ' .. rt .. '\n')
  out.write( '\t rotqbii ' .. rt .. ', ' .. ra .. ', ' .. u3 .. '\n' )
end

function si_rotqbii:get_tip(out)
  out.write('Rotate Quadword by Bits Immediate ')
end

function si_rotqbii:get_type(port)
  return 'qword'
end

-- #################################################### --

local si_rotqby = class(Node)

function si_rotqby:get_help(out)
  out.write[[ Rotate Quadword by Bytes  

 rt = ra <^ ((rb.b[3] & 0x0F) * 8) ]]
end

function si_rotqby:new()
  Node.new(self)
  self.ra = self.add_port(Input('ra'))
  self.rb = self.add_port(Input('rb'))
  self.rt = self.add_port(Output('rt'))
end

function si_rotqby:config(props)
  Node.config(self, props)
  props.delete('Name')
end

function si_rotqby:gen_code(out, scratch)
  local rt = 'r' .. self.rt.hex()
  local ra = 'r' .. self.ra.get_output().hex()
  local rb = 'r' .. self.rb.get_output().hex()
  out.write( '\t .reg ' .. rt .. '\n')
  out.write( '\t rotqby ' .. rt .. ', ' .. ra .. ', ' .. rb .. '\n' )
end

function si_rotqby:get_tip(out)
  out.write('Rotate Quadword by Bytes ')
end

function si_rotqby:get_type(port)
  return 'qword'
end

-- #################################################### --

local si_rotqbyi = class(Node)

function si_rotqbyi:get_help(out)
  out.write[[ Rotate Quadword by Bytes Immediate  

 rt = ra <^ ((s7 & 0x0F) * 8) ]]
end

function si_rotqbyi:new()
  Node.new(self)
  self.ra  = self.add_port(Input('ra'))
  self.rt  = self.add_port(Output('rt'))
  self.s7 = 0
end

function si_rotqbyi:config(props)
  Node.config(self, props)
  props.delete('Name')
  props.text_input(
                    's7',
                    function() return self.s7 end,
                    function(v) self.s7 = v end,
                    function(v) return math.evaluate(v) end
                  )
end

function si_rotqbyi:gen_code(out, scratch)
  local rt  = 'r' .. self.rt.hex()
  local ra  = 'r' .. self.ra.get_output().hex()
  local s7 = math.evaluate(self.s7)
  out.write( '\t .reg ' .. rt .. '\n')
  out.write( '\t rotqbyi ' .. rt .. ', ' .. ra .. ', ' .. s7 .. '\n' )
end

function si_rotqbyi:get_tip(out)
  out.write('Rotate Quadword by Bytes Immediate ')
end

function si_rotqbyi:get_type(port)
  return 'qword'
end

-- #################################################### --

local si_rotqbybi = class(Node)

function si_rotqbybi:get_help(out)
  out.write[[ Rotate Quadword by Bytes from Bit Shift Count  

 rt = ra <^ (rb.b[3] & 0x78) ]]
end

function si_rotqbybi:new()
  Node.new(self)
  self.ra = self.add_port(Input('ra'))
  self.rb = self.add_port(Input('rb'))
  self.rt = self.add_port(Output('rt'))
end

function si_rotqbybi:config(props)
  Node.config(self, props)
  props.delete('Name')
end

function si_rotqbybi:gen_code(out, scratch)
  local rt = 'r' .. self.rt.hex()
  local ra = 'r' .. self.ra.get_output().hex()
  local rb = 'r' .. self.rb.get_output().hex()
  out.write( '\t .reg ' .. rt .. '\n')
  out.write( '\t rotqbybi ' .. rt .. ', ' .. ra .. ', ' .. rb .. '\n' )
end

function si_rotqbybi:get_tip(out)
  out.write('Rotate Quadword by Bytes from Bit Shift Count ')
end

function si_rotqbybi:get_type(port)
  return 'qword'
end

-- #################################################### --

local si_rot = class(Node)

function si_rot:get_help(out)
  out.write[[ Rotate Word  

 rt.w[n] = ra.w[n] <^ (rb.w[n] & 0x1F) ]]
end

function si_rot:new()
  Node.new(self)
  self.ra = self.add_port(Input('ra'))
  self.rb = self.add_port(Input('rb'))
  self.rt = self.add_port(Output('rt'))
end

function si_rot:config(props)
  Node.config(self, props)
  props.delete('Name')
end

function si_rot:gen_code(out, scratch)
  local rt = 'r' .. self.rt.hex()
  local ra = 'r' .. self.ra.get_output().hex()
  local rb = 'r' .. self.rb.get_output().hex()
  out.write( '\t .reg ' .. rt .. '\n')
  out.write( '\t rot ' .. rt .. ', ' .. ra .. ', ' .. rb .. '\n' )
end

function si_rot:get_tip(out)
  out.write('Rotate Word ')
end

function si_rot:get_type(port)
  return 'qword'
end

-- #################################################### --

local si_roti = class(Node)

function si_roti:get_help(out)
  out.write[[ Rotate Word Immediate  

 rt.w[n] = ra.w[n] <^ (s7 & 0x1F) ]]
end

function si_roti:new()
  Node.new(self)
  self.ra  = self.add_port(Input('ra'))
  self.rt  = self.add_port(Output('rt'))
  self.s7 = 0
end

function si_roti:config(props)
  Node.config(self, props)
  props.delete('Name')
  props.text_input(
                    's7',
                    function() return self.s7 end,
                    function(v) self.s7 = v end,
                    function(v) return math.evaluate(v) end
                  )
end

function si_roti:gen_code(out, scratch)
  local rt  = 'r' .. self.rt.hex()
  local ra  = 'r' .. self.ra.get_output().hex()
  local s7 = math.evaluate(self.s7)
  out.write( '\t .reg ' .. rt .. '\n')
  out.write( '\t roti ' .. rt .. ', ' .. ra .. ', ' .. s7 .. '\n' )
end

function si_roti:get_tip(out)
  out.write('Rotate Word Immediate ')
end

function si_roti:get_type(port)
  return 'qword'
end

-- #################################################### --

local si_roth = class(Node)

function si_roth:get_help(out)
  out.write[[ Rotate Halfword  

 rt.h[n] = ra.h[n] <^ (rb.h[n] & 0x0F) ]]
end

function si_roth:new()
  Node.new(self)
  self.ra = self.add_port(Input('ra'))
  self.rb = self.add_port(Input('rb'))
  self.rt = self.add_port(Output('rt'))
end

function si_roth:config(props)
  Node.config(self, props)
  props.delete('Name')
end

function si_roth:gen_code(out, scratch)
  local rt = 'r' .. self.rt.hex()
  local ra = 'r' .. self.ra.get_output().hex()
  local rb = 'r' .. self.rb.get_output().hex()
  out.write( '\t .reg ' .. rt .. '\n')
  out.write( '\t roth ' .. rt .. ', ' .. ra .. ', ' .. rb .. '\n' )
end

function si_roth:get_tip(out)
  out.write('Rotate Halfword ')
end

function si_roth:get_type(port)
  return 'qword'
end

-- #################################################### --

local si_rothi = class(Node)

function si_rothi:get_help(out)
  out.write[[ Rotate Halfword Immediate  

 rt.h[n] = ra.h[n] <^ (s7 & 0x0F) ]]
end

function si_rothi:new()
  Node.new(self)
  self.ra  = self.add_port(Input('ra'))
  self.rt  = self.add_port(Output('rt'))
  self.s7 = 0
end

function si_rothi:config(props)
  Node.config(self, props)
  props.delete('Name')
  props.text_input(
                    's7',
                    function() return self.s7 end,
                    function(v) self.s7 = v end,
                    function(v) return math.evaluate(v) end
                  )
end

function si_rothi:gen_code(out, scratch)
  local rt  = 'r' .. self.rt.hex()
  local ra  = 'r' .. self.ra.get_output().hex()
  local s7 = math.evaluate(self.s7)
  out.write( '\t .reg ' .. rt .. '\n')
  out.write( '\t rothi ' .. rt .. ', ' .. ra .. ', ' .. s7 .. '\n' )
end

function si_rothi:get_tip(out)
  out.write('Rotate Halfword Immediate ')
end

function si_rothi:get_type(port)
  return 'qword'
end

register {
  __name = 'SPU [Rotate (Left)]',
  __prologue = '',
  __epilogue = '',
  ['rotqbi'] = si_rotqbi,
  ['rotqbii'] = si_rotqbii,
  ['rotqby'] = si_rotqby,
  ['rotqbyi'] = si_rotqbyi,
  ['rotqbybi'] = si_rotqbybi,
  ['rot'] = si_rot,
  ['roti'] = si_roti,
  ['roth'] = si_roth,
  ['rothi'] = si_rothi,
}
